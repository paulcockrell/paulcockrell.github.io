shadow$provide.module$node_modules$kaplay$dist$kaplay_cjs = function(global, require, module, exports) {
  function I(...t) {
    if (0 === t.length) {
      return new K(255, 255, 255);
    }
    if (1 === t.length) {
      if (t[0] instanceof K) {
        return t[0].clone();
      }
      if ("string" == typeof t[0]) {
        return K.fromHex(t[0]);
      }
      if (Array.isArray(t[0]) && 3 === t[0].length) {
        return K.fromArray(t[0]);
      }
    } else if (2 === t.length) {
      if (t[0] instanceof K) {
        return t[0].clone();
      }
    } else if (3 === t.length || 4 === t.length) {
      return new K(t[0], t[1], t[2]);
    }
    throw Error("Invalid color arguments");
  }
  function ue(t) {
    return t * Math.PI / 180;
  }
  function lt(t) {
    return 180 * t / Math.PI;
  }
  function Se(t, e, n) {
    return e > n ? Se(t, n, e) : Math.min(Math.max(t, e), n);
  }
  function fe(t, e, n) {
    if ("number" == typeof t && "number" == typeof e) {
      return t + (e - t) * n;
    }
    if (t instanceof E && e instanceof E || t instanceof K && e instanceof K) {
      return t.lerp(e, n);
    }
    throw Error(`Bad value for lerp(): ${t}, ${e}. Only number, Vec2 and Color is supported.`);
  }
  function Ve(t, e, n, r, o) {
    return r + (t - e) / (n - e) * (o - r);
  }
  function Vo(t, e, n, r, o) {
    return Se(Ve(t, e, n, r, o), r, o);
  }
  function v(...t) {
    if (1 === t.length) {
      if (t[0] instanceof E) {
        return new E(t[0].x, t[0].y);
      }
      if (Array.isArray(t[0]) && 2 === t[0].length) {
        return new E(...t[0]);
      }
    }
    return new E(...t);
  }
  function me(t, e, n, r) {
    return new z(t, e, n, r);
  }
  function Vn(t, e, n, r = o => -Math.cos(o)) {
    return t + (r(n) + 1) / 2 * (e - t);
  }
  function Po(t) {
    return null != t && (wr.seed = t), wr.seed;
  }
  function ge(...t) {
    return wr.genAny(...t);
  }
  function Or(...t) {
    return Math.floor(ge(...(0 < t.length ? t : [2])));
  }
  function Go(t) {
    return ge() <= t;
  }
  function Er(t) {
    for (let e = t.length - 1; 0 < e; e--) {
      let n = Math.floor(Math.random() * (e + 1));
      [t[e], t[n]] = [t[n], t[e]];
    }
    return t;
  }
  function Mo(t, e) {
    return t.length <= e ? t.slice() : Er(t.slice()).slice(0, e);
  }
  function Ro(t) {
    return t[Or(t.length)];
  }
  function Tr(t, e) {
    return t.pos.x + t.width > e.pos.x && t.pos.x < e.pos.x + e.width && t.pos.y + t.height > e.pos.y && t.pos.y < e.pos.y + e.height;
  }
  function lu(t, e) {
    if (t.p1.x === t.p2.x && t.p1.y === t.p2.y || e.p1.x === e.p2.x && e.p1.y === e.p2.y) {
      return null;
    }
    let n = (e.p2.y - e.p1.y) * (t.p2.x - t.p1.x) - (e.p2.x - e.p1.x) * (t.p2.y - t.p1.y);
    if (0 === n) {
      return null;
    }
    let r = ((e.p2.x - e.p1.x) * (t.p1.y - e.p1.y) - (e.p2.y - e.p1.y) * (t.p1.x - e.p1.x)) / n;
    t = ((t.p2.x - t.p1.x) * (t.p1.y - e.p1.y) - (t.p2.y - t.p1.y) * (t.p1.x - e.p1.x)) / n;
    return 0 > r || 1 < r || 0 > t || 1 < t ? null : r;
  }
  function Pn(t, e) {
    return (e = lu(t, e)) ? v(t.p1.x + e * (t.p2.x - t.p1.x), t.p1.y + e * (t.p2.y - t.p1.y)) : null;
  }
  function Gn(t, e) {
    let n = e.p2.sub(e.p1), r = Number.NEGATIVE_INFINITY, o = Number.POSITIVE_INFINITY;
    if (0 != n.x) {
      var i = (t.pos.x - e.p1.x) / n.x;
      let a = (t.pos.x + t.width - e.p1.x) / n.x;
      r = Math.max(r, Math.min(i, a));
      o = Math.min(o, Math.max(i, a));
    }
    0 != n.y && (i = (t.pos.y - e.p1.y) / n.y, t = (t.pos.y + t.height - e.p1.y) / n.y, r = Math.max(r, Math.min(i, t)), o = Math.min(o, Math.max(i, t)));
    return o >= r && 0 <= o && 1 >= r;
  }
  function Bt(t, e) {
    return e.x > t.pos.x && e.x < t.pos.x + t.width && e.y > t.pos.y && e.y < t.pos.y + t.height;
  }
  function Do(t, e) {
    return v(Math.max(t.pos.x, Math.min(e.center.x, t.pos.x + t.width)), Math.max(t.pos.y, Math.min(e.center.y, t.pos.y + t.height))).sdist(e.center) <= e.radius * e.radius;
  }
  function Bo(t, e) {
    return Fo(e, new ye(t.points()));
  }
  function Mn(t, e) {
    e = e.sub(t.p1);
    t = t.p2.sub(t.p1);
    if (Math.abs(e.cross(t)) > Number.EPSILON) {
      return !1;
    }
    t = e.dot(t) / t.dot(t);
    return 0 <= t && 1 >= t;
  }
  function Ft(t, e) {
    var n = t.p2.sub(t.p1), r = n.dot(n), o = t.p1.sub(e.center);
    n = 2 * n.dot(o);
    o = o.dot(o) - e.radius * e.radius;
    let l = n * n - 4 * r * o;
    if (r <= Number.EPSILON || 0 > l) {
      return !1;
    }
    if (0 == l) {
      if (r = -n / (2 * r), 0 <= r && 1 >= r) {
        return !0;
      }
    } else {
      if (o = (-n + Math.sqrt(l)) / (2 * r), r = (-n - Math.sqrt(l)) / (2 * r), 0 <= o && 1 >= o || 0 <= r && 1 >= r) {
        return !0;
      }
    }
    return Rn(e, t.p1);
  }
  function Ar(t, e) {
    if (et(e, t.p1) || et(e, t.p2)) {
      return !0;
    }
    for (let n = 0; n < e.pts.length; n++) {
      if (Pn(t, new Te(e.pts[n], e.pts[(n + 1) % e.pts.length]))) {
        return !0;
      }
    }
    return !1;
  }
  function Rn(t, e) {
    return t.center.sdist(e) < t.radius * t.radius;
  }
  function mu(t, e) {
    return t.center.sdist(e.center) < (t.radius + e.radius) * (t.radius + e.radius);
  }
  function Qt(t, e) {
    let n = e.pts[e.pts.length - 1];
    for (let r of e.pts) {
      if (Ft(new Te(n, r), t)) {
        return !0;
      }
      n = r;
    }
    return Rn(t, e.pts[0]) ? !0 : et(e, t.center);
  }
  function Fo(t, e) {
    for (let n = 0; n < t.pts.length; n++) {
      if (Ar(new Te(t.pts[n], t.pts[(n + 1) % t.pts.length]), e)) {
        return !0;
      }
    }
    return !(!t.pts.some(n => et(e, n)) && !e.pts.some(n => et(t, n)));
  }
  function et(t, e) {
    let n = !1;
    t = t.pts;
    for (let o = 0, i = t.length - 1; o < t.length; i = o++) {
      t[o].y > e.y != t[i].y > e.y && e.x < (t[i].x - t[o].x) * (e.y - t[o].y) / (t[i].y - t[o].y) + t[o].x && (n = !n);
    }
    return n;
  }
  function Sr(t, e) {
    e = e.sub(t.center);
    var n = ue(t.angle);
    let r = Math.cos(n), o = Math.sin(n);
    n = e.x * r + e.y * o;
    e = -e.x * o + e.y * r;
    return 1 > n * n / (t.radiusX * t.radiusX) + e * e / (t.radiusY * t.radiusY);
  }
  function An(t, e) {
    var n = e.center.sub(t.center), r = ue(t.angle);
    let o = Math.cos(r), i = Math.sin(r);
    r = n.x * o + n.y * i;
    n = -n.x * i + n.y * o;
    return Sr(new ke(v(), t.radiusX + e.radius, t.radiusY + e.radius, 0), v(r, n));
  }
  function Lo(t, e) {
    let n = t.toMat2().inverse;
    return e = new Te(n.transform(e.p1.sub(t.center)), n.transform(e.p2.sub(t.center))), Ft(e, new we(v(), 1));
  }
  function pu(t, e) {
    if (t.radiusX === t.radiusY) {
      return An(e, new we(t.center, t.radiusX));
    }
    if (e.radiusX === e.radiusY) {
      return An(t, new we(e.center, e.radiusX));
    }
    var n = new bt(1 / t.radiusX ** 2, 0, 0, 0, 1 / t.radiusY ** 2, 0, 0, 0, -1), r = new bt(1 / e.radiusX ** 2, 0, 0, 0, 1 / e.radiusY ** 2, 0, 0, 0, -1), o = t.center.x, i = t.center.y, a = e.center.x, l = e.center.y;
    t = ue(t.angle);
    e = ue(e.angle);
    o = new bt(Math.cos(t), -Math.sin(t), o, Math.sin(t), Math.cos(t), i, 0, 0, 1);
    a = new bt(Math.cos(e), -Math.sin(e), a, Math.sin(e), Math.cos(e), l, 0, 0, 1);
    l = o.inverse;
    a = a.inverse;
    var f = l.transpose.mul(n).mul(l), O = a.transpose.mul(r).mul(a);
    r = f.m11;
    n = f.m12;
    a = f.m13;
    l = f.m21;
    o = f.m22;
    i = f.m23;
    e = f.m31;
    t = f.m32;
    let S = f.m33;
    f = O.m11;
    let R = O.m12, F = O.m13, j = O.m21, H = O.m22, q = O.m23, W = O.m31, N = O.m32, k = O.m33, Z = r * o * S - r * i * t - n * l * S + n * i * e + a * l * t - a * o * e;
    O = (r * o * k - r * i * N - r * t * q + r * S * H - n * l * k + n * i * W + n * e * q - n * S * j + a * l * N - a * o * W - a * e * H + a * t * j + l * t * F - l * S * R - o * e * F + o * S * f + i * e * R - i * t * f) / Z;
    r = (r * H * k - r * q * N - n * j * k + n * q * W + a * j * N - a * H * W - l * R * k + l * F * N + o * f * k - o * F * W - i * f * N + i * R * W + e * R * q - e * F * H - t * f * q + t * F * j + S * f * H - S * R * j) / Z;
    n = (f * H * k - f * q * N - R * j * k + R * q * W + F * j * N - F * H * W) / Z;
    return 0 <= O ? !(0 < -3 * r + O ** 2 && 0 > 3 * O * n + r * O ** 2 - 4 * r ** 2 && 0 < -27 * n ** 2 + 18 * n * O * r + O ** 2 * r ** 2 - 4 * O ** 3 * n - 4 * r ** 3) : !(0 < -3 * r + O ** 2 && 0 < -27 * n ** 2 + 18 * n * O * r + O ** 2 * r ** 2 - 4 * O ** 3 * n - 4 * r ** 3);
  }
  function jo(t, e) {
    return Vr(t, new ye(e.points()));
  }
  function Vr(t, e) {
    let n = t.toMat2().inverse;
    return e = new ye(e.pts.map(r => n.transform(r.sub(t.center)))), Qt(new we(v(), 1), e);
  }
  function du(t, e) {
    return t.x === e.x && t.y === e.y;
  }
  function fu(t, e) {
    return e instanceof E ? du(e, t.pt) : e instanceof we ? Rn(e, t.pt) : e instanceof Te ? Mn(e, t.pt) : e instanceof $ ? Bt(e, t.pt) : e instanceof ye ? et(e, t.pt) : e instanceof ke ? Sr(e, t.pt) : !1;
  }
  function hu(t, e) {
    return e instanceof E ? Mn(t, e) : e instanceof we ? Ft(t, e) : e instanceof Te ? null != Pn(t, e) : e instanceof $ ? Gn(e, t) : e instanceof ye ? Ar(t, e) : e instanceof ke ? Lo(e, t) : !1;
  }
  function gu(t, e) {
    return e instanceof E ? Rn(t, e) : e instanceof we ? mu(t, e) : e instanceof Te ? Ft(e, t) : e instanceof $ ? Do(e, t) : e instanceof ye ? Qt(t, e) : e instanceof ke ? An(e, t) : !1;
  }
  function bu(t, e) {
    return e instanceof E ? Bt(t, e) : e instanceof we ? Do(t, e) : e instanceof Te ? Gn(t, e) : e instanceof $ ? Tr(t, e) : e instanceof ye ? Bo(t, e) : e instanceof ke ? jo(e, t) : !1;
  }
  function yu(t, e) {
    return e instanceof E ? et(t, e) : e instanceof we ? Qt(e, t) : e instanceof Te ? Ar(e, t) : e instanceof $ ? Bo(e, t) : e instanceof ye ? Fo(e, t) : e instanceof ke ? Vr(e, t) : !1;
  }
  function xu(t, e) {
    return e instanceof E ? Sr(t, e) : e instanceof we ? An(t, e) : e instanceof Te ? Lo(t, e) : e instanceof $ ? jo(t, e) : e instanceof ye ? Vr(t, e) : e instanceof ke ? pu(e, t) : !1;
  }
  function Ko(t, e, n) {
    var o = n.p1;
    n = n.p2.sub(o);
    var u = e.cross(n);
    if (Math.abs(u) < Number.EPSILON) {
      return null;
    }
    let m = o.sub(t);
    o = m.cross(n) / u;
    if (0 >= o || 1 <= o) {
      return null;
    }
    u = m.cross(e) / u;
    if (0 >= u || 1 <= u) {
      return null;
    }
    n = n.normal().unit();
    return 0 < e.dot(n) && (n.x *= -1, n.y *= -1), {point:t.add(e.scale(o)), normal:n, fraction:o};
  }
  function vu(t, e, n) {
    let r = Number.NEGATIVE_INFINITY, o = Number.POSITIVE_INFINITY, i;
    if (0 != t.x) {
      var a = (n.pos.x - t.x) / e.x;
      let l = (n.pos.x + n.width - t.x) / e.x;
      i = v(-Math.sign(e.x), 0);
      r = Math.max(r, Math.min(a, l));
      o = Math.min(o, Math.max(a, l));
    }
    0 != t.y && (a = (n.pos.y - t.y) / e.y, n = (n.pos.y + n.height - t.y) / e.y, Math.min(a, n) > r && (i = v(0, -Math.sign(e.y))), r = Math.max(r, Math.min(a, n)), o = Math.min(o, Math.max(a, n)));
    return o >= r && 0 <= r && 1 >= r ? {point:t.add(e.scale(r)), normal:i, fraction:r} : null;
  }
  function Io(t, e, n) {
    let o = n.center;
    var a = e.dot(e), l = t.sub(o), u = 2 * e.dot(l);
    n = l.dot(l) - n.radius * n.radius;
    l = u * u - 4 * a * n;
    if (a <= Number.EPSILON || 0 > l) {
      return null;
    }
    if (0 == l) {
      if (a = -u / (2 * a), 0 <= a && 1 >= a) {
        return t = t.add(e.scale(a)), {point:t, normal:t.sub(o), fraction:a};
      }
    } else {
      if (n = (-u + Math.sqrt(l)) / (2 * a), u = (-u - Math.sqrt(l)) / (2 * a), a = null, 0 <= n && 1 >= n && (a = n), 0 <= u && 1 >= u && (a = Math.min(u, a ?? u)), null != a) {
        return t = t.add(e.scale(a)), {point:t, normal:t.sub(o).unit(), fraction:a};
      }
    }
    return null;
  }
  function Cu(t, e, n) {
    n = n.pts;
    let o = null;
    var i = n[n.length - 1];
    for (let a = 0; a < n.length; a++) {
      let l = n[a];
      (i = Ko(t, e, new Te(i, l))) && (!o || o.fraction > i.fraction) && (o = i);
      i = l;
    }
    return o;
  }
  function wu(t, e, n) {
    var r = n.toMat2(), o = r.inverse, i = o.transform(t.sub(n.center));
    o = o.transform(e);
    let l = Io(i, o, new we(v(), 1));
    return l ? (i = Dt.rotation(ue(-n.angle)), o = Dt.scale(n.radiusX, n.radiusY).transform(l.point), r = r.transform(l.point).add(n.center), t = r.dist(t) / e.len(), {point:r, normal:i.transform(v(n.radiusY ** 2 * o.x, n.radiusX ** 2 * o.y)).unit(), fraction:t}) : l;
  }
  function ko(t, e, n, r = 64) {
    let i = e.len();
    e = e.scale(1 / i);
    let l = 0, u = v(Math.floor(t.x), Math.floor(t.y)), m = v(0 < e.x ? 1 : -1, 0 < e.y ? 1 : -1), d = v(Math.abs(1 / e.x), Math.abs(1 / e.y));
    var C = v(0 < m.x ? u.x + 1 - t.x : t.x - u.x, 0 < m.y ? u.y + 1 - t.y : t.y - u.y);
    C = v(d.x < 1 / 0 ? d.x * C.x : 1 / 0, d.y < 1 / 0 ? d.y * C.y : 1 / 0);
    let b = -1;
    for (; l <= r;) {
      let f = n(u);
      if (!0 === f) {
        return {point:t.add(e.scale(l)), normal:v(0 === b ? -m.x : 0, 1 === b ? -m.y : 0), fraction:l / i, gridPos:u};
      }
      if (f) {
        return f;
      }
      C.x < C.y ? (u.x += m.x, l = C.x, C.x += d.x, b = 0) : (u.y += m.y, l = C.y, C.y += d.y, b = 1);
    }
    return null;
  }
  function Ou(t, e, n, r) {
    e = e.sub(t);
    r = r.sub(n);
    let a = e.cross(r);
    return 1E-5 > a && -1E-5 < a || (a = n.sub(t).cross(r) / a, 0 > a || 1 < a) ? null : t.add(e.scale(a));
  }
  function _o(t, e, n, r) {
    let o = r * r, i = 1 - r;
    return t.scale(i * i).add(e.scale(2 * i * r)).add(n.scale(o));
  }
  function No(t, e, n, r) {
    let o = 1 - r;
    return e.sub(t).scale(2 * o).add(n.sub(e).scale(2 * r));
  }
  function Uo(t, e, n, r) {
    return n.sub(e.scale(2)).add(t).scale(2);
  }
  function Jt(t, e, n, r, o) {
    let i = o * o, a = i * o, l = 1 - o, u = l * l;
    return t.scale(u * l).add(e.scale(3 * u * o)).add(n.scale(3 * l * i)).add(r.scale(a));
  }
  function Ho(t, e, n, r, o) {
    let i = o * o, a = 1 - o, l = a * a;
    return e.sub(t).scale(3 * l).add(n.sub(e).scale(6 * a * o)).add(r.sub(n).scale(3 * i));
  }
  function qo(t, e, n, r, o) {
    let i = 1 - o;
    return n.sub(e.scale(2)).add(t).scale(6 * i).add(r.sub(n.scale(2)).add(e).scale(6 * o));
  }
  function zo(t, e, n, r, o) {
    let a = .5 * ((3 * o - 5) * o * o + 2), l = .5 * ((-3 * o + 4) * o + 1) * o, u = .5 * (o - 1) * o * o;
    return t.scale(.5 * ((-o + 2) * o - 1) * o).add(e.scale(a)).add(n.scale(l)).add(r.scale(u));
  }
  function Yo(t, e, n, r, o) {
    let a = .5 * (9 * o - 10) * o, l = .5 * ((-9 * o + 8) * o + 1), u = .5 * (3 * o - 2) * o;
    return t.scale(.5 * ((-3 * o + 4) * o - 1)).add(e.scale(a)).add(n.scale(l)).add(r.scale(u));
  }
  function Wo(t) {
    let e = Pr(t), n = e(1);
    return r => {
      r = e(r * n, !0);
      return t(r);
    };
  }
  function Pr(t, e = 10, n = 10) {
    let r = [0], o = [0], a = 1 / (e - 1) / n, l = 0;
    var u = t(0);
    let m = 0;
    for (let d = 1; d < e; d++) {
      for (let C = 0; C < n; C++) {
        m += a;
        let p = t(m);
        u = p.dist(u);
        l += u;
        u = p;
      }
      r[d] = l;
      o[d] = m;
    }
    return o[e - 1] = 1, (d, C = !1) => {
      if (C) {
        if (0 >= d) {
          return 0;
        }
        if (d >= l) {
          return 1;
        }
        for (C = 0; r[C + 1] < d;) {
          C++;
        }
        var f = o[C], g = r[C];
        return f + (d - g) / (r[C + 1] - g) * (o[C + 1] - f);
      }
      if (0 >= d) {
        return 0;
      }
      if (1 <= d) {
        return r[e - 1];
      }
      for (C = 0; o[C + 1] < d;) {
        C++;
      }
      f = o[C];
      g = r[C];
      return g + (d - f) / (o[C + 1] - f) * (r[C + 1] - g);
    };
  }
  function Lt(t, e, n, r) {
    let o = 2 * t + e - 2 * r + n, i = -3 * t + 3 * r - 2 * e - n;
    return u => {
      let m = u * u;
      return o * m * u + i * m + e * u + t;
    };
  }
  function Gr(t, e, n, r, o, i = Lt) {
    let a = i(e.x, (1 - o) * (n.x - t.x), (1 - o) * (r.x - e.x), n.x), l = i(e.y, (1 - o) * (n.y - t.y), (1 - o) * (r.y - e.y), n.y);
    return u => new E(a(u), l(u));
  }
  function jt(t, e, n, r, o = Lt) {
    return Gr(t, e, n, r, .5, o);
  }
  function $o(t, e, n, r, o = Lt) {
    return jt(r.add(t.sub(e).scale(6)), t, r, t.add(r.sub(n).scale(6)), o);
  }
  function Xo(t, e, n, r, o, i, a, l = Lt) {
    let u = l(e.x, .5 * (1 - o) * (1 + a) * (1 + i) * (e.x - t.x) + .5 * (1 - o) * (1 - a) * (1 - i) * (n.x - e.x), .5 * (1 - o) * (1 + a) * (1 - i) * (n.x - e.x) + .5 * (1 - o) * (1 - a) * (1 + i) * (r.x - n.x), n.x), m = l(e.y, .5 * (1 - o) * (1 + a) * (1 + i) * (e.y - t.y) + .5 * (1 - o) * (1 - a) * (1 - i) * (n.y - e.y), .5 * (1 - o) * (1 + a) * (1 - i) * (n.y - e.y) + .5 * (1 - o) * (1 - a) * (1 + i) * (r.y - n.y), n.y);
    return d => new E(u(d), m(d));
  }
  function Qo(t, e, n, r) {
    let o = 2 * t + e - 2 * r + n, i = -3 * t + 3 * r - 2 * e + n;
    return l => 3 * o * l * l + 2 * i * l + e;
  }
  function Wt(t) {
    return 0 <= t && 1 >= t;
  }
  function vr(t, e) {
    return Math.abs(t - e) <= Number.EPSILON;
  }
  function $t(t) {
    return 0 > t ? -Math.pow(-t, 1 / 3) : Math.pow(t, 1 / 3);
  }
  function Eu(t, e, n, r) {
    var o = 3 * t - 6 * e + 3 * n, i = -3 * t + 3 * e, a = t;
    n = -t + 3 * e - 3 * n + r;
    if (vr(n, 0)) {
      if (vr(o, 0)) {
        return vr(i, 0) ? [] : [-a / i].filter(Wt);
      }
      a = Math.sqrt(i * i - 4 * o * a);
      o *= 2;
      return [(a - i) / o, (-i - a) / o].filter(Wt);
    }
    o /= n;
    i /= n;
    t = (3 * i - o * o) / 3;
    e = t / 3;
    i = (2 * o * o * o - 9 * o * i + a / n * 27) / 27;
    a = i / 2;
    e = a * a + e * e * e;
    if (0 > e) {
      return a = -t / 3, a = Math.sqrt(a * a * a), i = -i / (2 * a), i = Math.acos(-1 > i ? -1 : 1 < i ? 1 : i), a = 2 * $t(a), [a * Math.cos(i / 3) - o / 3, a * Math.cos((i + 2 * Math.PI) / 3) - o / 3, a * Math.cos((i + 4 * Math.PI) / 3) - o / 3].filter(Wt);
    }
    if (0 === e) {
      return i = 0 > a ? $t(-a) : -$t(a), [2 * i - o / 3, -i - o / 3].filter(Wt);
    }
    t = Math.sqrt(e);
    i = $t(t - a);
    a = $t(t + a);
    return [i - a - o / 3].filter(Wt);
  }
  function Tu(t, e, n, r, o) {
    o = Eu(t.x - o, e.x - o, n.x - o, r.x - o);
    return 0 < o.length ? Jt(t, e, n, r, o[0]).y : NaN;
  }
  function Jo(t) {
    if (!t || 0 == t.length) {
      throw Error("Need at least one point for easingLinear.");
    }
    let e = t.length;
    return n => {
      if (0 >= n || 1 == t.length || n <= t[0].x) {
        return t[0].y;
      }
      for (let r = 0; r < e; r++) {
        if (t[r].x >= n) {
          return Ve(n, t[r - 1].x, t[r].x, t[r - 1].y, t[r].y);
        }
      }
      return t[t.length - 1].y;
    };
  }
  function Zo(t, e) {
    return n => Tu(v(0, 0), t, e, v(1, 1), n);
  }
  function es(t, e = "jump-end") {
    let n = 1 / t, i = 1 / (t + ("jump-end" == e || "jump-both" == e ? 1 : 0)), a = "jump-start" == e || "jump-both" == e ? i : 0;
    return l => a + Math.floor(l / n) * i;
  }
  function ts(t, e) {
    var n = Number.MAX_VALUE;
    let r = {normal:v(0), distance:0};
    for (let o of [t, e]) {
      for (let i = 0; i < o.pts.length; i++) {
        let u = o.pts[(i + 1) % o.pts.length].sub(o.pts[i]).normal().unit(), m = Number.MAX_VALUE;
        var d = -Number.MAX_VALUE;
        for (var f = 0; f < t.pts.length; f++) {
          var O$jscomp$0 = t.pts[f].dot(u);
          m = Math.min(m, O$jscomp$0);
          d = Math.max(d, O$jscomp$0);
        }
        f = Number.MAX_VALUE;
        O$jscomp$0 = -Number.MAX_VALUE;
        for (var f$jscomp$0 = 0; f$jscomp$0 < e.pts.length; f$jscomp$0++) {
          let O = e.pts[f$jscomp$0].dot(u);
          f = Math.min(f, O);
          O$jscomp$0 = Math.max(O$jscomp$0, O);
        }
        f$jscomp$0 = Math.min(d, O$jscomp$0) - Math.max(m, f);
        if (0 > f$jscomp$0) {
          return null;
        }
        f$jscomp$0 < Math.abs(n) && (n = O$jscomp$0 - m, d = f - d, n = Math.abs(n) < Math.abs(d) ? n : d, r.normal = u, r.distance = n);
      }
    }
    return r;
  }
  function ns(t, e, n) {
    return 0 <= (e.x - t.x) * (n.y - t.y) - (e.y - t.y) * (n.x - t.x);
  }
  function Au(t) {
    let e = 0, n = t[t.length - 1];
    for (let r = 0; r < t.length; r++) {
      e += (t[r].x - n.x) * (t[r].y + n.y), n = t[r];
    }
    return 0 > e;
  }
  function Cr(t, e, n, r) {
    let o = r.x - n.x;
    r = r.y - n.y;
    return 0 <= (o * (t.y - n.y) - r * (t.x - n.x)) * (o * (e.y - n.y) - r * (e.x - n.x));
  }
  function Su(t, e, n, r) {
    return Cr(t, e, n, r) && Cr(t, n, e, r) && Cr(t, r, e, n);
  }
  function Vu(t, e, n, r) {
    for (let o of t) {
      if (o !== e && o !== n && o !== r && Su(o, e, n, r)) {
        return !0;
      }
    }
    return !1;
  }
  function Pu(t, e, n, r) {
    return ns(t, e, n) && !Vu(r, t, e, n);
  }
  function Dn(t) {
    if (3 > t.length) {
      return [];
    }
    if (3 == t.length) {
      return [t];
    }
    let e = [], n = [];
    for (var C$jscomp$0 = 0; C$jscomp$0 < t.length; C$jscomp$0++) {
      e[C$jscomp$0] = C$jscomp$0 + 1, n[C$jscomp$0] = C$jscomp$0 - 1;
    }
    e[e.length - 1] = 0;
    n[0] = n.length - 1;
    Au(t) || ([e, n] = [n, e]);
    C$jscomp$0 = [];
    for (var C$jscomp$1 = 0; C$jscomp$1 < t.length; ++C$jscomp$1) {
      ns(t[n[C$jscomp$1]], t[C$jscomp$1], t[e[C$jscomp$1]]) || C$jscomp$0.push(t[C$jscomp$1]);
    }
    C$jscomp$1 = [];
    let a = t.length;
    var l = 1;
    let u = 0, m, d;
    for (; 3 < a;) {
      m = e[l];
      d = n[l];
      let C = t[d];
      l = t[l];
      let b = t[m];
      if (Pu(C, l, b, C$jscomp$0)) {
        C$jscomp$1.push([C, l, b]), e[d] = m, n[m] = d, C$jscomp$0.splice(C$jscomp$0.indexOf(l), 1), --a, u = 0;
      } else if (++u > a) {
        return [];
      }
      l = m;
    }
    return m = e[l], d = n[l], C$jscomp$1.push([t[d], t[l], t[m]]), C$jscomp$1;
  }
  function rs(t) {
    if (3 > t.length) {
      return !1;
    }
    let e = t.length - 2, n = t.length - 1, r = 0, o = t[n].sub(t[e]), i = t[r].sub(t[n]), a = o.cross(i);
    for (; r + 1 < t.length;) {
      if (e = n, n = r, r++, o = t[n].sub(t[e]), i = t[r].sub(t[n]), 0 > o.cross(i) * a) {
        return !1;
      }
    }
    return !0;
  }
  function Mu(t) {
    t = window.atob(t);
    let n = t.length, r = new Uint8Array(n);
    for (let o = 0; o < n; o++) {
      r[o] = t.charCodeAt(o);
    }
    return r.buffer;
  }
  function ys(t) {
    return Mu(t.split(",")[1]);
  }
  function Ln(t, e) {
    let n = document.createElement("a");
    n.href = e;
    n.download = t;
    n.click();
  }
  function Mr(t, e) {
    Ln(t, "data:text/plain;charset\x3dutf-8," + e);
  }
  function xs(t, e) {
    Mr(t, JSON.stringify(e));
  }
  function Rr(t, e) {
    e = URL.createObjectURL(e);
    Ln(t, e);
    URL.revokeObjectURL(e);
  }
  function Kn(t, e) {
    if (t === e) {
      return !0;
    }
    var n = typeof t, r = typeof e;
    if (n !== r) {
      return !1;
    }
    if ("object" === n && "object" === r && null !== t && null !== e) {
      if (Array.isArray(t) !== Array.isArray(e)) {
        return !1;
      }
      n = Object.keys(t);
      r = Object.keys(e);
      if (n.length !== r.length) {
        return !1;
      }
      for (let a of n) {
        if (!Kn(t[a], e[a])) {
          return !1;
        }
      }
      return !0;
    }
    return !1;
  }
  function Ru(t) {
    Cs.has(t) || (Cs.add(t), console.warn(t));
  }
  function tt(t, e) {
    Ru(`${t} is deprecated. Use ${e} instead.`);
  }
  function on(t, e) {
    return Number(t.toFixed(e));
  }
  function re(t, e) {
    return (...n) => {
      let r = n.length;
      if (r === t.length) {
        return t(...n);
      }
      if (r === e.length) {
        return e(...n);
      }
    };
  }
  function Es(t) {
    if ("string" != typeof t) {
      throw new TypeError("string cannot be undefined or null");
    }
    let e = [], n = 0, r = 0;
    for (; n < t.length;) {
      (r += Bu(n + r, t), _u(t[n + r]) && r++, Ku(t[n + r]) && r++, Iu(t[n + r]) && r++, Nu(t[n + r])) ? r++ : (e.push(t.substring(n, n + r)), n += r, r = 0);
    }
    return e;
  }
  function Bu(t, e) {
    var n = e[t];
    if (!Fu(n) || t === e.length - 1) {
      return 1;
    }
    n += e[t + 1];
    let o = e.substring(t + 2, t + 5);
    return Os(n) && Os(o) ? 4 : Lu(n) && ku(o) ? e.slice(t).indexOf(String.fromCodePoint(917631)) + 2 : ju(o) ? 4 : 2;
  }
  function Fu(t) {
    return t && xt(t[0].charCodeAt(0), 55296, 56319);
  }
  function Os(t) {
    return xt(Dr(t), 127462, 127487);
  }
  function Lu(t) {
    return xt(Dr(t), 127988, 127988);
  }
  function ju(t) {
    return xt(Dr(t), 127995, 127999);
  }
  function Ku(t) {
    return "string" == typeof t && xt(t.charCodeAt(0), 65024, 65039);
  }
  function Iu(t) {
    return "string" == typeof t && xt(t.charCodeAt(0), 8400, 8447);
  }
  function ku(t) {
    let e = t.codePointAt(0);
    return "string" == typeof t && "number" == typeof e && xt(e, 917504, 917631);
  }
  function _u(t) {
    return "string" == typeof t && Du.includes(t.charCodeAt(0));
  }
  function Nu(t) {
    return "string" == typeof t && 8205 === t.charCodeAt(0);
  }
  function Dr(t) {
    let e = t.charCodeAt(0) - 55296;
    t = t.charCodeAt(1) - 56320;
    return (e << 10) + t + 65536;
  }
  function xt(t, e, n) {
    return t >= e && t <= n;
  }
  function te() {
    return c.app.dt();
  }
  function an() {
    return c.app.fixedDt();
  }
  function un() {
    return c.app.restDt();
  }
  function Ne(t) {
    switch(t) {
      case "topleft":
        return qu;
      case "top":
        return zu;
      case "topright":
        return Yu;
      case "left":
        return Wu;
      case "center":
        return $u;
      case "right":
        return Xu;
      case "botleft":
        return Qu;
      case "bot":
        return Ju;
      case "botright":
        return Zu;
      default:
        return t;
    }
  }
  function Ms(t) {
    switch(t) {
      case "left":
        return 0;
      case "center":
        return .5;
      case "right":
        return 1;
      default:
        return 0;
    }
  }
  function Rs(t) {
    return t.createBuffer(1, 1, 44100);
  }
  function ec(t, e, n) {
    let r = [];
    for (r.push(e); e !== t;) {
      if (e = n.get(e), null == e) {
        return null;
      }
      r.push(e);
    }
    return r.reverse();
  }
  function Lr(t, e, n) {
    let r = new Kt((a, l) => a.cost < l.cost);
    r.insert({cost:0, node:e});
    let o = new Map();
    o.set(e, e);
    let i = new Map();
    for (i.set(e, 0); 0 !== r.length;) {
      let a = r.remove()?.node;
      if (a === n) {
        break;
      }
      var l = t.getNeighbours(a);
      for (let u of l) {
        l = (i.get(a) || 0) + t.getCost(a, u) + t.getHeuristic(u, n), (!i.has(u) || l < i.get(u)) && (i.set(u, l), r.insert({cost:l, node:u}), o.set(u, a));
      }
    }
    return ec(e, n, o);
  }
  function dt(t) {
    let e = new he();
    return t.pos && e.translate(t.pos), t.scale && e.scale(t.scale), t.angle && e.rotate(t.angle), t.parent ? e.mult(t.parent.transform) : e;
  }
  function Ls(t) {
    return new E(t.x / ae() * 2 - 1, -t.y / ce() * 2 + 1);
  }
  function Ct(t, e, n, r, o, i = 1) {
    r = ue(r % 360);
    o = ue(o % 360);
    o <= r && (o += 2 * Math.PI);
    let a = [];
    i = Math.ceil((o - r) / ue(8) * i);
    o = (o - r) / i;
    r = v(Math.cos(r), Math.sin(r));
    o = v(Math.cos(o), Math.sin(o));
    for (let C = 0; C <= i; C++) {
      a.push(t.add(e * r.x, n * r.y)), r = v(r.x * o.x - r.y * o.y, r.x * o.y + r.y * o.x);
    }
    return a;
  }
  function js(...t) {
    let e = I(...t);
    t = t[3] ?? 1;
    c.gfx.bgColor = e;
    c.gfx.bgAlpha = t;
    c.gfx.ggl.gl.clearColor(e.r / 255, e.g / 255, e.b / 255, t);
  }
  function Ks() {
    return c.gfx.bgColor?.clone?.() ?? null;
  }
  function Q(...t) {
    void 0 !== t[0] && (t = v(...t), 0 === t.x && 0 === t.y || c.gfx.transform.translate(t));
  }
  function be() {
    c.gfx.transformStack.push(c.gfx.transform.clone());
  }
  function Is(t) {
    c.gfx.transform = t.clone();
  }
  function rt(...t) {
    void 0 !== t[0] && (t = v(...t), 1 === t.x && 1 === t.y || c.gfx.transform.scale(t));
  }
  function $e(t) {
    t && c.gfx.transform.rotate(t);
  }
  function pe() {
    0 < c.gfx.transformStack.length && (c.gfx.transform = c.gfx.transformStack.pop());
  }
  function Oe() {
    c.gfx.renderer.flush();
  }
  function ae() {
    return c.gfx.width;
  }
  function ce() {
    return c.gfx.height;
  }
  function Nn() {
    return (c.gfx.viewport.width + c.gfx.viewport.height) / (c.gfx.width + c.gfx.height);
  }
  function ks(t) {
    return new E(t.x * c.gfx.viewport.width / c.gfx.width, t.y * c.gfx.viewport.height / c.gfx.height);
  }
  function tc(t) {
    return new E((t.x - c.gfx.viewport.x) * ae() / c.gfx.viewport.width, (t.y - c.gfx.viewport.y) * ce() / c.gfx.viewport.height);
  }
  function Un() {
    return tc(c.app.mousePos());
  }
  function wt() {
    return v(ae() / 2, ce() / 2);
  }
  function de(t) {
    return "string" != typeof t || jn(t) ? t : c.assets.urlPrefix + t;
  }
  function _r(t) {
    return fetch(t).then(e => {
      if (!e.ok) {
        throw Error(`Failed to fetch "${t}"`);
      }
      return e;
    });
  }
  function Ot(t) {
    return _r(t).then(e => e.json());
  }
  function _s(t) {
    return _r(t).then(e => e.text());
  }
  function Ns(t) {
    return _r(t).then(e => e.arrayBuffer());
  }
  function Us(t) {
    return void 0 !== t && (c.assets.urlPrefix = t), c.assets.urlPrefix;
  }
  function Hs(t, e) {
    return c.assets.custom.add(t, Ot(de(e)));
  }
  function Et(t) {
    let e = new Image();
    return e.crossOrigin = "anonymous", e.src = t, new Promise((n, r) => {
      e.onload = () => n(e);
      e.onerror = () => r(Error(`Failed to load image from "${t}"`));
    });
  }
  function Fe() {
    let t = [c.assets.sprites, c.assets.sounds, c.assets.shaders, c.assets.fonts, c.assets.bitmapFonts, c.assets.custom];
    return t.reduce((e, n) => e + n.progress(), 0) / t.length;
  }
  function Hn() {
    return [c.assets.sprites, c.assets.sounds, c.assets.shaders, c.assets.fonts, c.assets.bitmapFonts, c.assets.custom].reduce((e, n) => e.concat(n.getFailedAssets()), []);
  }
  function qs(t) {
    return c.assets.custom.get(t) ?? null;
  }
  function ln(t) {
    return c.assets.custom.add(null, t);
  }
  function It(t) {
    if ("string" == typeof t) {
      let e = Nr(t);
      if (e) {
        return e;
      }
      if (1 > Fe()) {
        return null;
      }
      throw Error(`Sprite not found: ${t}`);
    }
    if (t instanceof Le) {
      return le.loaded(t);
    }
    if (t instanceof le) {
      return t;
    }
    throw Error(`Invalid sprite: ${t}`);
  }
  function Nr(t) {
    return c.assets.sprites.get(t) ?? null;
  }
  function Tt(t, e, n = {sliceX:1, sliceY:1, anims:{}}) {
    return e = de(e), Array.isArray(e) ? e.some(r => "string" == typeof r) ? c.assets.sprites.add(t, Promise.all(e.map(r => "string" == typeof r ? Et(r) : Promise.resolve(r))).then(r => Ws(r, n))) : c.assets.sprites.addLoaded(t, Ws(e, n)) : "string" == typeof e ? c.assets.sprites.add(t, Le.from(e, n)) : c.assets.sprites.addLoaded(t, Le.fromImage(e, n));
  }
  function Ur(t = 1, e = 1, n = 0, r = 0, o = 1, i = 1) {
    let a = [];
    o /= t;
    i /= e;
    for (let m = 0; m < e; m++) {
      for (let d = 0; d < t; d++) {
        a.push(new z(n + d * o, r + m * i, o, i));
      }
    }
    return a;
  }
  function Ws(t, e = {}) {
    var n = document.createElement("canvas");
    let r = t[0].width, o = t[0].height;
    n.width = r * t.length;
    n.height = o;
    let i = n.getContext("2d");
    if (!i) {
      throw Error("Failed to create canvas context");
    }
    t.forEach((l, u) => {
      l instanceof ImageData ? i.putImageData(l, u * r, 0) : i.drawImage(l, u * r, 0);
    });
    n = i.getImageData(0, 0, t.length * r, o);
    return Le.fromImage(n, {...e, sliceX:t.length, sliceY:1});
  }
  function $s(t = "bean") {
    return Tt(t, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD0AAAA1CAYAAADyMeOEAAAAAXNSR0IArs4c6QAAAoVJREFUaIHdm7txwkAQhheGAqACiCHzOKQDQrqgILpwSAeEDBnEUAF0gCMxZ7G72qce/mec2Lpf9+3unaS78wgSNZ8uX5729+d1FNWXUuGmXlBOUUEIMckEpeQJgBu6C+BSFngztBR2vd+ovY+7g+p6LbgaWgJrAeUkDYIUXgXdBBwNi6kpABJwMTQH3AZsXRR8GHTfgEth8E3gjdAUcNewpbTgY85sCMCUuOokozE0YM0YRzM9NGAAXd8+omAF5h4lnmBRvpSnZHyLoLEbaN+aKB9KWv/KWw0tAbbANnlG+UvB2dm77NxxdwgBpjrF/d7rW9cbmpvio2A5z8iAYpVU8pGZlo6/2+MSco2lHfd3rv9jAP038e1xef9o2mjvYb2OqpqKE81028/jeietlSEVO5FRWsxWsJit1G3aFpW8iWe5RwpiCZAk25QvV6nz6fIlynRGuTd5WqpJ4guAlDfVKBK87hXljflgv1ON6fV+4+5gVlA17SfeG0heKqQd4l4jI/wrmaA9N9R4ar+wpHJDZyrrfcH0nB66PqAzPi76pn+faSyJk/vzOorYhGurQrzj/P68jtBMawHaHBIR9xoD5O34dy0qQOSYHvqExq2TpT2nf76+w7y251OYF0CRaU+J920TwLUa6inx6OxE6g80lu2ux7Y2eJLF/rCXE6zEPdnenk9o+4ih9AEdnW2q81HXl5LuU6OTl2fXUhqganbXAGq3g6jJOWV/OnoesO6YqqEB/GdNsjf7uHtwj2DzmRNpp7iOZfm6D9oAxB6Yi1gC4oIYeo4MIPdopEQRB+cAko5J1tW386HpB2Kz1eop4Epdwls/kgZ1sh8gZsEjdcWkr//D8Qu3Z3l5Nl1NtAAAAABJRU5ErkJggg\x3d\x3d");
  }
  function Xs(t, e, n) {
    e = de(e);
    n = de(n);
    "string" == typeof e && !n && (n = vs(e) + ".json");
    n = "string" == typeof n ? Ot(n) : Promise.resolve(n);
    return c.assets.sprites.add(t, n.then(o => {
      let i = o.meta.size, a = o.frames.map(u => new z(u.frame.x / i.w, u.frame.y / i.h, u.frame.w / i.w, u.frame.h / i.h)), l = {};
      for (let u of o.meta.frameTags) {
        u.from === u.to ? l[u.name] = u.from : l[u.name] = {from:u.from, to:u.to, speed:10, loop:!0, pingpong:"pingpong" === u.direction};
      }
      return Le.from(e, {frames:a, anims:l});
    }));
  }
  function Hr(t) {
    if (!t) {
      return Hr(c.globalOpt.font ?? "monospace");
    }
    if ("string" == typeof t) {
      let e = qn(t), n = qr(t);
      if (e) {
        return e.data ?? e;
      }
      if (n) {
        return n.data ?? n;
      }
      if (document.fonts.check(`${64}px ${t}`)) {
        return t;
      }
      if (1 > Fe()) {
        return null;
      }
      throw Error(`Font not found: ${t}`);
    }
    return t instanceof le ? t.data ? t.data : t : t;
  }
  function qr(t) {
    return c.assets.fonts.get(t) ?? null;
  }
  function Qs(t, e, n = {}) {
    let r = de(e);
    e = new FontFace(t, "string" == typeof e ? `url(${r})` : r);
    return document.fonts.add(e), c.assets.fonts.add(t, e.load().catch(i => {
      throw Error(`Failed to load font from "${r}": ${i}`);
    }).then(i => new At(i, n)));
  }
  function Js(t, e, n, r) {
    let o = t.width / e, i = {};
    r = r.split("").entries();
    for (let [l, u] of r) {
      i[u] = new z(l % o * e, Math.floor(l / o) * n, e, n);
    }
    return {tex:t, map:i, size:n};
  }
  function qn(t) {
    return c.assets.bitmapFonts.get(t) ?? null;
  }
  function Zs(t, e, n, r, o = {}) {
    e = de(e);
    return c.assets.bitmapFonts.add(t, Et(e).then(a => Js(Pe.fromImage(c.gfx.ggl, a, o), n, r, o.chars ?? " !\"#$%\x26'()*+,-./0123456789:;\x3c\x3d\x3e?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~")));
  }
  function ei(t, e) {
    return e = de(e), c.assets.sprites.add(t, new Promise(async n => {
      let r = "string" == typeof e ? await Ot(e) : e;
      var o = await Promise.all(r.frames.map(Et));
      let i = document.createElement("canvas");
      i.width = r.width;
      i.height = r.height * r.frames.length;
      let a = i.getContext("2d");
      if (!a) {
        throw Error("Failed to create canvas context");
      }
      o.forEach((u, m) => {
        a.drawImage(u, 0, m * r.height);
      });
      o = await Tt(null, i, {sliceY:r.frames.length, anims:r.anims});
      n(o);
    }));
  }
  function zn(t, e = "\nvec4 vert(vec2 pos, vec2 uv, vec4 color) {\n\treturn def_vert();\n}\n", n = "\nvec4 frag(vec2 pos, vec2 uv, vec4 color, sampler2D tex) {\n\treturn def_frag();\n}\n") {
    e = "\nattribute vec2 a_pos;\nattribute vec2 a_uv;\nattribute vec4 a_color;\n\nvarying vec2 v_pos;\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nvec4 def_vert() {\n\treturn vec4(a_pos, 0.0, 1.0);\n}\n\n{{user}}\n\nvoid main() {\n\tvec4 pos \x3d vert(a_pos, a_uv, a_color);\n\tv_pos \x3d a_pos;\n\tv_uv \x3d a_uv;\n\tv_color \x3d a_color;\n\tgl_Position \x3d pos;\n}\n".replace("{{user}}", e ?? "\nvec4 vert(vec2 pos, vec2 uv, vec4 color) {\n\treturn def_vert();\n}\n");
    n = "\nprecision mediump float;\n\nvarying vec2 v_pos;\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nuniform sampler2D u_tex;\n\nvec4 def_frag() {\n\tvec4 texColor \x3d texture2D(u_tex, v_uv);\n\treturn vec4((v_color.rgb * texColor.rgb), texColor.a) * v_color.a;\n}\n\n{{user}}\n\nvoid main() {\n\tgl_FragColor \x3d frag(v_pos, v_uv, v_color, u_tex);\n\tif (gl_FragColor.a \x3d\x3d 0.0) {\n\t\tdiscard;\n\t}\n}\n".replace("{{user}}", n ?? "\nvec4 frag(vec2 pos, vec2 uv, vec4 color, sampler2D tex) {\n\treturn def_frag();\n}\n");
    try {
      return new zr(t, e, n, en.map(i => i.name));
    } catch (i) {
      e = ws(i).match(/(?<type>^\w+) SHADER ERROR: 0:(?<line>\d+): (?<msg>.+)/);
      if (!e?.groups) {
        throw i;
      }
      t = Number(e.groups.line) - 14;
      n = e.groups.msg.trim();
      e = e.groups.type.toLowerCase();
      throw Error(`${e} shader line ${t}: ${n}`);
    }
  }
  function ti(t) {
    if (!t) {
      return c.gfx.defShader;
    }
    if ("string" == typeof t) {
      let e = Yr(t);
      if (e) {
        return e.data ?? e;
      }
      if (1 > Fe()) {
        return null;
      }
      throw Error(`Shader not found: ${t}`);
    }
    return t instanceof le ? t.data ? t.data : t : t;
  }
  function Yr(t) {
    return c.assets.shaders.get(t) ?? null;
  }
  function ni(t, e, n) {
    return c.assets.shaders.addLoaded(t, zn(c.gfx.ggl, e, n));
  }
  function ri(t, e, n) {
    e = de(e);
    n = de(n);
    let r = s(i => i ? _s(i) : Promise.resolve(null), "resolveUrl");
    e = Promise.all([r(e), r(n)]).then(([i, a]) => zn(c.gfx.ggl, i, a));
    return c.assets.shaders.add(t, e);
  }
  function oi(t) {
    if ("string" == typeof t) {
      let e = Wr(t);
      if (e) {
        return e;
      }
      if (1 > Fe()) {
        return null;
      }
      throw Error(`Sound not found: ${t}`);
    }
    if (t instanceof ot) {
      return le.loaded(t);
    }
    if (t instanceof le) {
      return t;
    }
    throw Error(`Invalid sound: ${t}`);
  }
  function Wr(t) {
    return c.assets.sounds.get(t) ?? null;
  }
  function si(t, e) {
    return e = de(e), c.assets.sounds.add(t, "string" == typeof e ? ot.fromURL(e) : ot.fromArrayBuffer(e));
  }
  function ii(t, e) {
    e = de(e);
    return (new Audio(e)).preload = "auto", c.assets.music[t] = e;
  }
  function $r(t, e) {
    return t = de(t), "string" == typeof e ? ln(new Promise((n, r) => {
      Ot(e).then(o => {
        $r(t, o).then(n).catch(r);
      });
    })) : ln(Le.from(t).then(n => {
      let r = {};
      for (let o in e) {
        let i = e[o], a = n.frames[0], l = 2048 * a.w, u = 2048 * a.h;
        var m = i.frames ? i.frames.map(C => new z(a.x + (i.x + C.x) / l * a.w, a.y + (i.y + C.y) / u * a.h, C.w / l * a.w, C.h / u * a.h)) : Ur(i.sliceX || 1, i.sliceY || 1, a.x + i.x / l * a.w, a.y + i.y / u * a.h, i.width / l * a.w, i.height / u * a.h);
        m = new Le(n.tex, m, i.anims);
        c.assets.sprites.addLoaded(o, m);
        r[o] = m;
      }
      return r;
    }));
  }
  function je(t, e, n = !1, r, o, i = {}) {
    r = r ?? c.gfx.defTex;
    if ((o = ti(o ?? c.gfx.defShader)) && !(o instanceof le)) {
      n = c.gfx.fixed || n ? c.gfx.transform : c.game.cam.transform.mult(c.gfx.transform);
      var d = [];
      for (let C of t) {
        t = Ls(n.multVec2(C.pos)), d.push(t.x, t.y, C.uv.x, C.uv.y, C.color.r / 255, C.color.g / 255, C.color.b / 255, C.opacity);
      }
      c.gfx.renderer.push(c.gfx.ggl.gl.TRIANGLES, d, e, o, r, i);
    }
  }
  function Ge(t) {
    if (!t.pts) {
      throw Error('drawPolygon() requires property "pts".');
    }
    let e = t.pts.length;
    if (!(3 > e)) {
      if (be(), Q(t.pos), rt(t.scale), $e(t.angle), Q(t.offset), !1 !== t.fill) {
        let n = t.color ?? K.WHITE, r = t.pts.map((i, a) => ({pos:new E(i.x, i.y), uv:t.uv ? t.uv[a] : new E(0, 0), color:t.colors && t.colors[a] ? t.colors[a].mult(n) : n, opacity:t.opacity ?? 1})), o;
        t.triangulate ? o = Dn(t.pts).map(a => a.map(l => t.pts.indexOf(l))).flat() : o = [...Array(e - 2).keys()].map(i => [0, i + 1, i + 2]).flat();
        je(r, t.indices ?? o, t.fixed, t.uv ? t.tex : c.gfx.defTex, t.shader, t.uniform ?? void 0);
      }
      t.outline && kt({pts:[...t.pts, t.pts[0]], radius:t.radius, width:t.outline.width, color:t.outline.color, join:t.outline.join, uniform:t.uniform, fixed:t.fixed, opacity:t.opacity ?? t.outline.opacity});
      pe();
    }
  }
  function Yn(t) {
    if (void 0 === t.radiusX || void 0 === t.radiusY) {
      throw Error('drawEllipse() requires properties "radiusX" and "radiusY".');
    }
    if (0 !== t.radiusX && 0 !== t.radiusY) {
      var e = t.start ?? 0, n = t.end ?? 360, r = Ne(t.anchor ?? "center").scale(new E(-t.radiusX, -t.radiusY)), o = Ct(r, t.radiusX, t.radiusY, e, n, t.resolution);
      o.unshift(r);
      r = Object.assign({}, t, {pts:o, radius:0, ...(t.gradient ? {colors:[t.gradient[0], ...Array(o.length - 1).fill(t.gradient[1])]} : {})});
      360 <= n - e && t.outline ? (!1 !== t.fill && Ge(Object.assign({}, r, {outline:null})), Ge(Object.assign({}, r, {pts:o.slice(1), fill:!1}))) : Ge(r);
    }
  }
  function Ue(t) {
    if ("number" != typeof t.radius) {
      throw Error('drawCircle() requires property "radius".');
    }
    0 !== t.radius && Yn(Object.assign({}, t, {radiusX:t.radius, radiusY:t.radius, angle:0}));
  }
  function _t(t) {
    let {p1:e, p2:n} = t;
    if (!e || !n) {
      throw Error('drawLine() requires properties "p1" and "p2".');
    }
    var r = t.width || 1;
    r = n.sub(e).unit().normal().scale(.5 * r);
    r = [e.sub(r), e.add(r), n.add(r), n.sub(r)].map(a => ({pos:new E(a.x, a.y), uv:new E(0), color:t.color ?? K.WHITE, opacity:t.opacity ?? 1}));
    je(r, [0, 1, 3, 1, 2, 3], t.fixed, c.gfx.defTex, t.shader, t.uniform ?? void 0);
  }
  function rc(t) {
    var e = t.pts;
    let n = [];
    var r = .5 * (t.width || 1);
    let o = e[0] === e[e.length - 1] || e[0].eq(e[e.length - 1]), i = t.pos || v(0, 0);
    var a;
    o ? a = e[0].sub(e[e.length - 2]) : a = e[1].sub(e[0]);
    var l = a.len(), u = a.normal().scale(-r / l), d = e[0];
    if (!o) {
      switch(t.cap) {
        case "square":
          var m = a.scale(-r / l);
          n.push(d.add(m).add(u));
          n.push(d.add(m).sub(u));
          break;
        case "round":
          m = Math.max(r, 10);
          var O = Math.PI / m, g = u.scale(-1), y = Math.cos(O);
          O = Math.sin(O);
          for (var A = 0; A < m; A++) {
            n.push(d), n.push(d.sub(g)), g = v(g.x * y - g.y * O, g.x * O + g.y * y);
          }
      }
    }
    for (g = 1; g < e.length; g++) {
      if (d === e[g] || d.eq(e[g])) {
        continue;
      }
      m = d;
      d = e[g];
      y = d.sub(m);
      O = y.len();
      A = y.normal().scale(-r / O);
      let V = a.cross(y);
      .05 > Math.abs(V) / (l * O) ? (n.push(m.add(u)), n.push(m.sub(u)), 0 > a.dot(y) && (n.push(m.sub(u)), n.push(m.add(u))), a = y, l = O, u = A) : (l = A.sub(u).cross(y) / V, a = u.add(a.scale(l)), 0 < V ? (n.push(m.add(a)), n.push(m.sub(u)), n.push(m.add(a)), n.push(m.sub(A))) : (n.push(m.add(u)), n.push(m.sub(a)), n.push(m.add(A)), n.push(m.sub(a))), a = y, l = O, u = A);
    }
    if (!o) {
      switch(n.push(d.add(u)), n.push(d.sub(u)), t.cap) {
        case "square":
          e = a.scale(r / l);
          n.push(d.add(e).add(u));
          n.push(d.add(e).sub(u));
          break;
        case "round":
          for (e = Math.max(r, 10), a = Math.PI / e, u = u.scale(1), r = Math.cos(a), a = Math.sin(a), l = 0; l < e; l++) {
            u = v(u.x * r - u.y * a, u.x * a + u.y * r), n.push(d), n.push(d.sub(u));
          }
      }
    }
    if (!(4 > n.length)) {
      d = n.map(f => ({pos:i.add(f), uv:v(), color:t.color || K.WHITE, opacity:t.opacity ?? 1}));
      u = [];
      e = 0;
      for (r = 0; r < n.length - 2; r += 2) {
        u[e++] = r + 1, u[e++] = r, u[e++] = r + 2, u[e++] = r + 2, u[e++] = r + 3, u[e++] = r + 1;
      }
      o && (u[e++] = n.length - 1, u[e++] = n.length - 2, u[e++] = 0, u[e++] = 0, u[e++] = 1, u[e++] = n.length - 1);
      je(d, u, t.fixed, c.gfx.defTex, t.shader, t.uniform ?? void 0);
    }
  }
  function oc(t) {
    var e = t.pts;
    let n = [];
    var r = .5 * (t.width || 1);
    let o = e[0] === e[e.length - 1] || e[0].eq(e[e.length - 1]), i = t.pos || v(0, 0);
    var a;
    o ? a = e[0].sub(e[e.length - 2]) : a = e[1].sub(e[0]);
    var l = a.len(), u = a.normal().scale(-r / l), d = e[0];
    if (!o) {
      switch(t.cap) {
        case "square":
          var m = a.scale(-r / l);
          n.push(d.add(m).add(u));
          n.push(d.add(m).sub(u));
          break;
        case "round":
          m = Math.max(r, 10);
          var O = Math.PI / m, g = u.scale(-1), y = Math.cos(O);
          O = Math.sin(O);
          for (var A = 0; A < m; A++) {
            n.push(d), n.push(d.sub(g)), g = v(g.x * y - g.y * O, g.x * O + g.y * y);
          }
      }
    }
    for (g = 1; g < e.length; g++) {
      if (d !== e[g] && !d.eq(e[g])) {
        m = d;
        d = e[g];
        y = d.sub(m);
        O = y.len();
        A = y.normal().scale(-r / O);
        var V = a.cross(y);
        if (.05 > Math.abs(V) / (l * O)) {
          n.push(m.add(u)), n.push(m.sub(u)), 0 > a.dot(y) && (n.push(m.sub(u)), n.push(m.add(u))), a = y, l = O, u = A;
        } else {
          l = A.sub(u).cross(y) / V;
          a = u.add(a.scale(l));
          if (0 < V) {
            a = m.add(a);
            l = Math.max(r, 10);
            var w = ue(u.angleBetween(A) / l);
            V = Math.cos(w);
            w = Math.sin(w);
            for (var F = 0; F < l; F++) {
              n.push(a), n.push(m.sub(u)), u = v(u.x * V - u.y * w, u.x * w + u.y * V);
            }
          } else {
            for (a = m.sub(a), l = Math.max(r, 10), w = ue(u.angleBetween(A) / l), V = Math.cos(w), w = Math.sin(w), F = 0; F < l; F++) {
              n.push(m.add(u)), n.push(a), u = v(u.x * V - u.y * w, u.x * w + u.y * V);
            }
          }
          a = y;
          l = O;
          u = A;
        }
      }
    }
    if (!o) {
      switch(n.push(d.add(u)), n.push(d.sub(u)), t.cap) {
        case "square":
          e = a.scale(r / l);
          n.push(d.add(e).add(u));
          n.push(d.add(e).sub(u));
          break;
        case "round":
          for (e = Math.max(r, 10), m = Math.PI / e, r = u.scale(1), u = Math.cos(m), m = Math.sin(m), g = 0; g < e; g++) {
            r = v(r.x * u - r.y * m, r.x * m + r.y * u), n.push(d), n.push(d.sub(r));
          }
      }
    }
    if (!(4 > n.length)) {
      d = n.map(f => ({pos:i.add(f), uv:v(), color:t.color || K.WHITE, opacity:t.opacity ?? 1}));
      e = [];
      r = 0;
      for (u = 0; u < n.length - 2; u += 2) {
        e[r++] = u + 1, e[r++] = u, e[r++] = u + 2, e[r++] = u + 2, e[r++] = u + 3, e[r++] = u + 1;
      }
      o && (e[r++] = n.length - 1, e[r++] = n.length - 2, e[r++] = 0, e[r++] = 0, e[r++] = 1, e[r++] = n.length - 1);
      je(d, e, t.fixed, c.gfx.defTex, t.shader, t.uniform ?? void 0);
    }
  }
  function sc(t) {
    var e = t.pts;
    let n = [];
    var r = .5 * (t.width || 1);
    let o = e[0] === e[e.length - 1] || e[0].eq(e[e.length - 1]), i = t.pos || v(0, 0);
    var a;
    o ? a = e[0].sub(e[e.length - 2]) : a = e[1].sub(e[0]);
    var l = a.len(), u = a.normal().scale(-r / l), d = e[0];
    if (!o) {
      switch(t.cap) {
        case "square":
          var m = a.scale(-r / l);
          n.push(d.add(m).add(u));
          n.push(d.add(m).sub(u));
          break;
        case "round":
          m = Math.max(r, 10);
          var O = Math.PI / m, g = u.scale(-1), y = Math.cos(O);
          O = Math.sin(O);
          for (var A = 0; A < m; A++) {
            n.push(d), n.push(d.sub(g)), g = v(g.x * y - g.y * O, g.x * O + g.y * y);
          }
      }
    }
    for (g = 1; g < e.length; g++) {
      if (d === e[g] || d.eq(e[g])) {
        continue;
      }
      m = d;
      d = e[g];
      y = d.sub(m);
      O = y.len();
      A = y.normal().scale(-r / O);
      let V = a.cross(y);
      .05 > Math.abs(V) / (l * O) ? (n.push(m.add(u)), n.push(m.sub(u)), 0 > a.dot(y) && (n.push(m.sub(u)), n.push(m.add(u))), a = y, l = O, u = A) : (l = A.sub(u).cross(y) / V, u = u.add(a.scale(l)), n.push(m.add(u)), n.push(m.sub(u)), a = y, l = O, u = A);
    }
    if (!o) {
      switch(n.push(d.add(u)), n.push(d.sub(u)), t.cap) {
        case "square":
          e = a.scale(r / l);
          n.push(d.add(e).add(u));
          n.push(d.add(e).sub(u));
          break;
        case "round":
          for (e = Math.max(r, 10), a = Math.PI / e, u = u.scale(1), r = Math.cos(a), a = Math.sin(a), l = 0; l < e; l++) {
            u = v(u.x * r - u.y * a, u.x * a + u.y * r), n.push(d), n.push(d.sub(u));
          }
      }
    }
    if (!(4 > n.length)) {
      d = n.map(f => ({pos:i.add(f), uv:v(), color:t.color || K.WHITE, opacity:t.opacity ?? 1}));
      u = [];
      e = 0;
      for (r = 0; r < n.length - 2; r += 2) {
        u[e++] = r + 1, u[e++] = r, u[e++] = r + 2, u[e++] = r + 2, u[e++] = r + 3, u[e++] = r + 1;
      }
      o && (u[e++] = n.length - 1, u[e++] = n.length - 2, u[e++] = 0, u[e++] = 0, u[e++] = 1, u[e++] = n.length - 1);
      je(d, u, t.fixed, c.gfx.defTex, t.shader, t.uniform ?? void 0);
    }
  }
  function kt(t) {
    let e = t.pts;
    var n = t.width ?? 1;
    if (!e) {
      throw Error('drawLines() requires property "pts".');
    }
    if (!(2 > e.length)) {
      if (2 < e.length) {
        switch(t.join) {
          case "bevel":
            return rc(t);
          case "round":
            return oc(t);
          case "miter":
            return sc(t);
        }
      }
      if (t.radius && 3 <= e.length) {
        _t(Object.assign({}, t, {p1:e[0], p2:e[1]}));
        for (n = 1; n < e.length - 2; n++) {
          _t(Object.assign({}, t, {p1:e[n], p2:e[n + 1]}));
        }
        _t(Object.assign({}, t, {p1:e[e.length - 2], p2:e[e.length - 1]}));
      } else {
        for (let r = 0; r < e.length - 1; r++) {
          _t(Object.assign({}, t, {p1:e[r], p2:e[r + 1]})), "none" !== t.join && Ue(Object.assign({}, t, {pos:e[r], radius:n / 2}));
        }
      }
    }
  }
  function Wn(t, e) {
    let n = e.segments ?? 16, r = [];
    for (let o = 0; o <= n; o++) {
      r.push(t(o / n));
    }
    kt({pts:r, width:e.width || 1, pos:e.pos, color:e.color, opacity:e.opacity});
  }
  function ai(t) {
    Wn(e => Jt(t.pt1, t.pt2, t.pt3, t.pt4, e), t);
  }
  function St(t) {
    let e = [], n = s(i => {
      e.push(i);
      t(i);
    }, "push"), r = s(() => {
      e.pop();
      t(o() ?? null);
    }, "pop"), o = s(() => e[e.length - 1], "cur");
    return [n, r, o];
  }
  function ui(t, e = {}) {
    function r(G) {
      n.push(G);
    }
    function o() {
      n.forEach(x => x());
      let G = t.getExtension("WEBGL_lose_context");
      G && G.loseContext();
    }
    function a(G) {
      if (!Kn(G, i)) {
        i = G;
        var x = G.reduce((w, S) => w + S.size, 0);
        G.reduce((w, S, M) => (t.vertexAttribPointer(M, S.size, t.FLOAT, !1, 4 * x, w), t.enableVertexAttribArray(M), w + 4 * S.size), 0);
      }
    }
    let n = [];
    s(r, "onDestroy");
    s(o, "destroy");
    let i = null;
    s(a, "setVertexFormat");
    let [l, u] = St(G => t.bindTexture(t.TEXTURE_2D, G)), [m, d] = St(G => t.bindBuffer(t.ARRAY_BUFFER, G)), [C, p] = St(G => t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, G)), [b, f] = St(G => t.bindFramebuffer(t.FRAMEBUFFER, G)), [O, g] = St(G => t.bindRenderbuffer(t.RENDERBUFFER, G)), [y, V] = St(G => {
      if (G) {
        var {x, y:w, w:S, h:M} = G;
        t.viewport(x, w, S, M);
      }
    }), [A, D] = St(G => t.useProgram(G));
    return y({x:0, y:0, w:t.drawingBufferWidth, h:t.drawingBufferHeight}), {gl:t, opts:e, onDestroy:r, destroy:o, pushTexture2D:l, popTexture2D:u, pushArrayBuffer:m, popArrayBuffer:d, pushElementArrayBuffer:C, popElementArrayBuffer:p, pushFramebuffer:b, popFramebuffer:f, pushRenderbuffer:O, popRenderbuffer:g, pushViewport:y, popViewport:V, pushProgram:A, popProgram:D, setVertexFormat:a};
  }
  function mi(t, e) {
    e.override ? Object.assign(t, e) : (e.pos && (t.pos = t.pos.add(e.pos)), e.scale && (t.scale = t.scale.scale(v(e.scale))), e.angle && (t.angle += e.angle), e.color && 1 === t.ch.length && (t.color = t.color.mult(e.color)), null != e.opacity && (t.opacity *= e.opacity));
  }
  function Xn(t) {
    let e = {}, n = "", r = [];
    t = String(t);
    let i = s(a => {
      0 < r.length && (e[n.length] = r.slice());
      n += a;
    }, "emit");
    for (; "" !== t;) {
      if ("\\" === t[0]) {
        if (1 === t.length) {
          throw Error("Styled text error: \\ at end of string");
        }
        i(t[1]);
        t = t.slice(2);
      } else {
        if ("[" === t[0]) {
          var a = /^\[(\/)?(\w+?)\]/.exec(t);
          if (!a) {
            i(t[0]);
            t = t.slice(1);
            continue;
          }
          let [l, u, m] = a;
          if (void 0 !== u) {
            if (a = r.pop(), a !== m) {
              throw void 0 !== a ? Error(`Styled text error: mismatched tags. Expected [/${a}], got [/${m}]`) : Error(`Styled text error: stray end tag [/${m}]`);
            }
          } else {
            r.push(m);
          }
          t = t.slice(l.length);
        } else {
          i(t[0]), t = t.slice(1);
        }
      }
    }
    if (0 < r.length) {
      throw Error(`Styled text error: unclosed tags ${r}`);
    }
    return {charStyleMap:e, text:n};
  }
  function He(t) {
    if (void 0 === t.text) {
      throw Error('formatText() requires property "text".');
    }
    var e = Hr(t.font);
    if (!t.text || "" === t.text || e instanceof le || !e) {
      return {width:0, height:0, chars:[], opt:t, renderedText:""};
    }
    let {charStyleMap:n, text:r} = Xn(t.text + "");
    var o = Es(r);
    if (e instanceof At || "string" == typeof e) {
      var A$jscomp$0 = e instanceof At ? e.fontface.family : e;
      e = e instanceof At ? {outline:e.outline, filter:e.filter} : {outline:null, filter:"linear"};
      var G$jscomp$0 = Xr[A$jscomp$0] ?? {font:{tex:new Pe(c.gfx.ggl, 2048, 2048, {filter:e.filter}), map:{}, size:64}, cursor:new E(0), maxHeight:0, outline:e.outline};
      Xr[A$jscomp$0] || (Xr[A$jscomp$0] = G$jscomp$0);
      e = G$jscomp$0.font;
      for (var x of o) {
        if (!G$jscomp$0.font.map[x]) {
          var w = c.fontCacheC2d;
          if (!w) {
            throw Error("fontCacheC2d is not defined.");
          }
          if (!c.fontCacheCanvas) {
            throw Error("fontCacheCanvas is not defined.");
          }
          w.clearRect(0, 0, c.fontCacheCanvas.width, c.fontCacheCanvas.height);
          w.font = `${e.size}px ${A$jscomp$0}`;
          w.textBaseline = "top";
          w.textAlign = "left";
          w.fillStyle = "#ffffff";
          var S = w.measureText(x), M = Math.ceil(S.width);
          if (M) {
            S = Math.ceil(Math.abs(S.actualBoundingBoxAscent)) + Math.ceil(Math.abs(S.actualBoundingBoxDescent));
            G$jscomp$0.outline && G$jscomp$0.outline.width && G$jscomp$0.outline.color && (w.lineJoin = "round", w.lineWidth = 2 * G$jscomp$0.outline.width, w.strokeStyle = G$jscomp$0.outline.color.toHex(), w.strokeText(x, G$jscomp$0.outline.width, G$jscomp$0.outline.width), M += 2 * G$jscomp$0.outline.width, S += 3 * G$jscomp$0.outline.width);
            w.fillText(x, G$jscomp$0.outline?.width ?? 0, G$jscomp$0.outline?.width ?? 0);
            w = w.getImageData(0, 0, M, S);
            if (2048 < G$jscomp$0.cursor.x + M && (G$jscomp$0.cursor.x = 0, G$jscomp$0.cursor.y += G$jscomp$0.maxHeight, G$jscomp$0.maxHeight = 0, 2048 < G$jscomp$0.cursor.y)) {
              throw Error("Font atlas exceeds character limit");
            }
            e.tex.update(w, G$jscomp$0.cursor.x, G$jscomp$0.cursor.y);
            e.map[x] = new z(G$jscomp$0.cursor.x, G$jscomp$0.cursor.y, M, S);
            G$jscomp$0.cursor.x += M + 1;
            G$jscomp$0.maxHeight = Math.max(G$jscomp$0.maxHeight, S);
          }
        }
      }
    }
    w = t.size || e.size;
    A$jscomp$0 = v(t.scale ?? 1).scale(w / e.size);
    S = t.lineSpacing ?? 0;
    var u = t.letterSpacing ?? 0;
    let m = 0;
    G$jscomp$0 = x = 0;
    M = [];
    let b = [], f = 0, O = null, g = 0;
    for (var y; f < o.length;) {
      let A = o[f];
      if ("\n" === A) {
        G$jscomp$0 += w + S, M.push({width:m - u, chars:b}), O = null, m = g = 0, b = [], y = void 0;
      } else {
        let D = e.map[A];
        if (D) {
          let G = D.w * A$jscomp$0.x;
          t.width && m + G > t.width && (G$jscomp$0 += w + S, null != O && (f -= b.length - O, A = o[f], D = e.map[A], G = D.w * A$jscomp$0.x, b = b.slice(0, O - 1), m = g), O = null, g = 0, M.push({width:m - u, chars:b}), m = y ?? 0, b = []);
          b.push({tex:e.tex, width:D.w, height:D.h, quad:new z(D.x / e.tex.width, D.y / e.tex.height, D.w / e.tex.width, D.h / e.tex.height), ch:A, pos:new E(m, G$jscomp$0), opacity:t.opacity ?? 1, color:t.color ?? K.WHITE, scale:v(A$jscomp$0), angle:0});
          " " === A && (O = b.length, g = m);
          t.indentAll && void 0 === y && /\S/.test(A) && (y = m);
          m += G;
          x = Math.max(x, m);
          m += u;
        }
      }
      f++;
    }
    M.push({width:m - u, chars:b});
    G$jscomp$0 += w;
    t.width && (x = t.width);
    o = [];
    for (y = 0; y < M.length; y++) {
      w = (x - M[y].width) * Ms(t.align ?? "left");
      for (let G of M[y].chars) {
        u = e.map[G.ch];
        S = o.length + y;
        (G.pos = G.pos.add(w, 0).add(u.w * A$jscomp$0.x * .5, u.h * A$jscomp$0.y * .5), t.transform) && (u = "function" == typeof t.transform ? t.transform(S, G.ch) : t.transform) && mi(G, u);
        if (n[S]) {
          u = n[S];
          for (let M of u) {
            u = t.styles?.[M], (u = "function" == typeof u ? u(S, G.ch) : u) && mi(G, u);
          }
        }
        o.push(G);
      }
    }
    return {width:x, height:G$jscomp$0, chars:o, opt:t, renderedText:r};
  }
  function it(t) {
    if (void 0 === t.width || void 0 === t.height) {
      throw Error('drawUVQuad() requires property "width" and "height".');
    }
    if (!(0 >= t.width || 0 >= t.height)) {
      var e = t.width, n = t.height, o = Ne(t.anchor || "topleft").scale((new E(e, n)).scale(-.5)), i = t.quad || new z(0, 0, 1, 1), a = t.color || I(255, 255, 255), l = t.opacity ?? 1, u = t.tex ? .1 / t.tex.width : 0, m = t.tex ? .1 / t.tex.height : 0, d = i.x + u, C = i.y + m;
      u = i.w - 2 * u;
      i = i.h - 2 * m;
      be();
      Q(t.pos);
      $e(t.angle);
      rt(t.scale);
      Q(o);
      je([{pos:new E(-e / 2, n / 2), uv:new E(t.flipX ? d + u : d, t.flipY ? C : C + i), color:a, opacity:l}, {pos:new E(-e / 2, -n / 2), uv:new E(t.flipX ? d + u : d, t.flipY ? C + i : C), color:a, opacity:l}, {pos:new E(e / 2, -n / 2), uv:new E(t.flipX ? d : d + u, t.flipY ? C + i : C), color:a, opacity:l}, {pos:new E(e / 2, n / 2), uv:new E(t.flipX ? d : d + u, t.flipY ? C : C + i), color:a, opacity:l}], [0, 1, 3, 1, 2, 3], t.fixed, t.tex, t.shader, t.uniform ?? void 0);
      pe();
    }
  }
  function qe(t) {
    be();
    Q(t.opt.pos);
    $e(t.opt.angle);
    Q(Ne(t.opt.anchor ?? "topleft").add(1, 1).scale(t.width, t.height).scale(-.5));
    t.chars.forEach(e => {
      it({tex:e.tex, width:e.width, height:e.height, pos:e.pos, scale:e.scale, angle:e.angle, color:e.color, opacity:e.opacity, quad:e.quad, anchor:"center", uniform:t.opt.uniform, shader:t.opt.shader, fixed:t.opt.fixed});
    });
    pe();
  }
  function ve(t) {
    if (void 0 === t.width || void 0 === t.height) {
      throw Error('drawRect() requires property "width" and "height".');
    }
    if (!(0 >= t.width || 0 >= t.height)) {
      var e = t.width, n = t.height, o = Ne(t.anchor || "topleft").add(1, 1).scale((new E(e, n)).scale(-.5)), i = [new E(0, 0), new E(e, 0), new E(e, n), new E(0, n)];
      if (t.radius) {
        let a = Math.min(e, n) / 2;
        i = Array.isArray(t.radius) ? t.radius.map(u => Math.min(a, u)) : Array(4).fill(Math.min(a, t.radius));
        i = [new E(i[0], 0), ...(i[1] ? Ct(new E(e - i[1], i[1]), i[1], i[1], 270, 360) : [v(e, 0)]), ...(i[2] ? Ct(new E(e - i[2], n - i[2]), i[2], i[2], 0, 90) : [v(e, n)]), ...(i[3] ? Ct(new E(i[3], n - i[3]), i[3], i[3], 90, 180) : [v(0, n)]), ...(i[0] ? Ct(new E(i[0], i[0]), i[0], i[0], 180, 270) : [])];
      }
      Ge(Object.assign({}, t, {offset:o, pts:i, ...(t.gradient ? {colors:t.horizontal ? [t.gradient[0], t.gradient[1], t.gradient[1], t.gradient[0]] : [t.gradient[0], t.gradient[0], t.gradient[1], t.gradient[1]]} : {})}));
    }
  }
  function ze(t) {
    Oe();
    let e = c.gfx.width, n = c.gfx.height;
    c.gfx.width = c.gfx.viewport.width;
    c.gfx.height = c.gfx.viewport.height;
    t();
    Oe();
    c.gfx.width = e;
    c.gfx.height = n;
  }
  function Qr(t, e) {
    ze(() => {
      var n = v(8);
      be();
      Q(t);
      let r = He({text:e, font:"monospace", size:16, pos:n, color:I(255, 255, 255), fixed:!0}), o = r.width + 2 * n.x;
      n = r.height + 2 * n.x;
      t.x + o >= ae() && Q(v(-o, 0));
      t.y + n >= ce() && Q(v(0, -n));
      ve({width:o, height:n, color:I(0, 0, 0), radius:4, opacity:.8, fixed:!0});
      qe(r);
      pe();
    });
  }
  function Qn(t) {
    if (!t.p1 || !t.p2 || !t.p3) {
      throw Error('drawTriangle() requires properties "p1", "p2" and "p3".');
    }
    return Ge(Object.assign({}, t, {pts:[t.p1, t.p2, t.p3]}));
  }
  function di() {
    if (c.debug.inspect) {
      var t = null;
      for (var e of c.game.root.get("*", {recursive:!0})) {
        if (e.c("area") && e.isHovering()) {
          t = e;
          break;
        }
      }
      if (c.game.root.drawInspect(), t) {
        e = [];
        t = t.inspect();
        for (let r in t) {
          t[r] ? e.push(`${t[r]}`) : e.push(`${r}`);
        }
        Qr(ks(Un()), e.join("\n"));
      }
      Qr(v(8), `FPS: ${c.debug.fps()}`);
    }
    c.debug.paused && ze(() => {
      be();
      Q(ae(), 0);
      Q(-8, 8);
      ve({width:32, height:32, anchor:"topright", color:I(0, 0, 0), opacity:.8, radius:4, fixed:!0});
      for (let e = 1; 2 >= e; e++) {
        ve({width:4, height:19.2, anchor:"center", pos:v(-32 / 3 * e, 16), color:I(255, 255, 255), radius:2, fixed:!0});
      }
      pe();
    });
    1 !== c.debug.timeScale && ze(() => {
      be();
      Q(ae(), ce());
      Q(-8, -8);
      let e = He({text:c.debug.timeScale.toFixed(1), font:"monospace", size:16, color:I(255, 255, 255), pos:v(-8), anchor:"botright", fixed:!0});
      ve({width:e.width + 16 + 32, height:e.height + 16, anchor:"botright", color:I(0, 0, 0), opacity:.8, radius:4, fixed:!0});
      for (let n = 0; 2 > n; n++) {
        let r = 1 > c.debug.timeScale;
        Qn({p1:v(-e.width - 8 * (r ? 2 : 3.5), -8), p2:v(-e.width - 8 * (r ? 2 : 3.5), -8 - e.height), p3:v(-e.width - 8 * (r ? 3.5 : 2), -8 - e.height / 2), pos:v(8 * -n + (r ? -4 : 0), 0), color:I(255, 255, 255), fixed:!0});
      }
      qe(e);
      pe();
    });
    c.debug.curRecording && ze(() => {
      be();
      Q(0, ce());
      Q(24, -24);
      Ue({radius:12, color:I(255, 0, 0), opacity:Vn(0, 1, 4 * c.app.time()), fixed:!0});
      pe();
    });
    c.debug.showLog && 0 < c.game.logs.length && ze(() => {
      be();
      Q(0, ce());
      Q(8, -8);
      var e = [];
      for (let r of c.game.logs) {
        let o = "", i = r.msg instanceof Error ? "error" : "info";
        o += `[time]${r.time.toFixed(2)}[/time]`;
        o += " ";
        o += `[${i}]${Jr(r.msg)}[/${i}]`;
        e.push(o);
      }
      c.game.logs = c.game.logs.filter(r => c.app.time() - r.time < (c.globalOpt.logTime || 4));
      e = He({text:e.join("\n"), font:"monospace", pos:v(8, -8), anchor:"botleft", size:16, width:.6 * ae(), lineSpacing:4, fixed:!0, styles:{time:{color:I(127, 127, 127)}, info:{color:I(255, 255, 255)}, error:{color:I(255, 0, 127)}}});
      ve({width:e.width + 16, height:e.height + 16, anchor:"botleft", color:I(0, 0, 0), radius:4, opacity:.8, fixed:!0});
      qe(e);
      pe();
    });
  }
  function Jr(t, e = !1, n = new Set()) {
    if (n.has(t)) {
      return "\x3crecursive\x3e";
    }
    var r = "", o;
    return e && "string" == typeof t && (t = JSON.stringify(t)), Array.isArray(t) && (r = ["[", t.map(i => Jr(i, !0, n.union(new Set([t])))).join(", "), "]"].join(""), t = r), null === t ? "null" : ("object" == typeof t && t.toString === Object.prototype.toString && (t.constructor !== Object && (r += t.constructor.name + " "), r += ["{", (o = Object.getOwnPropertyNames(t).map(i => `${/^\w+$/.test(i) ? i : JSON.stringify(i)}: ${Jr(t[i], !0, n.union(new Set([t])))}`).join(", ")) ? ` ${o} ` : "", "}"].join(""), 
    t = r), String(t).replaceAll(/(?<!\\)\[/g, "\\["));
  }
  function fi() {
    let t = c.game.cam, e = E.fromAngle(ge(0, 360)).scale(t.shake);
    t.shake = fe(t.shake, 0, 5 * te());
    t.transform = (new he()).translate(wt()).scale(t.scale).rotate(t.angle).translate((t.pos ?? wt()).scale(-1).add(e));
    c.game.root.draw();
    Oe();
  }
  function hi() {
    let t = Fe();
    0 < c.game.events.numListeners("loading") ? c.game.events.trigger("loading", t) : ze(() => {
      let e = ae() / 2, r = v(ae() / 2, ce() / 2).sub(v(e / 2, 12));
      ve({pos:v(0), width:ae(), height:ce(), color:I(0, 0, 0)});
      ve({pos:r, width:e, height:24, fill:!1, outline:{width:4}});
      ve({pos:r, width:e * t, height:24});
    });
  }
  function Jn(t, e, n) {
    let r = c.gfx.ggl.gl;
    Oe();
    r.clear(r.STENCIL_BUFFER_BIT);
    r.enable(r.STENCIL_TEST);
    r.stencilFunc(r.NEVER, 1, 255);
    r.stencilOp(r.REPLACE, r.REPLACE, r.REPLACE);
    e();
    Oe();
    r.stencilFunc(n, 1, 255);
    r.stencilOp(r.KEEP, r.KEEP, r.KEEP);
    t();
    Oe();
    r.disable(r.STENCIL_TEST);
  }
  function gi(t, e) {
    Jn(t, e, c.gfx.ggl.gl.EQUAL);
  }
  function Vt(t) {
    if (!t.tex) {
      throw Error('drawTexture() requires property "tex".');
    }
    let e = t.quad ?? new z(0, 0, 1, 1), n = t.tex.width * e.w, r = t.tex.height * e.h;
    var o = new E(1);
    if (t.tiled) {
      let i = Ne(t.anchor || "topleft");
      var u = (t.width || n) / n, m = (t.height || r) / r;
      o = Math.floor(u);
      let C = Math.floor(m);
      u -= o;
      m -= C;
      var f = (o + u ? 1 : 0) * (C + m ? 1 : 0);
      let O = Array(6 * f), g = Array(4 * f), y = 0;
      f = s((A, D, G, x, w) => {
        O[6 * y] = 4 * y;
        O[6 * y + 1] = 4 * y + 1;
        O[6 * y + 2] = 4 * y + 3;
        O[6 * y + 3] = 4 * y + 1;
        O[6 * y + 4] = 4 * y + 2;
        O[6 * y + 5] = 4 * y + 3;
        g[4 * y] = {pos:new E(A - i.x, D - i.y), uv:new E(w.x, w.y), color:t.color || K.WHITE, opacity:t.opacity || 1};
        g[4 * y + 1] = {pos:new E(A + G - i.x, D - i.y), uv:new E(w.x + w.w, w.y), color:t.color || K.WHITE, opacity:t.opacity || 1};
        g[4 * y + 2] = {pos:new E(A + G - i.x, D + x - i.y), uv:new E(w.x + w.w, w.y + w.h), color:t.color || K.WHITE, opacity:t.opacity || 1};
        g[4 * y + 3] = {pos:new E(A - i.x, D + x - i.y), uv:new E(w.x, w.y + w.h), color:t.color || K.WHITE, opacity:t.opacity || 1};
        y++;
      }, "addQuad");
      for (var A = 0; A < C; A++) {
        for (let D = 0; D < o; D++) {
          f(D * n, A * r, n, r, e);
        }
        u && f(o * n, A * r, n * u, r, new z(e.x, e.y, e.w * u, e.h));
      }
      if (m) {
        for (A = 0; A < o; A++) {
          f(A * n, C * r, n, r * m, new z(e.x, e.y, e.w, e.h * m));
        }
        u && f(o * n, C * r, n * u, r * m, new z(e.x, e.y, e.w * u, e.h * m));
      }
      je(g, O, t.fixed, t.tex, t.shader, t.uniform ?? void 0);
    } else {
      t.width && t.height ? (o.x = t.width / n, o.y = t.height / r) : t.width ? (o.x = t.width / n, o.y = o.x) : t.height && (o.y = t.height / r, o.x = o.y), it(Object.assign({}, t, {scale:o.scale(t.scale || new E(1)), tex:t.tex, quad:e, width:n, height:r}));
    }
  }
  function bi(t) {
    if (!t.sprite) {
      throw Error('drawSprite() requires property "sprite"');
    }
    let e = It(t.sprite);
    if (e && e.data) {
      var n = e.data.frames[t.frame ?? 0];
      if (!n) {
        throw Error(`Frame not found: ${t.frame ?? 0}`);
      }
      Vt(Object.assign({}, t, {tex:e.data.tex, quad:n.scale(t.quad ?? new z(0, 0, 1, 1))}));
    }
  }
  function yi(t, e) {
    Jn(t, e, c.gfx.ggl.gl.NOTEQUAL);
  }
  function Zr(t) {
    qe(He(t));
  }
  function Zn() {
    var t = c.pixelDensity;
    let e = c.gfx.ggl.gl.drawingBufferWidth / t;
    t = c.gfx.ggl.gl.drawingBufferHeight / t;
    if (c.globalOpt.letterbox) {
      if (!c.globalOpt.width || !c.globalOpt.height) {
        throw Error("Letterboxing requires width and height defined.");
      }
      var o = c.globalOpt.width / c.globalOpt.height;
      e / t > o ? (o *= t, c.gfx.viewport = {x:(e - o) / 2, y:0, width:o, height:t}) : (o = e / o, c.gfx.viewport = {x:0, y:(t - o) / 2, width:e, height:o});
    } else {
      if (c.globalOpt.stretch && (!c.globalOpt.width || !c.globalOpt.height)) {
        throw Error("Stretching requires width and height defined.");
      }
      c.gfx.viewport = {x:0, y:0, width:e, height:t};
    }
  }
  function at(t) {
    return t.fixed ? !0 : t.parent ? at(t.parent) : !1;
  }
  function Ke(t) {
    return {color:t.color, opacity:t.opacity, anchor:t.anchor, outline:t.outline, shader:t.shader, uniform:t.uniform};
  }
  function vi(t, e = {}) {
    return {id:"circle", radius:t, draw() {
      Ue(Object.assign(Ke(this), {radius:this.radius, fill:e.fill}));
    }, renderArea() {
      return new $(new E(this.anchor ? 0 : -this.radius), 2 * this.radius, 2 * this.radius);
    }, inspect() {
      return `radius: ${Math.ceil(this.radius)}`;
    }};
  }
  function er(...t) {
    return {id:"color", color:I(...t), inspect() {
      return `color: ${this.color.toString()}`;
    }};
  }
  function Ci(t) {
    return {add() {
      this.canvas = t;
    }};
  }
  function wi(t = 1) {
    let e, n = 0, r = !1;
    return {require:["opacity"], add() {
      e = this.opacity;
      this.opacity = 0;
    }, update() {
      r || (n += te(), this.opacity = Ve(n, 0, t, 0, e), n >= t && (this.opacity = e, r = !0));
    }};
  }
  function Oi(t = "intersect") {
    return {id:"mask", mask:t};
  }
  function tr(t) {
    return {id:"opacity", opacity:t ?? 1, fadeIn(e = 1, n = c.k.easings.linear) {
      return c.game.root.tween(0, this.opacity, e, r => this.opacity = r, n);
    }, fadeOut(e = 1, n = c.k.easings.linear) {
      return c.game.root.tween(this.opacity, 0, e, r => this.opacity = r, n);
    }, inspect() {
      return `opacity: ${on(this.opacity, 1)}`;
    }};
  }
  function Ei(t = 1, e = I(0, 0, 0), n = 1, r = "miter", o = 10, i = "butt") {
    return {id:"outline", outline:{width:t, color:e, opacity:n, join:r, miterLimit:o, cap:i}, inspect() {
      return `outline: ${this.outline.width}px, ${this.outline.color}`;
    }};
  }
  function Ti(t, e) {
    function G(x = 0) {
      for (; x < t.max;) {
        if (r[x].gc) {
          return x;
        }
        x++;
      }
      return null;
    }
    let n = e.lifetime, r = [], o = t.colors || [K.WHITE], i = t.opacities || [1], a = t.quads || [new z(0, 0, 1, 1)], l = t.scales || [1], u = t.lifeTime, m = e.direction, d = e.spread, C = t.speed || [0, 0], p = t.angle || [0, 0], b = t.angularVelocity || [0, 0], f = t.acceleration || [v(0), v(0)], O = t.damping || [0, 0], g = [], y = Array(t.max), V = 0, A = 0;
    for (let x = 0; x < t.max; x++) {
      g[6 * x] = 4 * x;
      g[6 * x + 1] = 4 * x + 1;
      g[6 * x + 2] = 4 * x + 3;
      g[6 * x + 3] = 4 * x + 1;
      g[6 * x + 4] = 4 * x + 2;
      g[6 * x + 5] = 4 * x + 3;
      for (let w = 0; 4 > w; w++) {
        y[4 * x + w] = {pos:new E(0, 0), uv:new E(0, 0), color:I(255, 255, 255), opacity:1};
      }
      r[x] = new eo();
    }
    let D = new oe();
    return s(G, "nextFree"), {id:"particles", emit(x) {
      let w = 0;
      for (let S = 0; S < x; S++) {
        if (w = G(w), null == w) {
          return;
        }
        var M = ge(m - d, m + d);
        M = E.fromAngle(M).scale(ge(C[0], C[1]));
        let F = ge(p[0], p[1]), j = ge(b[0], b[1]), H = v(ge(f[0].x, f[1].x), ge(f[0].y, f[1].y)), q = ge(O[0], O[1]), W = u ? ge(u[0], u[1]) : null, N = e.shape ? e.shape.random() : v(), k = r[w];
        k.lt = W;
        k.pos = N;
        k.vel = M;
        k.acc = H;
        k.angle = F;
        k.angularVelocity = j;
        k.damping = q;
        k.angularVelocity = j;
        k.gc = !1;
      }
      V += x;
    }, update() {
      if (!(void 0 !== n && 0 >= n)) {
        var x = te();
        for (let w of r) {
          w.gc || ((w.t += x, w.lt && w.t >= w.lt) ? (w.gc = !0, V--) : (w.vel = w.vel.add(w.acc.scale(x)).scale(1 - w.damping * x), w.pos = w.pos.add(w.vel.scale(x)), w.angle += w.angularVelocity * x));
        }
        void 0 !== n && (n -= x, 0 >= n && D.trigger());
        for (A += x; V < t.max && e.rate && A > e.rate;) {
          this.emit(1), V++, A -= e.rate;
        }
      }
    }, draw() {
      if (!(void 0 !== n && 0 >= n)) {
        for (let x = 0; x < r.length; x++) {
          let w = r[x];
          if (w.gc) {
            continue;
          }
          var S = w.progress, M = Math.floor(w.progress * o.length);
          M = M < o.length - 1 ? fe(o[M], o[M + 1], Ve(S, M / o.length, (M + 1) / o.length, 0, 1)) : o[M];
          var F = Math.floor(w.progress * i.length);
          S = F < i.length - 1 ? fe(i[F], i[F + 1], Ve(S, F / i.length, (F + 1) / i.length, 0, 1)) : i[F];
          F = a[Math.floor(w.progress * a.length)];
          let N = l[Math.floor(w.progress * l.length)], k = Math.cos(w.angle * Math.PI / 180), Z = Math.sin(w.angle * Math.PI / 180), X = (t.texture ? t.texture.width : 10) * F.w / 2, ee = (t.texture ? t.texture.height : 10) * F.h / 2, Ee = 4 * x, _ = y[Ee];
          _.pos.x = w.pos.x + -X * N * k - -ee * N * Z;
          _.pos.y = w.pos.y + -X * N * Z + -ee * N * k;
          _.uv.x = F.x;
          _.uv.y = F.y;
          _.color.r = M.r;
          _.color.g = M.g;
          _.color.b = M.b;
          _.opacity = S;
          _ = y[Ee + 1];
          _.pos.x = w.pos.x + X * N * k - -ee * N * Z;
          _.pos.y = w.pos.y + X * N * Z + -ee * N * k;
          _.uv.x = F.x + F.w;
          _.uv.y = F.y;
          _.color.r = M.r;
          _.color.g = M.g;
          _.color.b = M.b;
          _.opacity = S;
          _ = y[Ee + 2];
          _.pos.x = w.pos.x + X * N * k - ee * N * Z;
          _.pos.y = w.pos.y + X * N * Z + ee * N * k;
          _.uv.x = F.x + F.w;
          _.uv.y = F.y + F.h;
          _.color.r = M.r;
          _.color.g = M.g;
          _.color.b = M.b;
          _.opacity = S;
          _ = y[Ee + 3];
          _.pos.x = w.pos.x + -X * N * k - ee * N * Z;
          _.pos.y = w.pos.y + -X * N * Z + ee * N * k;
          _.uv.x = F.x;
          _.uv.y = F.y + F.h;
          _.color.r = M.r;
          _.color.g = M.g;
          _.color.b = M.b;
          _.opacity = S;
        }
        je(y, g, this.fixed, t.texture, this.shader, this.uniform);
      }
    }, onEnd(x) {
      return D.add(x);
    }, inspect() {
      return `count: ${V}/${t.max}`;
    }};
  }
  function Ai(t, e = {}) {
    if (3 > t.length) {
      throw Error(`Polygon's need more than two points, ${t.length} points provided`);
    }
    return {id:"polygon", pts:t, colors:e.colors, uv:e.uv, tex:e.tex, radius:e.radius, draw() {
      Ge(Object.assign(Ke(this), {pts:this.pts, colors:this.colors, uv:this.uv, tex:this.tex, radius:this.radius, fill:e.fill, triangulate:e.triangulate}));
    }, renderArea() {
      return new ye(this.pts);
    }, inspect() {
      return `polygon: ${this.pts.map(n => `[${n.x},${n.y}]`).join(",")}`;
    }};
  }
  function nr(t, e, n) {
    let r;
    return c.game.root.get("area").forEach(i => {
      if (!n || !n.some(u => i.is(u))) {
        var l = i.worldArea().raycast(t, e);
        l && (r ? l.fraction < r.fraction && (r = l, r.object = i) : (r = l, r.object = i));
      }
    }), r;
  }
  function rr(t, e, n = {}) {
    return {id:"rect", width:t, height:e, radius:n.radius || 0, draw() {
      ve(Object.assign(Ke(this), {width:this.width, height:this.height, radius:this.radius, fill:n.fill}));
    }, renderArea() {
      return new $(v(0), this.width, this.height);
    }, inspect() {
      return `rect: (${Math.ceil(this.width)}w, ${Math.ceil(this.height)}h)`;
    }};
  }
  function Si(t, e) {
    return {id:"shader", shader:t, ...("function" == typeof e ? {uniform:e(), update() {
      this.uniform = e();
    }} : {uniform:e}), inspect() {
      return `shader: ${t}`;
    }};
  }
  function Vi(t, e) {
    if (!e.tileWidth || !e.tileHeight) {
      throw Error("Must provide tileWidth and tileHeight.");
    }
    let n = c.game.root.add([Pt(e.pos ?? v(0))]), r = t.length, o = 0, i = null, a = null, l = null, u = null, m = s(x => x.x + x.y * o, "tile2Hash"), d = s(x => v(Math.floor(x % o), Math.floor(x / o)), "hash2Tile"), C = s(() => {
      i = [];
      for (let x of n.children) {
        p(x);
      }
    }, "createSpatialMap"), p = s(x => {
      let w = m(x.tilePos);
      i[w] ? i[w].push(x) : i[w] = [x];
    }, "insertIntoSpatialMap"), b = s(x => {
      let w = m(x.tilePos);
      i[w] && (x = i[w].indexOf(x), 0 <= x && i[w].splice(x, 1));
    }, "removeFromSpatialMap"), f = s(() => {
      let x = !1;
      for (let w of n.children) {
        let S = n.pos2Tile(w.pos);
        w.tilePos.x == S.x && w.tilePos.y == S.y || (x = !0, b(w), w.tilePos.x = S.x, w.tilePos.y = S.y, p(w));
      }
      x && n.trigger("spatialMapChanged");
    }, "updateSpatialMap"), O = s(() => {
      let x = n.getSpatialMap();
      var w = n.numRows() * n.numColumns();
      a ? a.length = w : a = Array(w);
      a.fill(1, 0, w);
      for (w = 0; w < x.length; w++) {
        let M = x[w];
        if (M) {
          let R = 0;
          for (let F of M) {
            if (F.isObstacle) {
              R = 1 / 0;
              break;
            } else {
              R += F.cost;
            }
          }
          a[w] = R || 1;
        }
      }
    }, "createCostMap"), g = s(() => {
      let x = n.getSpatialMap();
      var w = n.numRows() * n.numColumns();
      l ? l.length = w : l = Array(w);
      l.fill(15, 0, w);
      for (w = 0; w < x.length; w++) {
        let M = x[w];
        if (M) {
          let R = M.length, F = 15;
          for (let j = 0; j < R; j++) {
            F |= M[j].edgeMask;
          }
          l[w] = F;
        }
      }
    }, "createEdgeMap"), y = s(() => {
      var x = n.numRows() * n.numColumns();
      let w = s((M, R) => {
        let F = [];
        for (F.push(M); 0 < F.length;) {
          M = F.pop(), D(M).forEach(H => {
            0 > u[H] && (u[H] = R, F.push(H));
          });
        }
      }, "traverse");
      u ? u.length = x : u = Array(x);
      u.fill(-1, 0, x);
      x = 0;
      for (let M = 0; M < a.length; M++) {
        0 <= u[M] || w(M, x), x++;
      }
    }, "createConnectivityMap"), V = s((x, w) => a[w], "getCost"), A = s((x, w) => {
      x = d(x);
      w = d(w);
      return x.dist(w);
    }, "getHeuristic"), D = s((x, w) => {
      let S = [];
      var M = Math.floor(x % o);
      let R = 0 < M && l[x] & 1 && a[x - 1] !== 1 / 0, F = x >= o && l[x] & 2 && a[x - o] !== 1 / 0;
      M = M < o - 1 && l[x] & 4 && a[x + 1] !== 1 / 0;
      let H = x < o * r - o - 1 && l[x] & 8 && a[x + o] !== 1 / 0;
      return w ? (R && (F && S.push(x - o - 1), S.push(x - 1), H && S.push(x + o - 1)), F && S.push(x - o), M && (F && S.push(x - o + 1), S.push(x + 1), H && S.push(x + o + 1)), H && S.push(x + o)) : (R && S.push(x - 1), F && S.push(x - o), M && S.push(x + 1), H && S.push(x + o)), S;
    }, "getNeighbours");
    return n.use({id:"level", tileWidth() {
      return e.tileWidth;
    }, tileHeight() {
      return e.tileHeight;
    }, spawn(x, ...w) {
      let S = v(...w), M = (() => {
        if ("string" == typeof x) {
          if (e.tiles[x]) {
            if ("function" != typeof e.tiles[x]) {
              throw Error("Level symbol def must be a function returning a component list");
            }
            return e.tiles[x](S);
          }
          if (e.wildcardTile) {
            return e.wildcardTile(x, S);
          }
        } else {
          if (Array.isArray(x)) {
            return x;
          }
          throw Error("Expected a symbol or a component list");
        }
      })();
      if (!M) {
        return null;
      }
      let F = w = !1;
      for (var H of M) {
        "tile" === H.id && (F = !0), "pos" === H.id && (w = !0);
      }
      w || M.push(Pt(this.tile2Pos(S)));
      F || M.push(or());
      H = n.add(M);
      return w && (H.tilePosOffset = H.pos.clone()), H.tilePos = S, H.transform = dt(H), i && (p(H), this.trigger("spatialMapChanged"), this.trigger("navigationMapInvalid")), H;
    }, numColumns() {
      return o;
    }, numRows() {
      return r;
    }, levelWidth() {
      return o * this.tileWidth();
    }, levelHeight() {
      return r * this.tileHeight();
    }, tile2Pos(...x) {
      return v(...x).scale(this.tileWidth(), this.tileHeight());
    }, pos2Tile(...x) {
      x = v(...x);
      return v(Math.floor(x.x / this.tileWidth()), Math.floor(x.y / this.tileHeight()));
    }, getSpatialMap() {
      return i || C(), i;
    }, removeFromSpatialMap:b, insertIntoSpatialMap:p, onSpatialMapChanged(x) {
      return this.on("spatialMapChanged", x);
    }, onNavigationMapInvalid(x) {
      return this.on("navigationMapInvalid", x);
    }, getAt(x) {
      i || C();
      x = m(x);
      return i[x] || [];
    }, raycast(x, w) {
      let S = this.toWorld(x), M = this.toWorld(x.add(w)).sub(S), R = 1 / this.tileWidth();
      x = x.scale(R);
      w = ko(x, w, H => {
        var q = this.getAt(H);
        if (q.some(N => N.isObstacle)) {
          return !0;
        }
        H = null;
        for (let N of q) {
          N.has("area") && (q = N.worldArea().raycast(S, M)) && (H ? q.fraction < H.fraction && (H = q, H.object = N) : (H = q, H.object = N));
        }
        return H && (H.point = this.fromWorld(H.point).scale(R)), H || !1;
      }, 64);
      return w && (w.point = w.point.scale(this.tileWidth())), w;
    }, update() {
      i && f();
    }, invalidateNavigationMap() {
      u = l = a = null;
    }, onNavigationMapChanged(x) {
      return this.on("navigationMapChanged", x);
    }, getTilePath(x, w, S = {}) {
      if (a || O(), l || g(), u || y(), 0 > x.x || x.x >= o || 0 > x.y || x.y >= r || 0 > w.x || w.x >= o || 0 > w.y || w.y >= r) {
        return null;
      }
      x = m(x);
      var R = m(w);
      if (a[R] === 1 / 0) {
        return null;
      }
      if (x === R) {
        return [];
      }
      if (-1 != u[x] && u[x] !== u[R]) {
        return null;
      }
      let F = new Kt((k, Z) => k.cost < Z.cost);
      F.insert({cost:0, node:x});
      w = new Map();
      w.set(x, x);
      let H = new Map();
      for (H.set(x, 0); 0 !== F.length;) {
        let k = F.remove()?.node;
        if (k === R) {
          break;
        }
        var Z = D(k, S.allowDiagonals);
        for (var X of Z) {
          Z = (H.get(k) || 0) + V(k, X) + A(X, R), (!H.has(X) || Z < H.get(X)) && (H.set(X, Z), F.insert({cost:Z, node:X}), w.set(X, k));
        }
      }
      S = [];
      X = R;
      R = d(X);
      for (S.push(R); X !== x;) {
        X = w.get(X);
        if (void 0 === X) {
          throw Error("Bug in pathfinding algorithm");
        }
        R = d(X);
        S.push(R);
      }
      return S.reverse();
    }, getPath(x, w, S = {}) {
      let M = this.tileWidth(), R = this.tileHeight();
      return (S = this.getTilePath(this.pos2Tile(x), this.pos2Tile(w), S)) ? [x, ...S.slice(1, -1).map(j => j.scale(M, R).add(M / 2, R / 2)), w] : null;
    }}), n.onNavigationMapInvalid(() => {
      n.invalidateNavigationMap();
      n.trigger("navigationMapChanged");
    }), t.forEach((x, w) => {
      x = x.split("");
      o = Math.max(x.length, o);
      x.forEach((M, R) => {
        n.spawn(M, v(R, w));
      });
    }), n;
  }
  function Me(t, e, n) {
    return c.game.objEvents.registers[t] || (c.game.objEvents.registers[t] = new rn()), c.game.objEvents.on(t, (r, ...o) => {
      r.is(e) && n(r, ...o);
    });
  }
  function ji(t, e, n) {
    return Me("collide", t, (r, o, i) => o.is(e) && n(r, o, i));
  }
  function Ki(t, e, n) {
    return Me("collideUpdate", t, (r, o, i) => o.is(e) && n(r, o, i));
  }
  function Ii(t, e, n) {
    return Me("collideEnd", t, (r, o, i) => o.is(e) && n(r, o, i));
  }
  function sr(t, e) {
    c.game.root.get(t, {recursive:!0}).forEach(e);
    to(t, e);
    no((n, r) => {
      r === t && e(n);
    });
  }
  function _i(t, e) {
    let n = [];
    return sr(t, r => {
      if (!r.area) {
        throw Error("onHover() requires the object to have area() component");
      }
      n.push(r.onHover(() => e(r)));
    }), _e.join(n);
  }
  function Ni(t, e) {
    let n = [];
    return sr(t, r => {
      if (!r.area) {
        throw Error("onHoverUpdate() requires the object to have area() component");
      }
      n.push(r.onHoverUpdate(() => e(r)));
    }), _e.join(n);
  }
  function Ui(t, e) {
    let n = [];
    return sr(t, r => {
      if (!r.area) {
        throw Error("onHoverEnd() requires the object to have area() component");
      }
      n.push(r.onHoverEnd(() => e(r)));
    }), _e.join(n);
  }
  function Hi(t) {
    c.game.events.on("loading", t);
  }
  function qi(t) {
    c.app.onResize(t);
  }
  function zi(t) {
    c.game.events.on("error", t);
  }
  function Nt(t) {
    c.assets.loaded ? t() : c.game.events.on("load", t);
  }
  function Yi(t) {
    if (c.assets.loaded) {
      Hn().forEach(e => t(...e));
    } else {
      return c.game.events.on("loadError", t);
    }
  }
  function ro(...t) {
    c.game.cam.pos = v(...t);
  }
  function oo() {
    return c.game.cam.pos ? c.game.cam.pos.clone() : wt();
  }
  function so(...t) {
    c.game.cam.scale = v(...t);
  }
  function io() {
    return c.game.cam.scale.clone();
  }
  function ao(t) {
    c.game.cam.angle = t;
  }
  function uo() {
    return c.game.cam.angle;
  }
  function Wi() {
    return c.game.cam.transform.clone();
  }
  function co(t = I(255, 255, 255), e = 1) {
    let n = c.game.root.add([rr(ae(), ce()), er(t), tr(1), ur()]);
    t = n.fadeOut(e);
    return t.onEnd(() => ar(n)), t;
  }
  function $i() {
    return c.game.cam.transform.clone();
  }
  function Xi(t = 12) {
    c.game.cam.shake += t;
  }
  function dn(t) {
    return c.game.cam.transform.multVec2(t);
  }
  function ir(t) {
    return c.game.cam.transform.invert().multVec2(t);
  }
  function Qi(...t) {
    return tt("camPos", "setCamPos / getCamPos"), 0 < t.length && ro(...t), oo();
  }
  function Ji(...t) {
    return tt("camScale", "setCamScale / getCamScale"), 0 < t.length && so(...t), io();
  }
  function Zi(t) {
    return tt("camRot", "setCamRot / getCamRot"), void 0 !== t && ao(t), uo();
  }
  function ea(t = I(255, 255, 255), e = 1) {
    return tt("camFlash", "flash"), co(t, e);
  }
  function fn(t = []) {
    let e = new Map(), n = [], r = {}, o = new Ye(), i = [], a = new Set("*"), l = c.globalOpt.tagsAsComponents, u = null, m = !1, d = {id:Ts(), hidden:!1, transform:new he(), children:[], parent:null, set paused(p) {
      if (p !== m) {
        m = p;
        for (let b of i) {
          b.paused = p;
        }
      }
    }, get paused() {
      return m;
    }, get tags() {
      return Array.from(a);
    }, add(p) {
      p = Array.isArray(p) ? fn(p) : p;
      if (p.parent) {
        throw Error("Cannot add a game obj that already has a parent.");
      }
      return p.parent = this, p.transform = dt(p), this.children.push(p), p.trigger("add", p), c.game.events.trigger("add", p), p;
    }, readd(p) {
      let b = this.children.indexOf(p);
      return -1 !== b && (this.children.splice(b, 1), this.children.push(p)), p;
    }, remove(p) {
      let b = this.children.indexOf(p);
      if (-1 !== b) {
        p.parent = null;
        this.children.splice(b, 1);
        let f = s(O => {
          O.trigger("destroy");
          c.game.events.trigger("destroy", O);
          O.children.forEach(g => f(g));
        }, "trigger");
        f(p);
      }
    }, removeAll(p) {
      if (p) {
        this.get(p).forEach(b => this.remove(b));
      } else {
        for (let b of [...this.children]) {
          this.remove(b);
        }
      }
    }, fixedUpdate() {
      this.paused || (this.children.forEach(p => p.fixedUpdate()), this.trigger("fixedUpdate"));
    }, update() {
      this.paused || (this.children.forEach(p => p.update()), this.trigger("update"));
    }, draw() {
      if (!this.hidden) {
        this.canvas && (Oe(), this.canvas.bind());
        var p = c.gfx.fixed;
        this.fixed && (c.gfx.fixed = !0);
        be();
        Q(this.pos);
        rt(this.scale);
        $e(this.angle);
        var b = this.children.sort((f, O) => (f.layerIndex ?? c.game.defaultLayerIndex) - (O.layerIndex ?? c.game.defaultLayerIndex) || (f.z ?? 0) - (O.z ?? 0));
        if (this.mask) {
          let f = {intersect:c.k.drawMasked, subtract:c.k.drawSubtracted}[this.mask];
          if (!f) {
            throw Error(`Invalid mask func: "${this.mask}"`);
          }
          f(() => {
            b.forEach(O => O.draw());
          }, () => {
            this.trigger("draw");
          });
        } else {
          this.trigger("draw"), b.forEach(f => f.draw());
        }
        pe();
        c.gfx.fixed = p;
        this.canvas && (Oe(), this.canvas.unbind());
      }
    }, drawInspect() {
      this.hidden || (be(), Q(this.pos), rt(this.scale), $e(this.angle), this.children.forEach(p => p.drawInspect()), this.trigger("drawInspect"), pe());
    }, use(p) {
      if ("string" == typeof p) {
        return a.add(p);
      }
      if (!p || "object" != typeof p) {
        throw Error(`You can only pass a component or a string to .use(), you passed a "${typeof p}"`);
      }
      let b = [];
      p.id ? (this.unuse(p.id), r[p.id] = [], b = r[p.id], e.set(p.id, p), l && a.add(p.id)) : n.push(p);
      for (let O in p) {
        if (!ls.has(O)) {
          var g = Object.getOwnPropertyDescriptor(p, O);
          if (g) {
            if ("function" == typeof g.value && (p[O] = p[O].bind(this)), g.set && Object.defineProperty(p, O, {set:g.set.bind(this)}), g.get && Object.defineProperty(p, O, {get:g.get.bind(this)}), ms.has(O)) {
              b.push(this.on(O, "add" === O ? () => {
                u = s(V => b.push(V), "onCurCompCleanup");
                p[O]?.();
                u = null;
              } : p[O]).cancel);
            } else if (void 0 === this[O]) {
              Object.defineProperty(this, O, {get:s(() => p[O], "get"), set:s(y => p[O] = y, "set"), configurable:!0, enumerable:!0}), b.push(() => delete this[O]);
            } else {
              throw g = e.values().find(V => void 0 !== V[O])?.id, Error(`Duplicate component property: "${O}" while adding component "${p.id}"` + (g ? ` (originally added by "${g}")` : ""));
            }
          }
        }
      }
      g = s(() => {
        if (p.require) {
          for (let O of p.require) {
            if (!this.c(O)) {
              throw Error(`Component "${p.id}" requires component "${O}"`);
            }
          }
        }
      }, "checkDeps");
      p.destroy && b.push(p.destroy.bind(this));
      this.exists() ? (g(), p.add && (u = s(O => b.push(O), "onCurCompCleanup"), p.add.call(this), u = null), p.id && (this.trigger("use", p.id), c.game.events.trigger("use", this, p.id))) : p.require && b.push(this.on("add", g).cancel);
    }, unuse(p) {
      if (e.has(p)) {
        for (let b of e.values()) {
          if (b.require && b.require.includes(p)) {
            throw Error(`Can't unuse. Component "${b.id}" requires component "${p}"`);
          }
        }
        e.delete(p);
        this.trigger("unuse", p);
        c.game.events.trigger("unuse", this, p);
      } else {
        l && a.has(p) && a.delete(p);
      }
      r[p] && (r[p].forEach(b => b()), delete r[p]);
    }, c(p) {
      return e.get(p) ?? null;
    }, get(p, b = {}) {
      let f = s((g, y) => "comps" === b.only ? g.has(y) : "tags" === b.only ? g.is(y) : g.is(y) || g.has(y), "checkTagsOrComps"), O = b.recursive ? this.children.flatMap(s(function g(y) {
        return [y, ...y.children.flatMap(g)];
      }, "recurse")) : this.children;
      if (O = O.filter(g => p ? f(g, p) : !0), b.liveUpdate) {
        let g = s(V => b.recursive ? this.isAncestorOf(V) : V.parent === this, "isChild"), y = [];
        y.push(c.k.onAdd(V => {
          g(V) && f(V, p) && O.push(V);
        }));
        y.push(c.k.onDestroy(V => {
          if (g(V) && f(V, p)) {
            let A = O.findIndex(D => D.id === V.id);
            -1 !== A && O.splice(A, 1);
          }
        }));
        this.onDestroy(() => {
          for (let V of y) {
            V.cancel();
          }
        });
      }
      return O;
    }, query(p) {
      let f = p.include, O = p.exclude, g = [];
      switch(p.hierarchy || "children") {
        case "children":
          g = this.children;
          break;
        case "siblings":
          g = this.parent ? this.parent.children.filter(V => V !== this) : [];
          break;
        case "ancestors":
          let y = this.parent;
          for (; y;) {
            g.push(y), y = y.parent;
          }
          break;
        case "descendants":
          g = this.children.flatMap(s(function V(A) {
            return [A, ...A.children.flatMap(V)];
          }, "recurse"));
      }
      if (f && ("and" !== (p.includeOp || "and") && Array.isArray(p.include) ? g = g.filter(V => p.include.some(A => V.is(A))) : g = g.filter(V => V.is(f))), O && ("and" !== (p.includeOp || "and") && Array.isArray(p.include) ? g = g.filter(V => !p.exclude.some(A => V.is(A))) : g = g.filter(V => !V.is(O))), !0 === p.visible && (g = g.filter(y => y.visible)), p.distance) {
        if (!this.pos) {
          throw Error("Can't do a distance query from an object without pos");
        }
        let V = p.distance * p.distance;
        "near" === (p.distanceOp || "near") ? g = g.filter(A => A.pos && this.pos.sdist(A.pos) <= V) : g = g.filter(A => A.pos && this.pos.sdist(A.pos) > V);
      }
      return p.name && (g = g.filter(y => y.name === p.name)), g;
    }, isAncestorOf(p) {
      return p.parent ? p.parent === this || this.isAncestorOf(p.parent) : !1;
    }, exists() {
      return c.game.root.isAncestorOf(this);
    }, is(p, b = "and") {
      return Array.isArray(p) ? "and" === b ? p.every(f => a.has(f)) : p.some(f => a.has(f)) : a.has(p);
    }, tag(p) {
      if (Array.isArray(p)) {
        for (let b of p) {
          a.add(b), this.trigger("tag", b), c.game.events.trigger("tag", this, b);
        }
      } else {
        a.add(p), this.trigger("tag", p), c.game.events.trigger("tag", this, p);
      }
    }, untag(p) {
      if (Array.isArray(p)) {
        for (let b of p) {
          a.delete(b), this.trigger("untag", b), c.game.events.trigger("untag", this, b);
        }
      } else {
        a.delete(p), this.trigger("untag", p), c.game.events.trigger("untag", this, p);
      }
    }, has(p, b = "and") {
      return Array.isArray(p) ? "and" === b ? p.every(f => e.has(f)) : p.some(f => e.has(f)) : e.has(p);
    }, on(p, b) {
      let f = o.on(p, b.bind(this));
      return u && u(() => f.cancel()), f;
    }, trigger(p, ...b) {
      o.trigger(p, ...b);
      c.game.objEvents.trigger(p, this, ...b);
    }, destroy() {
      this.parent && this.parent.remove(this);
    }, inspect() {
      let p = {};
      for (let [b, f] of e) {
        p[b] = f.inspect?.() ?? null;
      }
      for (let [b, f] of n.entries()) {
        if (f.inspect) {
          p[b] = f.inspect();
        } else {
          for (let [O, g] of Object.entries(f)) {
            "function" != typeof g && (p[O] = `${O}: ${g}`);
          }
        }
      }
      return p;
    }, onAdd(p) {
      return this.on("add", p);
    }, onFixedUpdate(p) {
      return this.on("fixedUpdate", p);
    }, onUpdate(p) {
      return this.on("update", p);
    }, onDraw(p) {
      return this.on("draw", p);
    }, onDestroy(p) {
      return this.on("destroy", p);
    }, onUse(p) {
      return this.on("use", p);
    }, onUnuse(p) {
      return this.on("unuse", p);
    }, clearEvents() {
      o.clear();
    }}, C = "onKeyPress onKeyPressRepeat onKeyDown onKeyRelease onMousePress onMouseDown onMouseRelease onMouseMove onCharInput onMouseMove onTouchStart onTouchMove onTouchEnd onScroll onGamepadButtonPress onGamepadButtonDown onGamepadButtonRelease onGamepadStick onButtonPress onButtonDown onButtonRelease".split(" ");
    for (let p of C) {
      d[p] = (...b) => {
        let f = c.app[p]?.(...b);
        return i.push(f), d.onDestroy(() => f.cancel()), d.on("sceneEnter", () => {
          i.splice(i.indexOf(f), 1);
          let O = c.app[p]?.(...b);
          _e.replace(f, O);
          i.push(f);
        }), f;
      };
    }
    for (let p of t) {
      d.use(p);
    }
    return d;
  }
  function na(t) {
    c.game.gravity = t ? (c.game.gravity || v(0, 1)).unit().scale(t) : null;
  }
  function ra() {
    return c.game.gravity ? c.game.gravity.len() : 0;
  }
  function oa(t) {
    c.game.gravity = t.unit().scale(c.game.gravity ? c.game.gravity.len() : 1);
  }
  function ht() {
    return c.game.gravity ? c.game.gravity.unit() : v(0, 1);
  }
  function aa(t, e = {}) {
    function i() {
      c.debug.paused || c.app.isHidden() && !c.globalOpt.backgroundAudio || c.audio.ctx.resume();
    }
    function a() {
      i();
      r.play();
    }
    let n = new oe(), r = new Audio(t);
    r.crossOrigin = "anonymous";
    r.loop = !!e.loop;
    c.audio.ctx.createMediaElementSource(r).connect(c.audio.masterNode);
    s(i, "resumeAudioCtx");
    return s(a, "play"), e.paused || a(), r.onended = () => n.trigger(), {play() {
      a();
    }, seek(l) {
      r.currentTime = l;
    }, stop() {
      r.pause();
      this.seek(0);
    }, set loop(l) {
      r.loop = l;
    }, get loop() {
      return r.loop;
    }, set paused(l) {
      l ? r.pause() : a();
    }, get paused() {
      return r.paused;
    }, time() {
      return r.currentTime;
    }, duration() {
      return r.duration;
    }, set volume(l) {
      r.volume = Se(l, 0, 1);
    }, get volume() {
      return r.volume;
    }, set speed(l) {
      r.playbackRate = Math.max(l, 0);
    }, get speed() {
      return r.playbackRate;
    }, set detune(l) {
    }, get detune() {
      return 0;
    }, onEnd(l) {
      return n.add(l);
    }, then(l) {
      return this.onEnd(l);
    }};
  }
  function ua(t, e = {}) {
    if ("string" == typeof t && c.assets.music[t]) {
      return aa(c.assets.music[t], e);
    }
    let n = c.audio.ctx, r = e.paused ?? !1, o = n.createBufferSource(), i = new oe(), a = n.createGain(), l = n.createStereoPanner(), u = e.seek ?? 0, m = 0, d = 0, C = !1;
    o.loop = !!e.loop;
    o.detune.value = e.detune ?? 0;
    o.playbackRate.value = e.speed ?? 1;
    o.connect(l);
    o.onended = () => {
      f() >= (o.buffer?.duration ?? Number.POSITIVE_INFINITY) && i.trigger();
    };
    l.pan.value = e.pan ?? 0;
    l.connect(a);
    a.connect(c.audio.masterNode);
    a.gain.value = e.volume ?? 1;
    e = s(g => {
      o.buffer = g.buf;
      r || (m = n.currentTime, o.start(0, u), C = !0);
    }, "start");
    t = oi(t);
    t instanceof le && t.onLoad(e);
    let f = s(() => {
      if (!o.buffer) {
        return 0;
      }
      let g = r ? d - m : n.currentTime - m, y = o.buffer.duration;
      return o.loop ? g % y : Math.min(g, y);
    }, "getTime"), O = s(g => {
      let y = n.createBufferSource();
      return y.buffer = g.buffer, y.loop = g.loop, y.playbackRate.value = g.playbackRate.value, y.detune.value = g.detune.value, y.onended = g.onended, y.connect(l), y;
    }, "cloneNode");
    return {stop() {
      this.paused = !0;
      this.seek(0);
    }, set paused(g) {
      r !== g && ((r = g, g) ? (C && (o.stop(), C = !1), d = n.currentTime) : (o = O(o), g = d - m, o.start(0, g), C = !0, m = n.currentTime - g, d = 0));
    }, get paused() {
      return r;
    }, play(g = 0) {
      this.seek(g);
      this.paused = !1;
    }, seek(g) {
      o.buffer?.duration && (g > o.buffer.duration || (r ? (o = O(o), m = d - g) : (o.stop(), o = O(o), m = n.currentTime - g, o.start(0, g), C = !0, d = 0)));
    }, set speed(g) {
      o.playbackRate.value = g;
    }, get speed() {
      return o.playbackRate.value;
    }, set detune(g) {
      o.detune.value = g;
    }, get detune() {
      return o.detune.value;
    }, set volume(g) {
      a.gain.value = Math.max(g, 0);
    }, get volume() {
      return a.gain.value;
    }, set pan(g) {
      l.pan.value = g;
    }, get pan() {
      return l.pan.value;
    }, set loop(g) {
      o.loop = g;
    }, get loop() {
      return o.loop;
    }, duration() {
      return o.buffer?.duration ?? 0;
    }, time() {
      return f() % this.duration();
    }, onEnd(g) {
      return i.add(g);
    }, then(g) {
      return this.onEnd(g);
    }};
  }
  function cr(t) {
    return c.k.play(c.audio.burpSnd, t);
  }
  function lo(t) {
    c.audio.masterNode.gain.value = t;
  }
  function mo() {
    return c.audio.masterNode.gain.value;
  }
  function ca(t) {
    return tt("volume", "setVolume / getVolume"), void 0 !== t && lo(t), mo();
  }
  function lr() {
    c.app.onHide(() => {
      c.globalOpt.backgroundAudio || c.audio.ctx.suspend();
    });
    c.app.onShow(() => {
      c.globalOpt.backgroundAudio || c.debug.paused || c.audio.ctx.resume();
    });
    c.app.onResize(() => {
      if (!c.app.isFullscreen()) {
        var t = c.globalOpt.width && c.globalOpt.height;
        t && !c.globalOpt.stretch && !c.globalOpt.letterbox || (c.canvas.width = c.canvas.offsetWidth * c.pixelDensity, c.canvas.height = c.canvas.offsetHeight * c.pixelDensity, Zn(), t || (c.gfx.frameBuffer.free(), c.gfx.frameBuffer = new st(c.gfx.ggl, c.gfx.ggl.gl.drawingBufferWidth, c.gfx.ggl.gl.drawingBufferHeight), c.gfx.width = c.gfx.ggl.gl.drawingBufferWidth / c.pixelDensity / c.gscale, c.gfx.height = c.gfx.ggl.gl.drawingBufferHeight / c.pixelDensity / c.gscale));
      }
    });
    !1 !== c.globalOpt.debug && (c.app.onKeyPress(c.globalOpt.debugKey ?? "f1", () => c.debug.inspect = !c.debug.inspect), c.app.onKeyPress("f2", () => c.debug.clearLog()), c.app.onKeyPress("f8", () => c.debug.paused = !c.debug.paused), c.app.onKeyPress("f7", () => {
      c.debug.timeScale = on(Se(c.debug.timeScale - .2, 0, 2), 1);
    }), c.app.onKeyPress("f9", () => {
      c.debug.timeScale = on(Se(c.debug.timeScale + .2, 0, 2), 1);
    }), c.app.onKeyPress("f10", () => c.debug.stepFrame()));
    c.globalOpt.burp && c.app.onKeyPress("b", () => cr());
  }
  function la(t, e = {}) {
    let n = c.game.root.add([Pt(t), mr()]), r = 5 * (e.speed || 1), o = e.scale || 1;
    n.add([hn(c.boomSprite), Ut(0), gn("center"), po(r, o), ...(e.comps ?? [])]);
    let i = n.add([hn(c.kaSprite), Ut(0), gn("center"), bn(), ...(e.comps ?? [])]);
    return i.wait(.4 / r, () => i.use(po(r, o))), i.onDestroy(() => n.destroy()), n;
  }
  function fo(t, e) {
    if (c.game.layers) {
      throw Error("Layers can only be assigned once.");
    }
    e = t.indexOf(e);
    if (-1 == e) {
      throw Error("The default layer name should be present in the layers list.");
    }
    c.game.layers = t;
    c.game.defaultLayerIndex = e;
  }
  function ma() {
    return c.game.layers;
  }
  function pa() {
    return c.game.layers?.[c.game.defaultLayerIndex] ?? null;
  }
  function da(t, e) {
    tt("layers", "setLayers");
    fo(t, e);
  }
  function ar(t) {
    t.destroy();
  }
  function fa() {
    return c.game.root;
  }
  function ha(t, e) {
    c.game.scenes[t] = e;
  }
  function ga(t, ...e) {
    if (!c.game.scenes[t]) {
      throw Error(`Scene not found: ${t}`);
    }
    c.game.events.onOnce("frameEnd", () => {
      c.game.events.trigger("sceneLeave", t);
      c.app.events.clear();
      c.game.events.clear();
      c.game.objEvents.clear();
      [...c.game.root.children].forEach(n => {
        !n.stay || n.scenesToStay && !n.scenesToStay.includes(t) ? c.game.root.remove(n) : n.trigger("sceneEnter", t);
      });
      c.game.root.clearEvents();
      lr();
      c.game.cam = {pos:null, scale:v(1), angle:0, shake:0, transform:new he()};
      c.game.scenes[t](...e);
    });
    c.game.currentScene = t;
  }
  function ba(t) {
    return c.game.events.on("sceneLeave", t);
  }
  function ya() {
    return c.game.currentScene;
  }
  function hn(t, e = {}) {
    let n = null, r = null, o = null, i = new oe();
    if (!t) {
      throw Error("Please pass the resource name or data to sprite()");
    }
    let a = s((u, m, d, C) => {
      let p = v(1, 1);
      return d && C ? (p.x = d / (u.width * m.w), p.y = C / (u.height * m.h)) : d ? (p.x = d / (u.width * m.w), p.y = p.x) : C && (p.y = C / (u.height * m.h), p.x = p.y), p;
    }, "calcTexScale"), l = s((u, m) => {
      if (m) {
        var d = m.frames[0].clone();
        e.quad && (d = d.scale(e.quad));
        var C = a(m.tex, d, e.width, e.height);
        u.width = m.tex.width * d.w * C.x;
        u.height = m.tex.height * d.h * C.y;
        e.anim && u.play(e.anim);
        n = m;
        i.trigger(n);
      }
    }, "setSpriteData");
    return {id:"sprite", width:0, height:0, frame:e.frame || 0, quad:e.quad || new z(0, 0, 1, 1), animSpeed:e.animSpeed ?? 1, flipX:e.flipX ?? !1, flipY:e.flipY ?? !1, get sprite() {
      return t.toString();
    }, set sprite(u) {
      (u = It(u)) && u.onLoad(d => l(this, d));
    }, get animFrame() {
      if (!n || !r || null === o) {
        return this.frame;
      }
      let u = n.anims[r.name];
      return "number" == typeof u ? u : this.frame - Math.min(u.from, u.to);
    }, draw() {
      if (n) {
        var u = n.frames[this.frame ?? 0];
        if (!u) {
          throw Error(`Frame not found: ${this.frame ?? 0}`);
        }
        if (n.slice9) {
          let {left:m, right:d, top:C, bottom:p} = n.slice9;
          var b = n.tex.width * u.w, f = n.tex.height * u.h, O = this.width - m - d, g = this.height - C - p, y = m / b;
          b = d / b;
          let A = 1 - y - b, D = C / f;
          f = p / f;
          let x = 1 - D - f;
          O = [me(0, 0, y, D), me(y, 0, A, D), me(y + A, 0, b, D), me(0, D, y, x), me(y, D, A, x), me(y + A, D, b, x), me(0, D + x, y, f), me(y, D + x, A, f), me(y + A, D + x, b, f), me(0, 0, m, C), me(m, 0, O, C), me(m + O, 0, d, C), me(0, C, m, g), me(m, C, O, g), me(m + O, C, d, g), me(0, C + g, m, p), me(m, C + g, O, p), me(m + O, C + g, d, p)];
          for (g = 0; 9 > g; g++) {
            y = O[g], b = O[g + 9], Vt(Object.assign(Ke(this), {pos:b.pos(), tex:n.tex, quad:u.scale(y), flipX:this.flipX, flipY:this.flipY, tiled:e.tiled, width:b.w, height:b.h}));
          }
        } else {
          Vt(Object.assign(Ke(this), {tex:n.tex, quad:u.scale(this.quad ?? new z(0, 0, 1, 1)), flipX:this.flipX, flipY:this.flipY, tiled:e.tiled, width:this.width, height:this.height}));
        }
      }
    }, add() {
      let u = It(t);
      u ? u.onLoad(m => l(this, m)) : Nt(() => l(this, It(t).data));
    }, update() {
      if (n && r && null !== o) {
        var u = n.anims[r.name];
        if ("number" == typeof u) {
          this.frame = u;
        } else {
          if (0 === u.speed) {
            throw Error("Sprite anim speed cannot be 0");
          }
          r.timer += te() * this.animSpeed;
          r.timer >= 1 / r.speed && (r.timer = 0, this.frame += o, (this.frame < Math.min(u.from, u.to) || this.frame > Math.max(u.from, u.to)) && (r.loop ? r.pingpong ? (this.frame -= o, o *= -1, this.frame += o) : this.frame = u.from : r.pingpong ? o === Math.sign(u.to - u.from) ? (this.frame = u.to, o *= -1, this.frame += o) : (this.frame = u.from, r.onEnd(), this.stop()) : (this.frame = u.to, r.onEnd(), this.stop())));
        }
      }
    }, play(u, m = {}) {
      if (n) {
        var d = n.anims[u];
        if (void 0 === d) {
          throw Error(`Anim not found: ${u}`);
        }
        r && this.stop();
        r = "number" == typeof d ? {name:u, timer:0, loop:!1, pingpong:!1, speed:0, onEnd:s(() => {
        }, "onEnd")} : {name:u, timer:0, loop:m.loop ?? d.loop ?? !1, pingpong:m.pingpong ?? d.pingpong ?? !1, speed:m.speed ?? d.speed ?? 10, onEnd:m.onEnd ?? (() => {
        })};
        o = "number" == typeof d ? null : d.from < d.to ? 1 : -1;
        this.frame = "number" == typeof d ? d : d.from;
        this.trigger("animStart", u);
      } else {
        i.add(() => this.play(u, m));
      }
    }, stop() {
      if (r) {
        var u = r.name;
        r = null;
        this.trigger("animEnd", u);
      }
    }, numFrames() {
      return n?.frames.length ?? 0;
    }, getCurAnim() {
      return r;
    }, curAnim() {
      return r?.name;
    }, getAnim(u) {
      return n?.anims[u] ?? null;
    }, hasAnim(u) {
      return !!this.getAnim(u);
    }, onAnimEnd(u) {
      return this.on("animEnd", u);
    }, onAnimStart(u) {
      return this.on("animStart", u);
    }, renderArea() {
      return new $(v(0), this.width, this.height);
    }, inspect() {
      return "string" == typeof t ? `sprite: "${t}"` : null;
    }};
  }
  function xa(t, e = {}) {
    function n(o) {
      let i = He(Object.assign(Ke(o), {text:o.text + "", size:o.textSize, font:o.font, width:e.width && o.width, align:o.align, letterSpacing:o.letterSpacing, lineSpacing:o.lineSpacing, transform:o.textTransform, styles:o.textStyles, indentAll:e.indentAll}));
      return e.width || (o.width = i.width / (o.scale?.x || 1)), o.height = i.height / (o.scale?.y || 1), i;
    }
    s(n, "update");
    let r = {id:"text", set text(o) {
      t = o;
      n(this);
      this.renderedText = Xn(t).text;
    }, get text() {
      return t;
    }, textSize:e.size ?? 36, font:e.font, width:e.width ?? 0, height:0, align:e.align, lineSpacing:e.lineSpacing, letterSpacing:e.letterSpacing, textTransform:e.transform, textStyles:e.styles, renderedText:t ? Xn(t).text : "", add() {
      Nt(() => n(this));
    }, draw() {
      qe(n(this));
    }, renderArea() {
      return new $(v(0), this.width, this.height);
    }};
    return n(r), r;
  }
  function va(t, e) {
    return {id:"rect", width:t, height:e, draw() {
      it(Object.assign(Ke(this), {width:this.width, height:this.height}));
    }, renderArea() {
      return new $(v(0), this.width, this.height);
    }, inspect() {
      return `uvquad: (${Math.ceil(this.width)}w, ${Math.ceil(this.height)})h`;
    }};
  }
  function Ca(t = {}) {
    let e = null, n = null, r = null, o = null;
    return {id:"agent", require:["pos", "tile"], agentSpeed:t.speed ?? 100, allowDiagonals:t.allowDiagonals ?? !0, getDistanceToTarget() {
      return e ? this.pos.dist(e) : 0;
    }, getNextLocation() {
      return n && r ? n[r] : null;
    }, getPath() {
      return n ? n.slice() : null;
    }, getTarget() {
      return e;
    }, isNavigationFinished() {
      return n ? null === r : !0;
    }, isTargetReachable() {
      return null !== n;
    }, isTargetReached() {
      return e ? this.pos.eq(e) : !0;
    }, setTarget(i) {
      e = i;
      r = (n = this.getLevel().getPath(this.pos, e, {allowDiagonals:this.allowDiagonals})) ? 0 : null;
      n && null !== r ? (o || (o = this.getLevel().onNavigationMapChanged(() => {
        e && n && null !== r && (n = this.getLevel().getPath(this.pos, e, {allowDiagonals:this.allowDiagonals}), n ? (r = 0, this.trigger("navigationNext", this, n[r])) : (r = null, this.trigger("navigationEnded", this)));
      }), this.onDestroy(() => o?.cancel())), this.trigger("navigationStarted", this), this.trigger("navigationNext", this, n[r])) : this.trigger("navigationEnded", this);
    }, update() {
      if (e && n && null !== r) {
        if (2 > this.pos.sdist(n[r])) {
          if (r === n.length - 1) {
            this.pos = e.clone();
            r = null;
            this.trigger("navigationEnded", this);
            this.trigger("targetReached", this);
            return;
          }
          r++;
          this.trigger("navigationNext", this, n[r]);
        }
        this.moveTo(n[r], this.agentSpeed);
      }
    }, onNavigationStarted(i) {
      return this.on("navigationStarted", i);
    }, onNavigationNext(i) {
      return this.on("navigationNext", i);
    }, onNavigationEnded(i) {
      return this.on("navigationEnded", i);
    }, onTargetReached(i) {
      return this.on("targetReached", i);
    }, inspect() {
      return "agent: " + JSON.stringify({target:JSON.stringify(e), path:JSON.stringify(n)});
    }};
  }
  function wa(t) {
    let e = t.graph;
    return {id:"pathfinder", require:["pos"], navigateTo(n) {
      return this.graph?.getWaypointPath(this.pos, n, t.navigationOpt);
    }, get graph() {
      if (e) {
        return e;
      }
      let n = this.parent;
      for (; n;) {
        if (n.has("pathfinderMap")) {
          return n.graph;
        }
        n = n.parent;
      }
    }, set graph(n) {
      e = n;
    }};
  }
  function Oa(t = {}) {
    let e = t.waypoints, n = t.speed || 100, r = t.endBehavior || "stop", o = 0, i = null != e;
    return {id:"patrol", require:["pos"], get patrolSpeed() {
      return n;
    }, set patrolSpeed(a) {
      n = a;
    }, get waypoints() {
      return e;
    }, set waypoints(a) {
      e = a;
      o = 0;
      i = !1;
    }, get nextLocation() {
      return e ? e[o] : void 0;
    }, update() {
      let a = this.nextLocation;
      if (e && a && !i && (this.moveTo(a, n), 9 > this.pos.sdist(a))) {
        switch(r) {
          case "loop":
            o = (o + 1) % e.length;
            break;
          case "ping-pong":
            o += 1;
            o == e.length && (e.reverse(), o = 0);
            break;
          case "stop":
            o = Math.min(o + 1, e.length - 1), o == e.length - 1 && (i = !0, this.trigger("patrolFinished"));
        }
      }
    }, onPatrolFinished(a) {
      return this.on("patrolFinished", a);
    }};
  }
  function Ea(t, e = {}) {
    let n = "function" == typeof t ? t : () => c.game.root.query(t), r = e.checkFrequency || 1, o = "number" == typeof e.direction ? E.fromAngle(e.direction) : e.direction, i = 0;
    return {id:"sentry", require:["pos"], direction:"number" == typeof e.direction ? E.fromAngle(e.direction) : e.direction, spotted:[], set directionAngle(a) {
      this.direction = void 0 !== a ? E.fromAngle(a) : void 0;
    }, get directionAngle() {
      return this.direction ? this.direction.angle() : void 0;
    }, fieldOfView:e.fieldOfView || 200, isWithinFieldOfView(a, l, u) {
      l = ("number" == typeof l ? E.fromAngle(l) : l) || o;
      u = u || e.fieldOfView;
      if (!l || !u || 360 <= u) {
        return !0;
      }
      u /= 2;
      return a.pos && l.angleBetween(a.pos.sub(this.pos)) <= u;
    }, hasLineOfSight(a) {
      let l = nr(this.pos, a.pos.sub(this.pos), e.raycastExclude);
      return null != l && l.object === a;
    }, update() {
      if (i += te(), i > r) {
        i -= r;
        let a = n();
        if (a.length && o && this.fieldOfView && 360 > this.fieldOfView) {
          let l = this.fieldOfView / 2;
          a = a.filter(u => u.pos && o.angleBetween(u.pos.sub(this.pos)) <= l);
        }
        a.length && e.lineOfSight && (a = a.filter(l => l.pos && this.hasLineOfSight(l)));
        0 < a.length && (this.spotted = a, this.trigger("objectSpotted", a));
      }
    }, onObjectsSpotted(a) {
      return this.on("objectSpotted", a);
    }};
  }
  function or(t = {}) {
    let e = v(0), n = t.isObstacle ?? !1, r = t.cost ?? 0, o = t.edges ?? [], i = s(() => {
      let l = {left:1, top:2, right:4, bottom:8};
      return o.map(u => l[u] || 0).reduce((u, m) => u | m, 0);
    }, "getEdgeMask"), a = i();
    return {id:"tile", tilePosOffset:t.offset ?? v(0), set tilePos(l) {
      let u = this.getLevel();
      e = l.clone();
      this.pos = v(this.tilePos.x * u.tileWidth(), this.tilePos.y * u.tileHeight()).add(this.tilePosOffset);
    }, get tilePos() {
      return e;
    }, set isObstacle(l) {
      n !== l && (n = l, this.getLevel().invalidateNavigationMap());
    }, get isObstacle() {
      return n;
    }, set cost(l) {
      r !== l && (r = l, this.getLevel().invalidateNavigationMap());
    }, get cost() {
      return r;
    }, set edges(l) {
      o = l;
      a = i();
      this.getLevel().invalidateNavigationMap();
    }, get edges() {
      return o;
    }, get edgeMask() {
      return a;
    }, getLevel() {
      return this.parent;
    }, tileMove(l) {
      let u = this.getLevel();
      u.removeFromSpatialMap(this);
      this.tilePos = this.tilePos.add(l);
      u.insertIntoSpatialMap(this);
      u.trigger("spatialMapChanged");
    }, moveLeft() {
      this.tileMove(v(-1, 0));
    }, moveRight() {
      this.tileMove(v(1, 0));
    }, moveUp() {
      this.tileMove(v(0, -1));
    }, moveDown() {
      this.tileMove(v(0, 1));
    }};
  }
  function Ta(t, e) {
    return e.add(e.sub(t));
  }
  function Aa(t = {}) {
    let e = [], n = 0, r = !1;
    return {id:"animate", require:t.followMotion ? ["rotate"] : void 0, base:{pos:v(0, 0), angle:0, scale:v(1, 1), opacity:1}, animation:{paused:!1, seek(o) {
      n = Se(o, 0, this.duration);
      e.forEach(i => {
        i.isFinished = !1;
      });
      r = !1;
    }, get duration() {
      return e.reduce((o, i) => Math.max(i.duration, o), 0);
    }}, add() {
      t.relative && (this.has("pos") && (this.base.pos = this.pos.clone()), this.has("rotate") && (this.base.angle = this.angle), this.has("scale") && (this.base.scale = this.scale), this.has("opacity") && (this.base.opacity = this.opacity));
    }, update() {
      if (!this.animation.paused) {
        var o = !0, i;
        n += te();
        for (let a of e) {
          (i = a.update(this, n)) && !a.isFinished && (a.isFinished = !0, this.trigger("animateChannelFinished", a.name)), o && (o = i);
        }
        o && !r && (r = !0, this.trigger("animateFinished"));
      }
    }, animate(o, i, a) {
      r = !1;
      this.unanimate(o);
      "number" == typeof i[0] ? e.push(new ho(o, i, a, t.relative || !1)) : i[0] instanceof E ? e.push(new go(o, i, a, t.relative || !1, "pos" === o && (t.followMotion || !1))) : i[0] instanceof K && e.push(new bo(o, i, a, t.relative || !1));
    }, unanimate(o) {
      let i = e.findIndex(a => a.name === o);
      0 <= i && e.splice(i, 1);
    }, unanimateAll() {
      e.splice(0, e.length);
    }, onAnimateFinished(o) {
      return this.on("animateFinished", o);
    }, onAnimateChannelFinished(o) {
      return this.on("animateChannelFinished", o);
    }, serializeAnimationChannels() {
      return e.reduce((o, i) => (o[i.name] = i.serialize(), o), {});
    }, serializeAnimationOptions() {
      let o = {};
      return t.followMotion && (o.followMotion = !0), t.relative && (o.relative = !0), o;
    }};
  }
  function yo(t, e) {
    e = {name:t.name};
    return t.has("animate") && (e.channels = t.serializeAnimationChannels(), Object.assign(e, t.serializeAnimationOptions())), 0 < t.children.length && (e.children = t.children.filter(r => r.has("named")).map(r => yo(r, r.name))), e;
  }
  function po(t = 2, e = 1) {
    let n = 0;
    return {require:["scale"], update() {
      let r = Math.sin(n * t) * e;
      0 > r && this.destroy();
      this.scale = v(r);
      n += te();
    }};
  }
  function Sa(t, e) {
    if (null == t) {
      throw Error("health() requires the initial amount of hp");
    }
    return {id:"health", hurt(n = 1) {
      this.setHP(t - n);
      this.trigger("hurt", n);
    }, heal(n = 1) {
      let r = t;
      this.setHP(t + n);
      this.trigger("heal", t - r);
    }, hp() {
      return t;
    }, maxHP() {
      return e ?? null;
    }, setMaxHP(n) {
      e = n;
    }, setHP(n) {
      t = e ? Math.min(e, n) : n;
      0 >= t && this.trigger("death");
    }, onHurt(n) {
      return this.on("hurt", n);
    }, onHeal(n) {
      return this.on("heal", n);
    }, onDeath(n) {
      return this.on("death", n);
    }, inspect() {
      return `health: ${t}`;
    }};
  }
  function Va(t, e = {}) {
    if (null == t) {
      throw Error("lifespan() requires time");
    }
    let n = e.fade ?? 0;
    return {id:"lifespan", require:["opacity"], add() {
      c.game.root.wait(t, () => {
        this.opacity = this.opacity ?? 1;
        0 < n ? c.game.root.tween(this.opacity, 0, n, r => this.opacity = r, nt.linear).onEnd(() => {
          this.destroy();
        }) : this.destroy();
      });
    }};
  }
  function Pa(t) {
    return {id:"named", name:t};
  }
  function Ga(t, e, n) {
    function o(u) {
      r[u] || (r[u] = {enter:new oe(), end:new oe(), update:new oe(), draw:new oe()});
    }
    function i(u, m, d) {
      return o(m), r[m][u].add(d);
    }
    function a(u, m, ...d) {
      o(m);
      r[m][u].trigger(...d);
    }
    if (!t) {
      throw Error("state() requires an initial state");
    }
    let r = {};
    s(o, "initStateEvents");
    s(i, "on");
    s(a, "trigger");
    let l = !1;
    return {id:"state", state:t, enterState(u, ...m) {
      if (l = !0, e && !e.includes(u)) {
        throw Error(`State not found: ${u}`);
      }
      let d = this.state;
      if (n) {
        if (!n?.[d]) {
          return;
        }
        let C = "string" == typeof n[d] ? [n[d]] : n[d];
        if (!C.includes(u)) {
          throw Error(`Cannot transition state from "${d}" to "${u}". Available transitions: ${C.map(p => `"${p}"`).join(", ")}`);
        }
      }
      a("end", d, ...m);
      this.state = u;
      a("enter", u, ...m);
      a("enter", `${d} -> ${u}`, ...m);
    }, onStateTransition(u, m, d) {
      return i("enter", `${u} -> ${m}`, d);
    }, onStateEnter(u, m) {
      return i("enter", u, m);
    }, onStateUpdate(u, m) {
      return i("update", u, m);
    }, onStateDraw(u, m) {
      return i("draw", u, m);
    }, onStateEnd(u, m) {
      return i("end", u, m);
    }, update() {
      l || (a("enter", t), l = !0);
      a("update", this.state);
    }, draw() {
      a("draw", this.state);
    }, inspect() {
      return `state: ${this.state}`;
    }};
  }
  function mr(t) {
    return {id:"stay", stay:!0, scenesToStay:t};
  }
  function Ma(t = !0, e) {
    let n, r;
    return {id:"textInput", hasFocus:t, require:["text"], typedText:"", add() {
      let o = s(() => {
        this.text = this.typedText.replace(/([\[\\])/g, "\\$1");
      }, "flip");
      n = c.k.onCharInput(i => {
        this.hasFocus && (!e || this.typedText.length < e) && (c.k.isKeyDown("shift") ? this.typedText += i.toUpperCase() : this.typedText += i, o());
      });
      r = c.k.onKeyPressRepeat("backspace", () => {
        this.hasFocus && (this.typedText = this.typedText.slice(0, -1));
        o();
      });
    }, destroy() {
      n.cancel();
      r.cancel();
    }};
  }
  function bn(t = 1E3) {
    return {id:"timer", maxLoopsPerFrame:t, loop(e, n, r = -1, o = !1) {
      let i = o ? 0 : e, a = new oe(), l = this.onUpdate(() => {
        i += c.app.state.dt;
        for (let u = 0; i >= e && u < this.maxLoopsPerFrame; u++) {
          if (-1 != r && (r--, 0 > r)) {
            l.cancel();
            a.trigger();
            break;
          }
          n();
          i -= e;
        }
      });
      return {get paused() {
        return l.paused;
      }, set paused(u) {
        l.paused = u;
      }, cancel:l.cancel, onEnd:a.add, then(u) {
        return a.add(u), this;
      }};
    }, wait(e, n) {
      return this.loop(e, n ?? (() => {
      }), 1, !0);
    }, tween(e, n, r, o, i = nt.linear) {
      let a = 0, l = [], u = this.onUpdate(() => {
        a += c.app.state.dt;
        let m = Math.min(a / r, 1);
        o(fe(e, n, i(m)));
        1 === m && (u.cancel(), o(n), l.forEach(d => d()));
      });
      return {get paused() {
        return u.paused;
      }, set paused(m) {
        u.paused = m;
      }, onEnd(m) {
        l.push(m);
      }, then(m) {
        return this.onEnd(m), this;
      }, cancel() {
        u.cancel();
      }, finish() {
        u.cancel();
        o(n);
        l.forEach(m => m());
      }};
    }};
  }
  function Da(t = {}) {
    let e = {}, n = new Set(), r = [];
    return {id:"area", collisionIgnore:t.collisionIgnore ?? [], add() {
      xo++;
      this.area.cursor && r.push(this.onHover(() => c.app.setCursor(this.area.cursor)));
      r.push(this.onCollideUpdate((o, i) => {
        if (!o.id) {
          throw Error("area() requires the object to have an id");
        }
        e[o.id] || this.trigger("collide", o, i);
        i && (e[o.id] = i, n.add(o.id));
      }));
    }, destroy() {
      xo--;
      for (let o of r) {
        o.cancel();
      }
    }, fixedUpdate() {
      for (let o in e) {
        n.has(Number(o)) || (this.trigger("collideEnd", e[o].target), delete e[o]);
      }
      n.clear();
    }, drawInspect() {
      let o = this.localArea();
      be();
      Q(this.area.offset);
      let i = {outline:{width:4 / Nn(), color:I(0, 0, 255)}, anchor:this.anchor, fill:!1, fixed:at(this)};
      o instanceof $ ? ve({...i, pos:o.pos, width:o.width * this.area.scale.x, height:o.height * this.area.scale.y}) : o instanceof ye ? Ge({...i, pts:o.pts, scale:this.area.scale}) : o instanceof we && Ue({...i, pos:o.center, radius:o.radius});
      pe();
    }, area:{shape:t.shape ?? null, scale:t.scale ? v(t.scale) : v(1), offset:t.offset ?? v(0), cursor:t.cursor ?? null}, isClicked() {
      return c.app.isMousePressed() && this.isHovering();
    }, isHovering() {
      let o = at(this) ? c.k.mousePos() : c.k.toWorld(c.k.mousePos());
      return this.hasPoint(o);
    }, checkCollision(o) {
      if (!o.id) {
        throw Error("checkCollision() requires the object to have an id");
      }
      return e[o.id] ?? null;
    }, getCollisions() {
      return Object.values(e);
    }, isColliding(o) {
      if (!o.id) {
        throw Error("isColliding() requires the object to have an id");
      }
      return !!e[o.id];
    }, isOverlapping(o) {
      if (!o.id) {
        throw Error("isOverlapping() requires the object to have an id");
      }
      return (o = e[o.id]) && o.hasOverlap();
    }, onClick(o, i = "left") {
      i = c.app.onMousePress(i, () => {
        this.isHovering() && o();
      });
      return r.push(i), i;
    }, onHover(o) {
      let i = !1;
      return this.onUpdate(() => {
        i ? i = this.isHovering() : this.isHovering() && (i = !0, o());
      });
    }, onHoverUpdate(o) {
      return this.onUpdate(() => {
        this.isHovering() && o();
      });
    }, onHoverEnd(o) {
      let i = !1;
      return this.onUpdate(() => {
        i ? this.isHovering() || (i = !1, o()) : i = this.isHovering();
      });
    }, onCollide(o, i) {
      if ("function" == typeof o && void 0 === i) {
        return this.on("collide", o);
      }
      if ("string" == typeof o) {
        return this.onCollide((a, l) => {
          a.is(o) && i?.(a, l);
        });
      }
      throw Error("onCollide() requires either a function or a tag");
    }, onCollideUpdate(o, i) {
      if ("function" == typeof o && void 0 === i) {
        return this.on("collideUpdate", o);
      }
      if ("string" == typeof o) {
        return this.on("collideUpdate", (a, l) => a.is(o) && i?.(a, l));
      }
      throw Error("onCollideUpdate() requires either a function or a tag");
    }, onCollideEnd(o, i) {
      if ("function" == typeof o && void 0 === i) {
        return this.on("collideEnd", o);
      }
      if ("string" == typeof o) {
        return this.on("collideEnd", a => a.is(o) && i?.(a));
      }
      throw Error("onCollideEnd() requires either a function or a tag");
    }, hasPoint(o) {
      return et(this.worldArea(), o);
    }, resolveCollision(o) {
      (o = this.checkCollision(o)) && !o.resolved && (this.pos = this.pos.add(o.displacement), o.resolved = !0);
    }, localArea() {
      return this.area.shape ? this.area.shape : this.renderArea();
    }, worldArea() {
      let o = this.localArea();
      if (!(o instanceof ye || o instanceof $)) {
        throw Error("Only support polygon and rect shapes for now");
      }
      let i = this.transform.clone().translate(this.area.offset).scale(v(this.area.scale ?? 1));
      if (o instanceof $) {
        let a = Ne(this.anchor || "topleft").add(1, 1).scale(-.5).scale(o.width, o.height);
        i.translate(a);
      }
      return o.transform(i);
    }, screenArea() {
      let o = this.worldArea();
      return at(this) ? o : o.transform(c.game.cam.transform);
    }, inspect() {
      return this.area.scale?.x == this.area.scale?.y ? `area: ${this.area.scale?.x?.toFixed(1)}x` : `area: (${this.area.scale?.x?.toFixed(1)}x, ${this.area.scale.y?.toFixed(1)}y)`;
    }};
  }
  function Ba(t = {}) {
    let e = null, n = null, r = !1, o = v(0), i = null, a = null, l;
    return {id:"body", require:["pos"], vel:v(0), drag:t.drag ?? 0, jumpForce:t.jumpForce ?? 640, gravityScale:t.gravityScale ?? 1, isStatic:t.isStatic ?? !1, mass:t.mass ?? 1, add() {
      if (i = this.pos.clone(), a = this.pos.clone(), l = this.pos.clone(), 0 === this.mass) {
        throw Error("Can't set body mass to 0");
      }
      this.has("area") && (this.onCollideUpdate((u, m) => {
        if (m && u.has("body") && !m.resolved) {
          this.trigger("beforePhysicsResolve", m);
          var d = m.reverse();
          (u.trigger("beforePhysicsResolve", d), m.resolved || d.resolved || this.isStatic && u.isStatic) || (this.isStatic || u.isStatic ? (d = !this.isStatic && u.isStatic ? m : m.reverse(), d.source.pos = d.source.pos.add(d.displacement), d.source.transform = dt(d.source)) : (d = this.mass + u.mass, this.pos = this.pos.add(m.displacement.scale(u.mass / d)), u.pos = u.pos.add(m.displacement.scale(-this.mass / d)), this.transform = dt(this), u.transform = dt(u)), m.resolved = !0, this.trigger("physicsResolve", 
          m), u.trigger("physicsResolve", m.reverse()));
        }
      }), this.onPhysicsResolve(u => {
        if (c.game.gravity) {
          if (u.isBottom() && this.isFalling()) {
            this.vel = this.vel.reject(c.game.gravity.unit());
            let m = e;
            e = u.target;
            m != e && (n = u.target.pos);
            r ? r = !1 : m || (this.trigger("ground", e), u.target.trigger("land", this));
          } else {
            u.isTop() && this.isJumping() && (this.vel = this.vel.reject(c.game.gravity.unit()), this.trigger("headbutt", u.target), u.target.trigger("headbutted", this));
          }
        }
      }));
    }, update() {
      e && this.isColliding(e) && e.exists() && e.has("body") && (n && !e.pos.eq(n) && !1 !== t.stickToPlatform && this.moveBy(e.pos.sub(n)), n = e.pos);
      let u = un();
      u && (this.pos.x == l.x && (this.pos.x = fe(i.x, a.x, u / an()), l.x = this.pos.x), this.pos.y == l.y && (this.pos.y = fe(i.y, a.y, u / an()), l.y = this.pos.y));
    }, fixedUpdate() {
      if (i && (this.pos.x == l.x && (this.pos.x = i.x), this.pos.y == l.y && (this.pos.y = i.y), i = null), c.game.gravity && !this.isStatic) {
        r && (e = null, n = null, this.trigger("fallOff"), r = !1);
        !e || this.isColliding(e) && e.exists() && e.has("body") || (r = !0);
        var m = this.vel.clone();
        this.vel = this.vel.add(c.game.gravity.scale(this.gravityScale * te()));
        let d = t.maxVelocity ?? 65536;
        this.vel.slen() > d * d && (this.vel = this.vel.unit().scale(d));
        0 > m.dot(c.game.gravity) && 0 <= this.vel.dot(c.game.gravity) && this.trigger("fall");
      }
      if (this.vel.x += o.x * te(), this.vel.y += o.y * te(), this.vel.x *= 1 - this.drag * te(), this.vel.y *= 1 - this.drag * te(), this.move(this.vel), un()) {
        i = this.pos.clone(), m = this.vel.add(o.scale(te())), a = this.pos.add(m.scale(te())), l = this.pos.clone();
      }
      o.x = 0;
      o.y = 0;
    }, onPhysicsResolve(u) {
      return this.on("physicsResolve", u);
    }, onBeforePhysicsResolve(u) {
      return this.on("beforePhysicsResolve", u);
    }, curPlatform() {
      return e;
    }, isGrounded() {
      return null !== e;
    }, isFalling() {
      return 0 < this.vel.dot(ht());
    }, isJumping() {
      return 0 > this.vel.dot(ht());
    }, applyImpulse(u) {
      this.isStatic || (this.vel = this.vel.add(u));
    }, addForce(u) {
      this.isStatic || (o.x += u.x / this.mass, o.y += u.y / this.mass);
    }, jump(u) {
      this.isStatic || (e = null, n = null, this.vel = ht().scale(-u || -this.jumpForce));
    }, onGround(u) {
      return this.on("ground", u);
    }, onFall(u) {
      return this.on("fall", u);
    }, onFallOff(u) {
      return this.on("fallOff", u);
    }, onHeadbutt(u) {
      return this.on("headbutt", u);
    }, onLand(u) {
      return this.on("land", u);
    }, onHeadbutted(u) {
      return this.on("headbutted", u);
    }, inspect() {
      return `gravityScale: ${this.gravityScale}x`;
    }};
  }
  function Fa(t = 2) {
    let e = t;
    return {id:"doubleJump", require:["body"], numJumps:t, add() {
      this.onGround(() => {
        e = this.numJumps;
      });
    }, doubleJump(n) {
      0 >= e || (e < this.numJumps && this.trigger("doubleJump"), e--, this.jump(n));
    }, onDoubleJump(n) {
      return this.on("doubleJump", n);
    }, inspect() {
      return `jumpsLeft: ${e}`;
    }};
  }
  function La(t) {
    return {id:"surfaceEffector", require:["area"], speed:t.speed, speedVariation:t.speedVariation ?? 0, forceScale:t.speedVariation ?? .9, add() {
      this.onCollideUpdate("body", (e, n) => {
        n = n?.normal.normal();
        let o = e.vel.project(n);
        n = n?.scale(this.speed)?.sub(o);
        e.addForce(n?.scale(e.mass * this.forceScale));
      });
    }};
  }
  function ja(t) {
    return {id:"areaEffector", require:["area"], useGlobalAngle:t.useGlobalAngle || !1, forceAngle:t.forceAngle, forceMagnitude:t.forceMagnitude, forceVariation:t.forceVariation ?? 0, linearDrag:t.linearDrag ?? 0, add() {
      this.onCollideUpdate("body", (e, n) => {
        e.has("body") && (n = E.fromAngle(this.forceAngle).scale(this.forceMagnitude), e.addForce(n), this.linearDrag && e.addForce(e.vel.scale(-this.linearDrag)));
      });
    }};
  }
  function Ka(t) {
    return {id:"pointEffector", require:["area", "pos"], forceMagnitude:t.forceMagnitude, forceVariation:t.forceVariation ?? 0, distanceScale:t.distanceScale ?? 1, forceMode:t.forceMode || "inverseLinear", linearDrag:t.linearDrag ?? 0, add() {
      this.onCollideUpdate("body", (e, n) => {
        n = this.pos.sub(e.pos);
        let o = n.len(), i = o * this.distanceScale / 10;
        n = n.scale(this.forceMagnitude * ("constant" === this.forceMode ? 1 : "inverseLinear" === this.forceMode ? 1 / i : 1 / i ** 2) / o);
        e.addForce(n);
        this.linearDrag && e.addForce(e.vel.scale(-this.linearDrag));
      });
    }};
  }
  function Ia(t) {
    return {id:"constantForce", require:["body"], force:t.force, update() {
      this.force && this.addForce(this.force);
    }};
  }
  function ka(t) {
    return {id:"platformEffector", require:["area", "body"], surfaceArc:t.surfaceArc ?? 180, useOneWay:t.useOneWay ?? !1, add() {
      this.onBeforePhysicsResolve(e => {
        var n = e.target.vel;
        n = ht().scale(-1).angleBetween(n);
        Math.abs(n) > this.surfaceArc / 2 && e.preventResolution();
      });
    }};
  }
  function _a(t) {
    return {id:"buoyancyEffector", require:["area"], surfaceLevel:t.surfaceLevel, density:t.density ?? 1, linearDrag:t.linearDrag ?? 1, angularDrag:t.angularDrag ?? .2, flowAngle:t.flowAngle ?? 0, flowMagnitude:t.flowMagnitude ?? 0, flowVariation:t.flowVariation ?? 0, add() {
      this.onCollideUpdate("body", (e, n) => {
        n = e.worldArea();
        [n] = n.cut(v(-100, this.surfaceLevel), v(100, this.surfaceLevel));
        n && (this.applyBuoyancy(e, n), this.applyDrag(e, n));
        this.flowMagnitude && e.addForce(E.fromAngle(this.flowAngle).scale(this.flowMagnitude));
      });
    }, applyBuoyancy(e, n) {
      n = this.density * n.area();
      n = v(0, 1).scale(-n);
      e.addForce(n);
    }, applyDrag(e, n) {
      n = e.vel.scale(-(this.density * this.linearDrag));
      e.addForce(n);
    }};
  }
  function gn(t) {
    if (!t) {
      throw Error("Please define an anchor");
    }
    return {id:"anchor", anchor:t, inspect() {
      return "string" == typeof this.anchor ? "anchor: " + this.anchor : "anchor: " + this.anchor.toString();
    }};
  }
  function ur() {
    return {id:"fixed", fixed:!0};
  }
  function Na(t, e) {
    return {id:"follow", require:["pos"], follow:{obj:t, offset:e ?? v(0)}, add() {
      t.exists() && (this.pos = this.follow.obj.pos.add(this.follow.offset));
    }, update() {
      t.exists() && (this.pos = this.follow.obj.pos.add(this.follow.offset));
    }};
  }
  function Ua(t) {
    let e = c.game.layers?.indexOf(t);
    return {id:"layer", get layerIndex() {
      return e ?? null;
    }, get layer() {
      return e ? c.game.layers?.[e] ?? null : null;
    }, set layer(n) {
      if (e = c.game.layers?.indexOf(n), -1 == e) {
        throw Error("Invalid layer name");
      }
    }, inspect() {
      return `layer: ${this.layer}`;
    }};
  }
  function Ha(t, e) {
    let n = "number" == typeof t ? E.fromAngle(t) : t.unit();
    return {id:"move", require:["pos"], update() {
      this.move(n.scale(e));
    }};
  }
  function qa(t = {}) {
    let e = t.distance ?? 200, n = !1;
    return {id:"offscreen", require:["pos"], isOffScreen() {
      let r = this.screenPos();
      if (!r) {
        return !1;
      }
      let o = new $(v(0), ae(), ce());
      return !Bt(o, r) && o.sdistToPoint(r) > e * e;
    }, onExitScreen(r) {
      return this.on("exitView", r);
    }, onEnterScreen(r) {
      return this.on("enterView", r);
    }, update() {
      this.isOffScreen() ? (n || (this.trigger("exitView"), n = !0), t.hide && (this.hidden = !0), t.pause && (this.paused = !0), t.destroy && this.destroy()) : (n && (this.trigger("enterView"), n = !1), t.hide && (this.hidden = !1), t.pause && (this.paused = !1));
    }};
  }
  function Pt(...t) {
    return {id:"pos", pos:v(...t), moveBy(...e) {
      this.pos = this.pos.add(v(...e));
    }, move(...e) {
      this.moveBy(v(...e).scale(te()));
    }, moveTo(...e) {
      if ("number" == typeof e[0] && "number" == typeof e[1]) {
        return this.moveTo(v(e[0], e[1]), e[2]);
      }
      let n = e[0];
      e = e[1];
      if (void 0 === e) {
        this.pos = v(n);
      } else {
        var o = n.sub(this.pos);
        o.len() <= e * te() ? this.pos = v(n) : this.move(o.unit().scale(e));
      }
    }, worldPos(e = null) {
      return e ? (this.pos = this.pos.add(this.fromWorld(e)), null) : this.parent ? this.parent.transform.multVec2(this.pos) : this.pos;
    }, toWorld(e) {
      return this.parent ? this.parent.transform.multVec2(this.pos.add(e)) : this.pos.add(e);
    }, fromWorld(e) {
      return this.parent ? this.parent.transform.invert().multVec2(e).sub(this.pos) : e.sub(this.pos);
    }, screenPos(e = null) {
      return e ? (this.pos = this.pos.add(this.fromScreen(e)), null) : (e = this.worldPos()) ? at(this) ? e : dn(e) : null;
    }, toScreen(e) {
      e = this.toWorld(e);
      return at(this) ? e : dn(e);
    }, fromScreen(e) {
      return at(this) ? this.fromWorld(e) : this.fromWorld(ir(e));
    }, toOther(e, n) {
      return e.fromWorld(this.toWorld(n));
    }, fromOther(e, n) {
      return e.toOther(this, n);
    }, inspect() {
      return `pos: (${Math.round(this.pos.x)}x, ${Math.round(this.pos.y)}y)`;
    }, drawInspect() {
      Ue({color:I(255, 0, 0), radius:4 / Nn()});
    }};
  }
  function za(t) {
    return {id:"rotate", angle:t ?? 0, rotateBy(e) {
      this.angle += e;
    }, rotateTo(e) {
      this.angle = e;
    }, inspect() {
      return `angle: ${Math.round(this.angle)}`;
    }};
  }
  function Ut(...t) {
    if (0 === t.length) {
      return Ut(1);
    }
    let e = v(...t);
    return {id:"scale", set scale(n) {
      if (!(n instanceof E)) {
        throw Error("The scale property on scale is a vector. Use scaleTo or scaleBy to set the scale with a number.");
      }
      e = v(n);
    }, get scale() {
      return e;
    }, scaleTo(...n) {
      e = v(...n);
    }, scaleBy(...n) {
      e = e.scale(v(...n));
    }, inspect() {
      return e.x == e.y ? `scale: ${e.x.toFixed(1)}x` : `scale: (${e.x.toFixed(1)}x, ${e.y.toFixed(1)}y)`;
    }};
  }
  function Ya(t) {
    return {id:"z", z:t, inspect() {
      return `z: ${this.z}`;
    }};
  }
  var Tn = Object.defineProperty, nu = Object.getOwnPropertyDescriptor, ru = Object.getOwnPropertyNames, ou = Object.prototype.hasOwnProperty, s = (t, e) => Tn(t, "name", {value:e, configurable:!0}), iu = (t, e, n, r) => {
    if (e && "object" == typeof e || "function" == typeof e) {
      for (let o of ru(e)) {
        !ou.call(t, o) && o !== n && Tn(t, o, {get:() => e[o], enumerable:!(r = nu(e, o)) || r.enumerable});
      }
    }
    return t;
  }, To = (() => {
    for (var t = new Uint8Array(128), e = 0; 64 > e; e++) {
      t[26 > e ? e + 65 : 52 > e ? e + 71 : 62 > e ? e - 4 : 4 * e - 205] = e;
    }
    return n => {
      for (var r = n.length, o = new Uint8Array(3 * (r - ("\x3d" == n[r - 1]) - ("\x3d" == n[r - 2])) / 4 | 0), i = 0, a = 0; i < r;) {
        var l = t[n.charCodeAt(i++)], u = t[n.charCodeAt(i++)], m = t[n.charCodeAt(i++)], d = t[n.charCodeAt(i++)];
        o[a++] = l << 2 | u >> 4;
        o[a++] = u << 4 | m >> 2;
        o[a++] = m << 6 | d;
      }
      return o;
    };
  })(), hc = {};
  ((t, e) => {
    for (var n in e) {
      Tn(t, n, {get:e[n], enumerable:!0});
    }
  })(hc, {default:() => fc});
  module.exports = (t => iu(Tn({}, "__esModule", {value:!0}), t))(hc);
  const node_modules$kaplay$dist$kaplay_cjs$classdecl$var0 = class {
    static $jscomp$static$block$510831985$0() {
      s(this, "Color");
    }
    constructor(e, n, r) {
      this.b = this.g = this.r = 255;
      this.r = Se(e, 0, 255);
      this.g = Se(n, 0, 255);
      this.b = Se(r, 0, 255);
    }
    static fromArray(e) {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var0(e[0], e[1], e[2]);
    }
    static fromHex(e) {
      if ("number" == typeof e) {
        return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var0(e >> 16 & 255, e >> 8 & 255, e >> 0 & 255);
      }
      if ("string" == typeof e) {
        e = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);
        if (!e) {
          throw Error("Invalid hex color format");
        }
        return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var0(parseInt(e[1], 16), parseInt(e[2], 16), parseInt(e[3], 16));
      }
      throw Error("Invalid hex color format");
    }
    static fromHSL(e, n, r) {
      if (0 == n) {
        return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var0(255 * r, 255 * r, 255 * r);
      }
      let o = s((d, C, p) => (0 > p && (p += 1), 1 < p && --p, p < 1 / 6 ? d + 6 * (C - d) * p : .5 > p ? C : p < 2 / 3 ? d + (C - d) * (2 / 3 - p) * 6 : d), "hue2rgb");
      n = .5 > r ? r * (1 + n) : r + n - r * n;
      let a = 2 * r - n;
      r = o(a, n, e + 1 / 3);
      let u = o(a, n, e);
      e = o(a, n, e - 1 / 3);
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var0(Math.round(255 * r), Math.round(255 * u), Math.round(255 * e));
    }
    static $jscomp$static$init$510831985$1$RED() {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var0(255, 0, 0);
    }
    static $jscomp$static$init$510831985$2$GREEN() {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var0(0, 255, 0);
    }
    static $jscomp$static$init$510831985$3$BLUE() {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var0(0, 0, 255);
    }
    static $jscomp$static$init$510831985$4$YELLOW() {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var0(255, 255, 0);
    }
    static $jscomp$static$init$510831985$5$MAGENTA() {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var0(255, 0, 255);
    }
    static $jscomp$static$init$510831985$6$CYAN() {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var0(0, 255, 255);
    }
    static $jscomp$static$init$510831985$7$WHITE() {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var0(255, 255, 255);
    }
    static $jscomp$static$init$510831985$8$BLACK() {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var0(0, 0, 0);
    }
    clone() {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var0(this.r, this.g, this.b);
    }
    lighten(e) {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var0(this.r + e, this.g + e, this.b + e);
    }
    darken(e) {
      return this.lighten(-e);
    }
    invert() {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var0(255 - this.r, 255 - this.g, 255 - this.b);
    }
    mult(e) {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var0(this.r * e.r / 255, this.g * e.g / 255, this.b * e.b / 255);
    }
    lerp(e, n) {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var0(fe(this.r, e.r, n), fe(this.g, e.g, n), fe(this.b, e.b, n));
    }
    toHSL() {
      let e = this.r / 255, n = this.g / 255, r = this.b / 255, o = Math.max(e, n, r);
      var i = Math.min(e, n, r);
      let a = (o + i) / 2, u = a;
      if (o == i) {
        a = i = 0;
      } else {
        let m = o - i;
        switch(i = .5 < u ? m / (2 - o - i) : m / (o + i), o) {
          case e:
            a = (n - r) / m + (n < r ? 6 : 0);
            break;
          case n:
            a = (r - e) / m + 2;
            break;
          case r:
            a = (e - n) / m + 4;
        }
        a /= 6;
      }
      return [a, i, u];
    }
    eq(e) {
      return this.r === e.r && this.g === e.g && this.b === e.b;
    }
    toString() {
      return `rgb(${this.r}, ${this.g}, ${this.b})`;
    }
    toHex() {
      return "#" + (16777216 + (this.r << 16) + (this.g << 8) + this.b).toString(16).slice(1);
    }
    toArray() {
      return [this.r, this.g, this.b];
    }
  };
  node_modules$kaplay$dist$kaplay_cjs$classdecl$var0.$jscomp$static$block$510831985$0();
  node_modules$kaplay$dist$kaplay_cjs$classdecl$var0.RED = node_modules$kaplay$dist$kaplay_cjs$classdecl$var0.$jscomp$static$init$510831985$1$RED();
  node_modules$kaplay$dist$kaplay_cjs$classdecl$var0.GREEN = node_modules$kaplay$dist$kaplay_cjs$classdecl$var0.$jscomp$static$init$510831985$2$GREEN();
  node_modules$kaplay$dist$kaplay_cjs$classdecl$var0.BLUE = node_modules$kaplay$dist$kaplay_cjs$classdecl$var0.$jscomp$static$init$510831985$3$BLUE();
  node_modules$kaplay$dist$kaplay_cjs$classdecl$var0.YELLOW = node_modules$kaplay$dist$kaplay_cjs$classdecl$var0.$jscomp$static$init$510831985$4$YELLOW();
  node_modules$kaplay$dist$kaplay_cjs$classdecl$var0.MAGENTA = node_modules$kaplay$dist$kaplay_cjs$classdecl$var0.$jscomp$static$init$510831985$5$MAGENTA();
  node_modules$kaplay$dist$kaplay_cjs$classdecl$var0.CYAN = node_modules$kaplay$dist$kaplay_cjs$classdecl$var0.$jscomp$static$init$510831985$6$CYAN();
  node_modules$kaplay$dist$kaplay_cjs$classdecl$var0.WHITE = node_modules$kaplay$dist$kaplay_cjs$classdecl$var0.$jscomp$static$init$510831985$7$WHITE();
  node_modules$kaplay$dist$kaplay_cjs$classdecl$var0.BLACK = node_modules$kaplay$dist$kaplay_cjs$classdecl$var0.$jscomp$static$init$510831985$8$BLACK();
  var K = node_modules$kaplay$dist$kaplay_cjs$classdecl$var0;
  s(I, "rgb");
  var Ao = s((t, e, n) => K.fromHSL(t, e, n), "hsl2rgb");
  s(ue, "deg2rad");
  s(lt, "rad2deg");
  s(Se, "clamp");
  s(fe, "lerp");
  s(Ve, "map");
  s(Vo, "mapc");
  const node_modules$kaplay$dist$kaplay_cjs$classdecl$var1 = class {
    static $jscomp$static$block$510831985$9() {
      s(this, "Vec2");
    }
    constructor(e = 0, n = e) {
      this.y = this.x = 0;
      this.x = e;
      this.y = n;
    }
    static fromAngle(e) {
      e = ue(e);
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var1(Math.cos(e), Math.sin(e));
    }
    static fromArray(e) {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var1(e[0], e[1]);
    }
    static $jscomp$static$init$510831985$10$ZERO() {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var1(0, 0);
    }
    static $jscomp$static$init$510831985$11$ONE() {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var1(1, 1);
    }
    static $jscomp$static$init$510831985$12$LEFT() {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var1(-1, 0);
    }
    static $jscomp$static$init$510831985$13$RIGHT() {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var1(1, 0);
    }
    static $jscomp$static$init$510831985$14$UP() {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var1(0, -1);
    }
    static $jscomp$static$init$510831985$15$DOWN() {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var1(0, 1);
    }
    clone() {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var1(this.x, this.y);
    }
    add(...e) {
      e = v(...e);
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var1(this.x + e.x, this.y + e.y);
    }
    sub(...e) {
      e = v(...e);
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var1(this.x - e.x, this.y - e.y);
    }
    scale(...e) {
      e = v(...e);
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var1(this.x * e.x, this.y * e.y);
    }
    dist(...e) {
      e = v(...e);
      return this.sub(e).len();
    }
    sdist(...e) {
      e = v(...e);
      return this.sub(e).slen();
    }
    static sdist(e, n) {
      let r = e.x - n.x;
      e = e.y - n.y;
      return r * r + e * e;
    }
    len() {
      return Math.sqrt(this.dot(this));
    }
    slen() {
      return this.dot(this);
    }
    unit() {
      let e = this.len();
      return 0 === e ? new node_modules$kaplay$dist$kaplay_cjs$classdecl$var1(0) : this.scale(1 / e);
    }
    normal() {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var1(this.y, -this.x);
    }
    reflect(e) {
      return this.sub(e.scale(2 * this.dot(e)));
    }
    project(e) {
      return e.scale(e.dot(this) / e.len());
    }
    reject(e) {
      return this.sub(this.project(e));
    }
    dot(e) {
      return this.x * e.x + this.y * e.y;
    }
    static dot(e, n) {
      return e.x * e.x + e.y * e.y;
    }
    cross(e) {
      return this.x * e.y - this.y * e.x;
    }
    static cross(e, n) {
      return e.x * n.y - e.y * n.x;
    }
    angle(...e) {
      e = v(...e);
      return lt(Math.atan2(this.y - e.y, this.x - e.x));
    }
    angleBetween(...e) {
      e = v(...e);
      return lt(Math.atan2(this.cross(e), this.dot(e)));
    }
    lerp(e, n) {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var1(fe(this.x, e.x, n), fe(this.y, e.y, n));
    }
    slerp(e, n) {
      var r = this.dot(e);
      let o = this.cross(e);
      r = Math.atan2(o, r);
      return this.scale(Math.sin((1 - n) * r)).add(e.scale(Math.sin(n * r))).scale(1 / o);
    }
    isZero() {
      return 0 === this.x && 0 === this.y;
    }
    toFixed(e) {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var1(Number(this.x.toFixed(e)), Number(this.y.toFixed(e)));
    }
    transform(e) {
      return e.multVec2(this);
    }
    eq(e) {
      return this.x === e.x && this.y === e.y;
    }
    bbox() {
      return new $(this, 0, 0);
    }
    toString() {
      return `vec2(${this.x.toFixed(2)}, ${this.y.toFixed(2)})`;
    }
    toArray() {
      return [this.x, this.y];
    }
  };
  node_modules$kaplay$dist$kaplay_cjs$classdecl$var1.$jscomp$static$block$510831985$9();
  node_modules$kaplay$dist$kaplay_cjs$classdecl$var1.ZERO = node_modules$kaplay$dist$kaplay_cjs$classdecl$var1.$jscomp$static$init$510831985$10$ZERO();
  node_modules$kaplay$dist$kaplay_cjs$classdecl$var1.ONE = node_modules$kaplay$dist$kaplay_cjs$classdecl$var1.$jscomp$static$init$510831985$11$ONE();
  node_modules$kaplay$dist$kaplay_cjs$classdecl$var1.LEFT = node_modules$kaplay$dist$kaplay_cjs$classdecl$var1.$jscomp$static$init$510831985$12$LEFT();
  node_modules$kaplay$dist$kaplay_cjs$classdecl$var1.RIGHT = node_modules$kaplay$dist$kaplay_cjs$classdecl$var1.$jscomp$static$init$510831985$13$RIGHT();
  node_modules$kaplay$dist$kaplay_cjs$classdecl$var1.UP = node_modules$kaplay$dist$kaplay_cjs$classdecl$var1.$jscomp$static$init$510831985$14$UP();
  node_modules$kaplay$dist$kaplay_cjs$classdecl$var1.DOWN = node_modules$kaplay$dist$kaplay_cjs$classdecl$var1.$jscomp$static$init$510831985$15$DOWN();
  var E = node_modules$kaplay$dist$kaplay_cjs$classdecl$var1;
  s(v, "vec2");
  const node_modules$kaplay$dist$kaplay_cjs$classdecl$var2 = class {
    static $jscomp$static$block$510831985$16() {
      s(this, "Quad");
    }
    constructor(e, n, r, o) {
      this.y = this.x = 0;
      this.h = this.w = 1;
      this.x = e;
      this.y = n;
      this.w = r;
      this.h = o;
    }
    scale(e) {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var2(this.x + this.w * e.x, this.y + this.h * e.y, this.w * e.w, this.h * e.h);
    }
    pos() {
      return new E(this.x, this.y);
    }
    clone() {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var2(this.x, this.y, this.w, this.h);
    }
    eq(e) {
      return this.x === e.x && this.y === e.y && this.w === e.w && this.h === e.h;
    }
    toString() {
      return `quad(${this.x}, ${this.y}, ${this.w}, ${this.h})`;
    }
  };
  node_modules$kaplay$dist$kaplay_cjs$classdecl$var2.$jscomp$static$block$510831985$16();
  var z = node_modules$kaplay$dist$kaplay_cjs$classdecl$var2;
  s(me, "quad");
  const node_modules$kaplay$dist$kaplay_cjs$classdecl$var3 = class {
    static $jscomp$static$block$510831985$17() {
      s(this, "Mat2");
    }
    constructor(e, n, r, o) {
      this.a = e;
      this.b = n;
      this.c = r;
      this.d = o;
    }
    mul(e) {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var3(this.a * e.a + this.b * e.c, this.a * e.b + this.b * e.d, this.c * e.a + this.d * e.c, this.c * e.b + this.d * e.d);
    }
    transform(e) {
      return v(this.a * e.x + this.b * e.y, this.c * e.x + this.d * e.y);
    }
    get inverse() {
      let e = this.det;
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var3(this.d / e, -this.b / e, -this.c / e, this.a / e);
    }
    get transpose() {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var3(this.a, this.c, this.b, this.d);
    }
    get eigenvalues() {
      let e = this.trace / 2, n = this.det;
      return [e + Math.sqrt(e * e - n), e - Math.sqrt(e * e - n)];
    }
    eigenvectors(e, n) {
      return 0 != this.c ? [[e - this.d, this.c], [n - this.d, this.c]] : 0 != this.b ? [[this.b, e - this.a], [this.b, n - this.a]] : Math.abs(this.transform(v(1, 0)).x - e) < Number.EPSILON ? [[1, 0], [0, 1]] : [[0, 1], [1, 0]];
    }
    get det() {
      return this.a * this.d - this.b * this.c;
    }
    get trace() {
      return this.a + this.d;
    }
    static rotation(e) {
      let n = Math.cos(e);
      e = Math.sin(e);
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var3(n, e, -e, n);
    }
    static scale(e, n) {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var3(e, 0, 0, n);
    }
  };
  node_modules$kaplay$dist$kaplay_cjs$classdecl$var3.$jscomp$static$block$510831985$17();
  var Dt = node_modules$kaplay$dist$kaplay_cjs$classdecl$var3;
  const node_modules$kaplay$dist$kaplay_cjs$classdecl$var4 = class {
    static $jscomp$static$block$510831985$18() {
      s(this, "Mat3");
    }
    constructor(e, n, r, o, i, a, l, u, m) {
      this.m11 = e;
      this.m12 = n;
      this.m13 = r;
      this.m21 = o;
      this.m22 = i;
      this.m23 = a;
      this.m31 = l;
      this.m32 = u;
      this.m33 = m;
    }
    static fromMat2(e) {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var4(e.a, e.b, 0, e.c, e.d, 0, 0, 0, 1);
    }
    toMat2() {
      return new Dt(this.m11, this.m12, this.m21, this.m22);
    }
    mul(e) {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var4(this.m11 * e.m11 + this.m12 * e.m21 + this.m13 * e.m31, this.m11 * e.m12 + this.m12 * e.m22 + this.m13 * e.m32, this.m11 * e.m13 + this.m12 * e.m23 + this.m13 * e.m33, this.m21 * e.m11 + this.m22 * e.m21 + this.m23 * e.m31, this.m21 * e.m12 + this.m22 * e.m22 + this.m23 * e.m32, this.m21 * e.m13 + this.m22 * e.m23 + this.m23 * e.m33, this.m31 * e.m11 + this.m32 * e.m21 + this.m33 * e.m31, this.m31 * e.m12 + this.m32 * e.m22 + this.m33 * 
      e.m32, this.m31 * e.m13 + this.m32 * e.m23 + this.m33 * e.m33);
    }
    get det() {
      return this.m11 * this.m22 * this.m33 + this.m12 * this.m23 * this.m31 + this.m13 * this.m21 * this.m32 - this.m13 * this.m22 * this.m31 - this.m12 * this.m21 * this.m33 - this.m11 * this.m23 * this.m32;
    }
    rotate(e) {
      let n = Math.cos(e);
      e = Math.sin(e);
      let o = this.m11, i = this.m12;
      return this.m11 = n * this.m11 + e * this.m21, this.m12 = n * this.m12 + e * this.m22, this.m21 = n * this.m21 - e * o, this.m22 = n * this.m22 - e * i, this;
    }
    scale(e, n) {
      return this.m11 *= e, this.m12 *= e, this.m21 *= n, this.m22 *= n, this;
    }
    get inverse() {
      let e = this.det;
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var4((this.m22 * this.m33 - this.m23 * this.m32) / e, (this.m13 * this.m32 - this.m12 * this.m33) / e, (this.m12 * this.m23 - this.m13 * this.m22) / e, (this.m23 * this.m31 - this.m21 * this.m33) / e, (this.m11 * this.m33 - this.m13 * this.m31) / e, (this.m13 * this.m21 - this.m11 * this.m23) / e, (this.m21 * this.m32 - this.m22 * this.m31) / e, (this.m12 * this.m31 - this.m11 * this.m32) / e, (this.m11 * this.m22 - this.m12 * this.m21) / 
      e);
    }
    get transpose() {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var4(this.m11, this.m21, this.m31, this.m12, this.m22, this.m32, this.m13, this.m23, this.m33);
    }
  };
  node_modules$kaplay$dist$kaplay_cjs$classdecl$var4.$jscomp$static$block$510831985$18();
  var bt = node_modules$kaplay$dist$kaplay_cjs$classdecl$var4, he = (() => {
    const node_modules$kaplay$dist$kaplay_cjs$classdecl$var5 = class {
      static $jscomp$static$block$510831985$19() {
        s(this, "Mat4");
      }
      constructor(e) {
        this.m = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        e && (this.m = e);
      }
      static translate(e) {
        return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var5([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, e.x, e.y, 0, 1]);
      }
      static scale(e) {
        return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var5([e.x, 0, 0, 0, 0, e.y, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      }
      static rotateX(e) {
        e = ue(-e);
        let n = Math.cos(e);
        e = Math.sin(e);
        return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var5([1, 0, 0, 0, 0, n, -e, 0, 0, e, n, 0, 0, 0, 0, 1]);
      }
      static rotateY(e) {
        e = ue(-e);
        let n = Math.cos(e);
        e = Math.sin(e);
        return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var5([n, 0, e, 0, 0, 1, 0, 0, -e, 0, n, 0, 0, 0, 0, 1]);
      }
      static rotateZ(e) {
        e = ue(-e);
        let n = Math.cos(e);
        e = Math.sin(e);
        return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var5([n, -e, 0, 0, e, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      }
      translate(e) {
        return this.m[12] += this.m[0] * e.x + this.m[4] * e.y, this.m[13] += this.m[1] * e.x + this.m[5] * e.y, this.m[14] += this.m[2] * e.x + this.m[6] * e.y, this.m[15] += this.m[3] * e.x + this.m[7] * e.y, this;
      }
      scale(e) {
        return this.m[0] *= e.x, this.m[4] *= e.y, this.m[1] *= e.x, this.m[5] *= e.y, this.m[2] *= e.x, this.m[6] *= e.y, this.m[3] *= e.x, this.m[7] *= e.y, this;
      }
      rotate(e) {
        e = ue(-e);
        let n = Math.cos(e);
        e = Math.sin(e);
        let o = this.m[0], i = this.m[1], a = this.m[4], l = this.m[5];
        return this.m[0] = o * n + i * e, this.m[1] = -o * e + i * n, this.m[4] = a * n + l * e, this.m[5] = -a * e + l * n, this;
      }
      mult(e) {
        let n = [];
        for (let r = 0; 4 > r; r++) {
          for (let o = 0; 4 > o; o++) {
            n[4 * r + o] = this.m[0 + o] * e.m[4 * r] + this.m[4 + o] * e.m[4 * r + 1] + this.m[8 + o] * e.m[4 * r + 2] + this.m[12 + o] * e.m[4 * r + 3];
          }
        }
        return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var5(n);
      }
      multVec2(e) {
        return new E(e.x * this.m[0] + e.y * this.m[4] + this.m[12], e.x * this.m[1] + e.y * this.m[5] + this.m[13]);
      }
      getTranslation() {
        return new E(this.m[12], this.m[13]);
      }
      getScale() {
        if (0 != this.m[0] || 0 != this.m[1]) {
          var n = Math.sqrt(this.m[0] * this.m[0] + this.m[1] * this.m[1]);
          return new E(n, (this.m[0] * this.m[5] - this.m[1] * this.m[4]) / n);
        }
        return 0 != this.m[4] || 0 != this.m[5] ? (n = Math.sqrt(this.m[4] * this.m[4] + this.m[5] * this.m[5]), new E((this.m[0] * this.m[5] - this.m[1] * this.m[4]) / n, n)) : new E(0, 0);
      }
      getRotation() {
        if (0 != this.m[0] || 0 != this.m[1]) {
          var e = Math.sqrt(this.m[0] * this.m[0] + this.m[1] * this.m[1]);
          return lt(0 < this.m[1] ? Math.acos(this.m[0] / e) : -Math.acos(this.m[0] / e));
        }
        return 0 != this.m[4] || 0 != this.m[5] ? (e = Math.sqrt(this.m[4] * this.m[4] + this.m[5] * this.m[5]), lt(Math.PI / 2 - (0 < this.m[5] ? Math.acos(-this.m[4] / e) : -Math.acos(this.m[4] / e)))) : 0;
      }
      getSkew() {
        if (0 != this.m[0] || 0 != this.m[1]) {
          var e = Math.sqrt(this.m[0] * this.m[0] + this.m[1] * this.m[1]);
          return new E(Math.atan(this.m[0] * this.m[4] + this.m[1] * this.m[5]) / (e * e), 0);
        }
        return 0 != this.m[4] || 0 != this.m[5] ? (e = Math.sqrt(this.m[4] * this.m[4] + this.m[5] * this.m[5]), new E(0, Math.atan(this.m[0] * this.m[4] + this.m[1] * this.m[5]) / (e * e))) : new E(0, 0);
      }
      invert() {
        let e = [];
        var n = this.m[10] * this.m[15] - this.m[14] * this.m[11], r = this.m[9] * this.m[15] - this.m[13] * this.m[11], o = this.m[9] * this.m[14] - this.m[13] * this.m[10];
        let i = this.m[8] * this.m[15] - this.m[12] * this.m[11], a = this.m[8] * this.m[14] - this.m[12] * this.m[10], l = this.m[8] * this.m[13] - this.m[12] * this.m[9], u = this.m[6] * this.m[15] - this.m[14] * this.m[7], m = this.m[5] * this.m[15] - this.m[13] * this.m[7], d = this.m[5] * this.m[14] - this.m[13] * this.m[6], C = this.m[4] * this.m[15] - this.m[12] * this.m[7], p = this.m[4] * this.m[14] - this.m[12] * this.m[6], b = this.m[5] * this.m[15] - this.m[13] * this.m[7], f = this.m[4] * 
        this.m[13] - this.m[12] * this.m[5], O = this.m[6] * this.m[11] - this.m[10] * this.m[7], g = this.m[5] * this.m[11] - this.m[9] * this.m[7], y = this.m[5] * this.m[10] - this.m[9] * this.m[6], V = this.m[4] * this.m[11] - this.m[8] * this.m[7], A = this.m[4] * this.m[10] - this.m[8] * this.m[6], D = this.m[4] * this.m[9] - this.m[8] * this.m[5];
        e[0] = this.m[5] * n - this.m[6] * r + this.m[7] * o;
        e[4] = -(this.m[4] * n - this.m[6] * i + this.m[7] * a);
        e[8] = this.m[4] * r - this.m[5] * i + this.m[7] * l;
        e[12] = -(this.m[4] * o - this.m[5] * a + this.m[6] * l);
        e[1] = -(this.m[1] * n - this.m[2] * r + this.m[3] * o);
        e[5] = this.m[0] * n - this.m[2] * i + this.m[3] * a;
        e[9] = -(this.m[0] * r - this.m[1] * i + this.m[3] * l);
        e[13] = this.m[0] * o - this.m[1] * a + this.m[2] * l;
        e[2] = this.m[1] * u - this.m[2] * m + this.m[3] * d;
        e[6] = -(this.m[0] * u - this.m[2] * C + this.m[3] * p);
        e[10] = this.m[0] * b - this.m[1] * C + this.m[3] * f;
        e[14] = -(this.m[0] * d - this.m[1] * p + this.m[2] * f);
        e[3] = -(this.m[1] * O - this.m[2] * g + this.m[3] * y);
        e[7] = this.m[0] * O - this.m[2] * V + this.m[3] * A;
        e[11] = -(this.m[0] * g - this.m[1] * V + this.m[3] * D);
        e[15] = this.m[0] * y - this.m[1] * A + this.m[2] * D;
        n = this.m[0] * e[0] + this.m[1] * e[4] + this.m[2] * e[8] + this.m[3] * e[12];
        for (r = 0; 4 > r; r++) {
          for (o = 0; 4 > o; o++) {
            e[4 * r + o] *= 1 / n;
          }
        }
        return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var5(e);
      }
      clone() {
        return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var5([...this.m]);
      }
      toString() {
        return this.m.toString();
      }
    };
    node_modules$kaplay$dist$kaplay_cjs$classdecl$var5.$jscomp$static$block$510831985$19();
    return node_modules$kaplay$dist$kaplay_cjs$classdecl$var5;
  })();
  s(Vn, "wave");
  var Xt = class {
    static $jscomp$static$block$510831985$20() {
      s(this, "RNG");
    }
    constructor(e) {
      this.seed = e;
    }
    gen() {
      return this.seed = (1103515245 * this.seed + 12345) % 2147483648, this.seed / 2147483648;
    }
    genNumber(e, n) {
      return e + this.gen() * (n - e);
    }
    genVec2(e, n) {
      return new E(this.genNumber(e.x, n.x), this.genNumber(e.y, n.y));
    }
    genColor(e, n) {
      return new K(this.genNumber(e.r, n.r), this.genNumber(e.g, n.g), this.genNumber(e.b, n.b));
    }
    genAny(...e) {
      if (0 === e.length) {
        return this.gen();
      }
      if (1 === e.length) {
        if ("number" == typeof e[0]) {
          return this.genNumber(0, e[0]);
        }
        if (e[0] instanceof E) {
          return this.genVec2(v(0, 0), e[0]);
        }
        if (e[0] instanceof K) {
          return this.genColor(I(0, 0, 0), e[0]);
        }
      } else if (2 === e.length) {
        if ("number" == typeof e[0] && "number" == typeof e[1]) {
          return this.genNumber(e[0], e[1]);
        }
        if (e[0] instanceof E && e[1] instanceof E) {
          return this.genVec2(e[0], e[1]);
        }
        if (e[0] instanceof K && e[1] instanceof K) {
          return this.genColor(e[0], e[1]);
        }
      }
      throw Error("More than 2 arguments not supported");
    }
  }, wr = new Xt(Date.now());
  Xt.$jscomp$static$block$510831985$20();
  s(Po, "randSeed");
  s(ge, "rand");
  s(Or, "randi");
  s(Go, "chance");
  s(Er, "shuffle");
  s(Mo, "chooseMultiple");
  s(Ro, "choose");
  s(Tr, "testRectRect");
  s(lu, "testLineLineT");
  s(Pn, "testLineLine");
  s(Gn, "testRectLine");
  s(Bt, "testRectPoint");
  s(Do, "testRectCircle");
  s(Bo, "testRectPolygon");
  s(Mn, "testLinePoint");
  s(Ft, "testLineCircle");
  s(Ar, "testLinePolygon");
  s(Rn, "testCirclePoint");
  s(mu, "testCircleCircle");
  s(Qt, "testCirclePolygon");
  s(Fo, "testPolygonPolygon");
  s(et, "testPolygonPoint");
  s(Sr, "testEllipsePoint");
  s(An, "testEllipseCircle");
  s(Lo, "testEllipseLine");
  s(pu, "testEllipseEllipse");
  s(jo, "testEllipseRect");
  s(Vr, "testEllipsePolygon");
  s(du, "testPointPoint");
  s(fu, "testPointShape");
  s(hu, "testLineShape");
  s(gu, "testCircleShape");
  s(bu, "testRectShape");
  s(yu, "testPolygonShape");
  s(xu, "testEllipseShape");
  s(Ko, "raycastLine");
  s(vu, "raycastRect");
  s(Io, "raycastCircle");
  s(Cu, "raycastPolygon");
  s(wu, "raycastEllipse");
  s(ko, "raycastGrid");
  const node_modules$kaplay$dist$kaplay_cjs$classdecl$var6 = class {
    static $jscomp$static$block$510831985$21() {
      s(this, "Point");
    }
    constructor(e) {
      this.pt = e.clone();
    }
    transform(e) {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var6(e.multVec2(this.pt));
    }
    bbox() {
      return new $(this.pt, 0, 0);
    }
    area() {
      return 0;
    }
    clone() {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var6(this.pt);
    }
    collides(e) {
      return fu(this, e);
    }
    contains(e) {
      return this.pt.eq(e);
    }
    raycast(e, n) {
      return null;
    }
    random() {
      return this.pt.clone();
    }
  };
  node_modules$kaplay$dist$kaplay_cjs$classdecl$var6.$jscomp$static$block$510831985$21();
  var Sn = node_modules$kaplay$dist$kaplay_cjs$classdecl$var6, Te = (() => {
    const node_modules$kaplay$dist$kaplay_cjs$classdecl$var7 = class {
      static $jscomp$static$block$510831985$22() {
        s(this, "Line");
      }
      constructor(e, n) {
        this.p1 = e.clone();
        this.p2 = n.clone();
      }
      transform(e) {
        return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var7(e.multVec2(this.p1), e.multVec2(this.p2));
      }
      bbox() {
        return $.fromPoints(this.p1, this.p2);
      }
      area() {
        return this.p1.dist(this.p2);
      }
      clone() {
        return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var7(this.p1, this.p2);
      }
      collides(e) {
        return hu(this, e);
      }
      contains(e) {
        return this.collides(e);
      }
      raycast(e, n) {
        return Ko(e, n, this);
      }
      random() {
        return this.p1.add(this.p2.sub(this.p1).scale(ge(1)));
      }
    };
    node_modules$kaplay$dist$kaplay_cjs$classdecl$var7.$jscomp$static$block$510831985$22();
    return node_modules$kaplay$dist$kaplay_cjs$classdecl$var7;
  })(), $ = (() => {
    const node_modules$kaplay$dist$kaplay_cjs$classdecl$var8 = class {
      static $jscomp$static$block$510831985$23() {
        s(this, "Rect");
      }
      constructor(e, n, r) {
        this.pos = e.clone();
        this.width = n;
        this.height = r;
      }
      static fromPoints(e, n) {
        return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var8(e.clone(), n.x - e.x, n.y - e.y);
      }
      center() {
        return new E(this.pos.x + this.width / 2, this.pos.y + this.height / 2);
      }
      points() {
        return [this.pos, this.pos.add(this.width, 0), this.pos.add(this.width, this.height), this.pos.add(0, this.height)];
      }
      transform(e) {
        return new ye(this.points().map(n => e.multVec2(n)));
      }
      bbox() {
        return this.clone();
      }
      area() {
        return this.width * this.height;
      }
      clone() {
        return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var8(this.pos.clone(), this.width, this.height);
      }
      distToPoint(e) {
        return Math.sqrt(this.sdistToPoint(e));
      }
      sdistToPoint(e) {
        let n = this.pos, r = this.pos.add(this.width, this.height), o = Math.max(n.x - e.x, 0, e.x - r.x);
        e = Math.max(n.y - e.y, 0, e.y - r.y);
        return o * o + e * e;
      }
      collides(e) {
        return bu(this, e);
      }
      contains(e) {
        return this.collides(e);
      }
      raycast(e, n) {
        return vu(e, n, this);
      }
      random() {
        return this.pos.add(ge(this.width), ge(this.height));
      }
    };
    node_modules$kaplay$dist$kaplay_cjs$classdecl$var8.$jscomp$static$block$510831985$23();
    return node_modules$kaplay$dist$kaplay_cjs$classdecl$var8;
  })(), we = (() => {
    const node_modules$kaplay$dist$kaplay_cjs$classdecl$var9 = class {
      static $jscomp$static$block$510831985$24() {
        s(this, "Circle");
      }
      constructor(e, n) {
        this.center = e.clone();
        this.radius = n;
      }
      transform(e) {
        return (new ke(this.center, this.radius, this.radius)).transform(e);
      }
      bbox() {
        return $.fromPoints(this.center.sub(v(this.radius)), this.center.add(v(this.radius)));
      }
      area() {
        return this.radius * this.radius * Math.PI;
      }
      clone() {
        return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var9(this.center, this.radius);
      }
      collides(e) {
        return gu(this, e);
      }
      contains(e) {
        return this.collides(e);
      }
      raycast(e, n) {
        return Io(e, n, this);
      }
      random() {
        return this.center.add(E.fromAngle(ge(360)).scale(ge(this.radius)));
      }
    };
    node_modules$kaplay$dist$kaplay_cjs$classdecl$var9.$jscomp$static$block$510831985$24();
    return node_modules$kaplay$dist$kaplay_cjs$classdecl$var9;
  })(), ke = (() => {
    const node_modules$kaplay$dist$kaplay_cjs$classdecl$var10 = class {
      static $jscomp$static$block$510831985$25() {
        s(this, "Ellipse");
      }
      constructor(e, n, r, o = 0) {
        this.center = e.clone();
        this.radiusX = n;
        this.radiusY = r;
        this.angle = o;
      }
      static fromMat2(e) {
        e = e.inverse;
        e = e.transpose.mul(e);
        let [o, i] = e.eigenvalues, [a, l] = e.eigenvectors(o, i), [u, m] = [1 / Math.sqrt(o), 1 / Math.sqrt(i)];
        return u > m ? new node_modules$kaplay$dist$kaplay_cjs$classdecl$var10(v(), u, m, lt(Math.atan2(-a[1], a[0]))) : new node_modules$kaplay$dist$kaplay_cjs$classdecl$var10(v(), m, u, lt(Math.atan2(-l[1], l[0])));
      }
      toMat2() {
        var e = ue(this.angle);
        let n = Math.cos(e);
        e = Math.sin(e);
        return new Dt(n * this.radiusX, -e * this.radiusY, e * this.radiusX, n * this.radiusY);
      }
      transform(e) {
        if (0 == this.angle && 0 == e.getRotation()) {
          return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var10(e.multVec2(this.center), e.m[0] * this.radiusX, e.m[5] * this.radiusY);
        }
        var n = this.toMat2();
        let r = e.getRotation(), o = e.getScale();
        n = bt.fromMat2(n).scale(o.x, o.y).rotate(r).toMat2();
        n = node_modules$kaplay$dist$kaplay_cjs$classdecl$var10.fromMat2(n);
        return n.center = e.multVec2(this.center), n;
      }
      bbox() {
        if (0 == this.angle) {
          return $.fromPoints(this.center.sub(v(this.radiusX, this.radiusY)), this.center.add(v(this.radiusX, this.radiusY)));
        }
        var e = ue(this.angle), n = Math.cos(e), r = Math.sin(e), o = this.radiusX * n;
        e = this.radiusX * r;
        r *= this.radiusY;
        n *= this.radiusY;
        o = Math.sqrt(o * o + r * r);
        e = Math.sqrt(e * e + n * n);
        return $.fromPoints(this.center.sub(v(o, e)), this.center.add(v(o, e)));
      }
      area() {
        return this.radiusX * this.radiusY * Math.PI;
      }
      clone() {
        return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var10(this.center, this.radiusX, this.radiusY, this.angle);
      }
      collides(e) {
        return xu(this, e);
      }
      contains(e) {
        e = e.sub(this.center);
        var n = ue(this.angle);
        let r = Math.cos(n), o = Math.sin(n);
        n = e.x * r + e.y * o;
        e = -e.x * o + e.y * r;
        return 1 > n * n / (this.radiusX * this.radiusX) + e * e / (this.radiusY * this.radiusY);
      }
      raycast(e, n) {
        return wu(e, n, this);
      }
      random() {
        return this.center;
      }
    };
    node_modules$kaplay$dist$kaplay_cjs$classdecl$var10.$jscomp$static$block$510831985$25();
    return node_modules$kaplay$dist$kaplay_cjs$classdecl$var10;
  })();
  s(Ou, "segmentLineIntersection");
  const node_modules$kaplay$dist$kaplay_cjs$classdecl$var11 = class {
    static $jscomp$static$block$510831985$26() {
      s(this, "Polygon");
    }
    constructor(e) {
      if (3 > e.length) {
        throw Error("Polygons should have at least 3 vertices");
      }
      this.pts = e;
    }
    transform(e) {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var11(this.pts.map(n => e.multVec2(n)));
    }
    bbox() {
      let e = v(Number.MAX_VALUE), n = v(-Number.MAX_VALUE);
      for (let r of this.pts) {
        e.x = Math.min(e.x, r.x), n.x = Math.max(n.x, r.x), e.y = Math.min(e.y, r.y), n.y = Math.max(n.y, r.y);
      }
      return $.fromPoints(e, n);
    }
    area() {
      let e = 0, n = this.pts.length;
      for (let r = 0; r < n; r++) {
        let o = this.pts[r], i = this.pts[(r + 1) % n];
        e += o.x * i.y * .5;
        e -= i.x * o.y * .5;
      }
      return Math.abs(e);
    }
    clone() {
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var11(this.pts.map(e => e.clone()));
    }
    collides(e) {
      return yu(this, e);
    }
    contains(e) {
      return this.collides(e);
    }
    raycast(e, n) {
      return Cu(e, n, this);
    }
    random() {
      return v();
    }
    cut(e, n) {
      new Te(e, n);
      let o = [], i = [], a = n.sub(e), l = this.pts[this.pts.length - 1], u = l.sub(e), m = 0 < a.cross(u);
      return this.pts.forEach(d => {
        u = d.sub(e);
        let C = 0 < a.cross(u);
        if (m != C) {
          let p = Ou(l, d, e, n);
          o.push(p);
          i.push(p);
          m = C;
        }
        (C ? o : i).push(d);
        l = d;
      }), [o.length ? new node_modules$kaplay$dist$kaplay_cjs$classdecl$var11(o) : null, i.length ? new node_modules$kaplay$dist$kaplay_cjs$classdecl$var11(i) : null];
    }
  };
  node_modules$kaplay$dist$kaplay_cjs$classdecl$var11.$jscomp$static$block$510831985$26();
  var ye = node_modules$kaplay$dist$kaplay_cjs$classdecl$var11;
  s(_o, "evaluateQuadratic");
  s(No, "evaluateQuadraticFirstDerivative");
  s(Uo, "evaluateQuadraticSecondDerivative");
  s(Jt, "evaluateBezier");
  s(Ho, "evaluateBezierFirstDerivative");
  s(qo, "evaluateBezierSecondDerivative");
  s(zo, "evaluateCatmullRom");
  s(Yo, "evaluateCatmullRomFirstDerivative");
  s(Wo, "normalizedCurve");
  s(Pr, "curveLengthApproximation");
  s(Lt, "hermite");
  s(Gr, "cardinal");
  s(jt, "catmullRom");
  s($o, "bezier");
  s(Xo, "kochanekBartels");
  s(Qo, "hermiteFirstDerivative");
  s(Wt, "inZeroOneDomain");
  s(vr, "approximately");
  s($t, "cubeRoot");
  s(Eu, "getCubicRoots");
  s(Tu, "cubicBezierYforX");
  s(Jo, "easingLinear");
  s(Zo, "easingCubicBezier");
  s(es, "easingSteps");
  s(ts, "sat");
  s(ns, "isOrientedCcw");
  s(Au, "isOrientedCcwPolygon");
  s(Cr, "onSameSide");
  s(Su, "pointInTriangle");
  s(Vu, "someInTriangle");
  s(Pu, "isEar");
  s(Dn, "triangulate");
  s(rs, "isConvex");
  var en = [{name:"a_pos", size:2}, {name:"a_uv", size:2}, {name:"a_color", size:4}], is = 8192 * en.reduce((t, e) => t + e.size, 0), ls = new Set(["id", "require"]), ms = new Set("add fixedUpdate update draw destroy inspect drawInspect".split(" ")), Fn = Symbol.for("kaplay.cancel"), rn = class extends Map {
    constructor() {
      super(...arguments);
      this.lastID = 0;
    }
    static $jscomp$static$block$510831985$27() {
      s(this, "Registry");
    }
    push(e) {
      let n = this.lastID;
      return this.set(n, e), this.lastID++, n;
    }
    pushd(e) {
      let n = this.push(e);
      return () => this.delete(n);
    }
  }, _e = (() => {
    const node_modules$kaplay$dist$kaplay_cjs$classdecl$var12 = class {
      static $jscomp$static$block$510831985$28() {
        s(this, "KEventController");
      }
      constructor(e) {
        this.paused = !1;
        this.cancel = e;
      }
      static join(e) {
        let n = new node_modules$kaplay$dist$kaplay_cjs$classdecl$var12(() => e.forEach(r => r.cancel()));
        return Object.defineProperty(n, "paused", {get:s(() => e[0].paused, "get"), set:s(r => e.forEach(o => o.paused = r), "set")}), n.paused = !1, n;
      }
      static replace(e, n) {
        return e.cancel = () => n.cancel(), n.paused = e.paused, Object.defineProperty(e, "paused", {get:s(() => n.paused, "get"), set:s(r => n.paused = r, "set")}), e;
      }
    };
    node_modules$kaplay$dist$kaplay_cjs$classdecl$var12.$jscomp$static$block$510831985$28();
    return node_modules$kaplay$dist$kaplay_cjs$classdecl$var12;
  })(), oe = class {
    constructor() {
      this.cancellers = new WeakMap();
      this.handlers = new rn();
    }
    static $jscomp$static$block$510831985$29() {
      s(this, "KEvent");
    }
    add(e) {
      function n(...i) {
        if (!o.paused) {
          return e(...i);
        }
      }
      s(n, "handler");
      let r = this.handlers.pushd(n), o = new _e(r);
      return this.cancellers.set(n, r), o;
    }
    addOnce(e) {
      let n = this.add((...r) => {
        n.cancel();
        e(...r);
      });
      return n;
    }
    next() {
      return new Promise(e => this.addOnce(e));
    }
    trigger(...e) {
      this.handlers.forEach(n => {
        let o;
        n(...e) === Fn && (o = this.cancellers.get(n)) && o();
      });
    }
    numListeners() {
      return this.handlers.size;
    }
    clear() {
      this.handlers.clear();
    }
  }, Ye = class {
    constructor() {
      this.handlers = {};
      this.registers = {};
    }
    static $jscomp$static$block$510831985$30() {
      s(this, "KEventHandler");
    }
    on(e, n) {
      return this.handlers[e] || (this.handlers[e] = new oe()), this.handlers[e].add(n);
    }
    onOnce(e, n) {
      let r = this.on(e, (...o) => {
        r.cancel();
        n(...o);
      });
      return r;
    }
    next(e) {
      return new Promise(n => {
        this.onOnce(e, (...r) => n(r[0]));
      });
    }
    trigger(e, ...n) {
      this.handlers[e] && this.handlers[e].trigger(...n);
    }
    remove(e) {
      delete this.handlers[e];
    }
    clear() {
      this.handlers = {};
    }
    numListeners(e) {
      return this.handlers[e]?.numListeners() ?? 0;
    }
  };
  Ye.$jscomp$static$block$510831985$30();
  oe.$jscomp$static$block$510831985$29();
  rn.$jscomp$static$block$510831985$27();
  var hs = s(t => t[0] instanceof K, "arrayIsColor"), gs = s(t => t[0] instanceof E, "arrayIsVec2"), bs = s(t => "number" == typeof t[0], "arrayIsNumber"), Kt = class {
    static $jscomp$static$block$510831985$31() {
      s(this, "BinaryHeap");
    }
    constructor(e = (n, r) => n < r) {
      this._compareFn = e;
      this._items = [];
    }
    insert(e) {
      this._items.push(e);
      this.moveUp(this._items.length - 1);
    }
    remove() {
      if (0 === this._items.length) {
        return null;
      }
      let e = this._items[0], n = this._items.pop();
      return 0 !== this._items.length && (this._items[0] = n, this.moveDown(0)), e;
    }
    clear() {
      this._items.splice(0, this._items.length);
    }
    moveUp(e) {
      for (; 0 < e;) {
        let n = Math.floor((e - 1) / 2);
        if (!this._compareFn(this._items[e], this._items[n]) && this._items[e] >= this._items[n]) {
          break;
        }
        this.swap(e, n);
        e = n;
      }
    }
    moveDown(e) {
      for (; e < Math.floor(this._items.length / 2);) {
        let n = 2 * e + 1;
        if (n < this._items.length - 1 && !this._compareFn(this._items[n], this._items[n + 1]) && ++n, this._compareFn(this._items[e], this._items[n])) {
          break;
        }
        this.swap(e, n);
        e = n;
      }
    }
    swap(e, n) {
      [this._items[e], this._items[n]] = [this._items[n], this._items[e]];
    }
    get length() {
      return this._items.length;
    }
  };
  Kt.$jscomp$static$block$510831985$31();
  s(Mu, "base64ToArrayBuffer");
  s(ys, "dataURLToArrayBuffer");
  s(Ln, "download");
  s(Mr, "downloadText");
  s(xs, "downloadJSON");
  s(Rr, "downloadBlob");
  var jn = s(t => t.match(/^data:\w+\/\w+;base64,.+/), "isDataURL"), vs = s(t => t.split(".").slice(0, -1).join("."), "getFileName");
  s(Kn, "deepEq");
  var Cs = new Set(), ws = s(t => t instanceof Error ? t.message : String(t), "getErrorMessage");
  s(Ru, "warn");
  s(tt, "deprecateMsg");
  s(on, "toFixed");
  s(re, "overload2");
  var Du = Object.freeze([776, 2359, 2367, 2984, 3007, 3021, 3633, 3635, 3648, 3657, 4352, 4449, 4520]);
  s(Es, "runes");
  s(Bu, "nextUnits");
  s(Fu, "isFirstOfSurrogatePair");
  s(Os, "isRegionalIndicator");
  s(Lu, "isSubdivisionFlag");
  s(ju, "isFitzpatrickModifier");
  s(Ku, "isVariationSelector");
  s(Iu, "isDiacriticalMark");
  s(ku, "isSupplementarySpecialpurposePlane");
  s(_u, "isGrapheme");
  s(Nu, "isZeroWidthJoiner");
  s(Dr, "codePointFromSurrogatePair");
  s(xt, "betweenInclusive");
  var Be = s((t, e) => Array.isArray(t) ? t?.includes(e) : t === e, "isEqOrIncludes"), We = s((t, e) => Array.isArray(e) ? e.some(n => t.has(n)) : t.has(e), "setHasOrIncludes"), sn = s((t, e, n) => {
    t.has(e) ? t.get(e)?.push(n) : t.set(e, [n]);
  }, "mapAddOrPush"), Ts = (() => {
    let t = 0;
    return () => t++;
  })(), Ss = s(() => pt.lastInputDevice, "getLastInputDeviceType"), Vs = s(() => {
    let t = pt.buttons;
    for (let e in t) {
      let n = t[e].keyboard && [t[e].keyboard].flat(), r = t[e].keyboardCode && [t[e].keyboardCode].flat(), o = t[e].gamepad && [t[e].gamepad].flat(), i = t[e].mouse && [t[e].mouse].flat();
      n && n.forEach(a => {
        sn(pt.buttonsByKey, a, e);
      });
      r && r.forEach(a => {
        sn(pt.buttonsByKeyCode, a, e);
      });
      o && o.forEach(a => {
        sn(pt.buttonsByGamepad, a, e);
      });
      i && i.forEach(a => {
        sn(pt.buttonsByMouse, a, e);
      });
    }
  }, "parseButtonBindings"), vt = class {
    constructor() {
      this.pressed = new Set([]);
      this.pressedRepeat = new Set([]);
      this.released = new Set([]);
      this.down = new Set([]);
    }
    static $jscomp$static$block$510831985$32() {
      s(this, "ButtonState");
    }
    update() {
      this.pressed.clear();
      this.released.clear();
      this.pressedRepeat.clear();
    }
    press(e) {
      this.pressed.add(e);
      this.pressedRepeat.add(e);
      this.down.add(e);
    }
    pressRepeat(e) {
      this.pressedRepeat.add(e);
    }
    release(e) {
      this.down.delete(e);
      this.pressed.delete(e);
      this.released.add(e);
    }
  }, Br = class {
    constructor() {
      this.buttonState = new vt();
      this.stickState = new Map();
    }
    static $jscomp$static$block$510831985$33() {
      s(this, "GamepadState");
    }
  }, Fr = class {
    constructor() {
      this.dts = [];
      this.fps = this.timer = 0;
    }
    static $jscomp$static$block$510831985$34() {
      s(this, "FPSCounter");
    }
    tick(e) {
      this.dts.push(e);
      this.timer += e;
      1 <= this.timer && (this.timer = 0, this.fps = Math.round(1 / (this.dts.reduce((n, r) => n + r) / this.dts.length)), this.dts = []);
    }
  }, pt, Ps = {"Joy-Con L+R (STANDARD GAMEPAD Vendor: 057e Product: 200e)":{buttons:{0:"south", 1:"east", 2:"west", 3:"north", 4:"lshoulder", 5:"rshoulder", 6:"ltrigger", 7:"rtrigger", 8:"select", 9:"start", 10:"lstick", 11:"rstick", 12:"dpad-up", 13:"dpad-down", 14:"dpad-left", 15:"dpad-right", 16:"home", 17:"capture"}, sticks:{left:{x:0, y:1}, right:{x:2, y:3}}}, "Joy-Con (L) (STANDARD GAMEPAD Vendor: 057e Product: 2006)":{buttons:{0:"south", 1:"east", 2:"west", 3:"north", 4:"lshoulder", 5:"rshoulder", 
  9:"select", 10:"lstick", 16:"start"}, sticks:{left:{x:0, y:1}}}, "Joy-Con (R) (STANDARD GAMEPAD Vendor: 057e Product: 2007)":{buttons:{0:"south", 1:"east", 2:"west", 3:"north", 4:"lshoulder", 5:"rshoulder", 9:"start", 10:"lstick", 16:"select"}, sticks:{left:{x:0, y:1}}}, "Pro Controller (STANDARD GAMEPAD Vendor: 057e Product: 2009)":{buttons:{0:"south", 1:"east", 2:"west", 3:"north", 4:"lshoulder", 5:"rshoulder", 6:"ltrigger", 7:"rtrigger", 8:"select", 9:"start", 10:"lstick", 11:"rstick", 12:"dpad-up", 
  13:"dpad-down", 14:"dpad-left", 15:"dpad-right", 16:"home", 17:"capture"}, sticks:{left:{x:0, y:1}, right:{x:2, y:3}}}, default:{buttons:{0:"south", 1:"east", 2:"west", 3:"north", 4:"lshoulder", 5:"rshoulder", 6:"ltrigger", 7:"rtrigger", 8:"select", 9:"start", 10:"lstick", 11:"rstick", 12:"dpad-up", 13:"dpad-down", 14:"dpad-left", 15:"dpad-right", 16:"home"}, sticks:{left:{x:0, y:1}, right:{x:2, y:3}}}}, Hu = s(t => ({canvas:t.canvas, buttons:t.buttons ?? {}, buttonsByKey:new Map(), buttonsByMouse:new Map(), 
  buttonsByGamepad:new Map(), buttonsByKeyCode:new Map(), loopID:null, stopped:!1, dt:0, fixedDt:.02, restDt:0, time:0, realTime:0, fpsCounter:new Fr(), timeScale:1, skipTime:!1, isHidden:!1, numFrames:0, mousePos:new E(0), mouseDeltaPos:new E(0), keyState:new vt(), mouseState:new vt(), mergedGamepadState:new Br(), gamepadStates:new Map(), lastInputDevice:null, buttonState:new vt(), gamepads:[], charInputted:[], isMouseMoved:!1, lastWidth:t.canvas.offsetWidth, lastHeight:t.canvas.offsetHeight, events:new Ye()}), 
  "initAppState"), Gs = s(t => {
    function n() {
      return e.dt * e.timeScale;
    }
    function r() {
      return e.fixedDt * e.timeScale;
    }
    function o() {
      return e.restDt * e.timeScale;
    }
    function i() {
      return e.isHidden;
    }
    function a() {
      return e.time;
    }
    function l() {
      return e.fpsCounter.fps;
    }
    function u() {
      return e.numFrames;
    }
    function m() {
      return e.canvas.toDataURL();
    }
    function d(h) {
      e.canvas.style.cursor = h;
    }
    function C() {
      return e.canvas.style.cursor;
    }
    function p(h) {
      if (h) {
        try {
          let T = e.canvas.requestPointerLock();
          T.catch && T.catch(P => console.error(P));
        } catch (T) {
          console.error(T);
        }
      } else {
        document.exitPointerLock();
      }
    }
    function b() {
      return !!document.pointerLockElement;
    }
    function f(h) {
      h.requestFullscreen ? h.requestFullscreen() : h.webkitRequestFullscreen && h.webkitRequestFullscreen();
    }
    function O() {
      document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullScreen && document.webkitExitFullScreen();
    }
    function g(h = !0) {
      h ? f(e.canvas) : O();
    }
    function y() {
      return document.fullscreenElement === e.canvas || document.webkitFullscreenElement === e.canvas;
    }
    function V() {
      e.stopped = !0;
      let h = Object.entries(Re), T = Object.entries(yr), P = Object.entries(En);
      for (let [B, ne] of h) {
        e.canvas.removeEventListener(B, ne);
      }
      for (let [B, ne] of T) {
        document.removeEventListener(B, ne);
      }
      for (let [B, ne] of P) {
        window.removeEventListener(B, ne);
      }
      Eo.disconnect();
    }
    function A(h, T) {
      null !== e.loopID && cancelAnimationFrame(e.loopID);
      let P = 0, B = 0, ne = s(Ae => {
        if (!e.stopped) {
          if ("visible" === document.visibilityState) {
            Ae /= 1E3;
            var Ze = Math.min(Ae - e.realTime, .25), Rt = t.maxFPS ? 1 / t.maxFPS : 0;
            if (e.realTime = Ae, B += Ze, B > Rt) {
              if (!e.skipTime) {
                P += B;
                e.dt = e.fixedDt;
                for (e.restDt = 0; P > e.fixedDt;) {
                  P -= e.fixedDt, P < e.fixedDt && (e.restDt = P), h();
                }
                e.restDt = P;
                e.dt = B;
                e.time += n();
                e.fpsCounter.tick(e.dt);
              }
              B = 0;
              e.skipTime = !1;
              e.numFrames++;
              T(On, Ja);
            }
          }
          e.loopID = requestAnimationFrame(ne);
        }
      }, "frame");
      ne(0);
    }
    function D() {
      return "ontouchstart" in window || 0 < navigator.maxTouchPoints;
    }
    function G() {
      return e.mousePos.clone();
    }
    function x() {
      return e.mouseDeltaPos.clone();
    }
    function w(h = "left") {
      return e.mouseState.pressed.has(h);
    }
    function S(h = "left") {
      return e.mouseState.down.has(h);
    }
    function M(h = "left") {
      return e.mouseState.released.has(h);
    }
    function R() {
      return e.isMouseMoved;
    }
    function F(h) {
      return void 0 === h ? 0 < e.keyState.pressed.size : We(e.keyState.pressed, h);
    }
    function j(h) {
      return void 0 === h ? 0 < e.keyState.pressedRepeat.size : We(e.keyState.pressedRepeat, h);
    }
    function H(h) {
      return void 0 === h ? 0 < e.keyState.down.size : We(e.keyState.down, h);
    }
    function q(h) {
      return void 0 === h ? 0 < e.keyState.released.size : We(e.keyState.released, h);
    }
    function W(h) {
      return void 0 === h ? 0 < e.mergedGamepadState.buttonState.pressed.size : We(e.mergedGamepadState.buttonState.pressed, h);
    }
    function N(h) {
      return void 0 === h ? 0 < e.mergedGamepadState.buttonState.down.size : We(e.mergedGamepadState.buttonState.down, h);
    }
    function k(h) {
      return void 0 === h ? 0 < e.mergedGamepadState.buttonState.released.size : We(e.mergedGamepadState.buttonState.released, h);
    }
    function Z(h) {
      return void 0 === h ? 0 < e.buttonState.pressed.size : We(e.buttonState.pressed, h);
    }
    function X(h) {
      return void 0 === h ? 0 < e.buttonState.down.size : We(e.buttonState.down, h);
    }
    function ee(h) {
      return void 0 === h ? 0 < e.buttonState.released.size : We(e.buttonState.released, h);
    }
    function Ee(h) {
      return e.buttons?.[h];
    }
    function _(h, T) {
      e.buttons[h] = {...e.buttons[h], ...T};
    }
    function gt(h) {
      e.buttonState.press(h);
      e.events.trigger("buttonPress", h);
    }
    function Gt(h) {
      e.buttonState.release(h);
      e.events.trigger("buttonRelease", h);
    }
    function Ht(h) {
      return e.events.on("resize", h);
    }
    function L(h) {
      return e.events.on("mouseMove", () => h(G(), x()));
    }
    function U(h) {
      return e.events.on("charInput", h);
    }
    function Y(h) {
      return e.events.on("touchStart", h);
    }
    function se(h) {
      return e.events.on("touchMove", h);
    }
    function xe(h) {
      return e.events.on("touchEnd", h);
    }
    function J(h) {
      return e.events.on("scroll", h);
    }
    function Ce(h) {
      return e.events.on("hide", h);
    }
    function qt(h) {
      return e.events.on("show", h);
    }
    function gr(h, T) {
      return e.events.on("gamepadStick", (P, B, ne) => P === h && T(B, ne));
    }
    function br(h) {
      e.events.on("gamepadConnect", h);
    }
    function wn(h) {
      e.events.on("gamepadDisconnect", h);
    }
    function Qe(h) {
      return e.mergedGamepadState.stickState.get(h) || new E(0);
    }
    function ct() {
      return [...e.charInputted];
    }
    function zt() {
      return [...e.gamepads];
    }
    function On() {
      e.events.trigger("input");
      e.keyState.down.forEach(h => e.events.trigger("keyDown", h));
      e.mouseState.down.forEach(h => e.events.trigger("mouseDown", h));
      e.buttonState.down.forEach(h => {
        e.events.trigger("buttonDown", h);
      });
      eu();
    }
    function Ja() {
      e.keyState.update();
      e.mouseState.update();
      e.buttonState.update();
      e.mergedGamepadState.buttonState.update();
      e.mergedGamepadState.stickState.forEach((h, T) => {
        e.mergedGamepadState.stickState.set(T, new E(0));
      });
      e.charInputted = [];
      e.isMouseMoved = !1;
      e.mouseDeltaPos = new E(0);
      e.gamepadStates.forEach(h => {
        h.buttonState.update();
        h.stickState.forEach((T, P) => {
          h.stickState.set(P, new E(0));
        });
      });
    }
    function vo(h) {
      let T = {index:h.index, isPressed:s(P => e.gamepadStates.get(h.index)?.buttonState.pressed.has(P) || !1, "isPressed"), isDown:s(P => e.gamepadStates.get(h.index)?.buttonState.down.has(P) || !1, "isDown"), isReleased:s(P => e.gamepadStates.get(h.index)?.buttonState.released.has(P) || !1, "isReleased"), getStick:s(P => e.gamepadStates.get(h.index)?.stickState.get(P) || v(), "getStick")};
      return e.gamepads.push(T), e.gamepadStates.set(h.index, {buttonState:new vt(), stickState:new Map([["left", new E(0)], ["right", new E(0)]])}), T;
    }
    function Za(h) {
      e.gamepads = e.gamepads.filter(T => T.index !== h.index);
      e.gamepadStates.delete(h.index);
    }
    function eu() {
      for (var h$jscomp$0 of navigator.getGamepads()) {
        h$jscomp$0 && !e.gamepadStates.has(h$jscomp$0.index) && vo(h$jscomp$0);
      }
      for (let h of e.gamepads) {
        h$jscomp$0 = navigator.getGamepads()[h.index];
        if (!h$jscomp$0) {
          continue;
        }
        let B = (t.gamepads ?? {})[h$jscomp$0.id] || Ps[h$jscomp$0.id] || Ps.default, ne = e.gamepadStates.get(h.index);
        if (ne) {
          for (var Ae$jscomp$0 = 0; Ae$jscomp$0 < h$jscomp$0.buttons.length; Ae$jscomp$0++) {
            let ie = B.buttons[Ae$jscomp$0], Ze = h$jscomp$0.buttons[Ae$jscomp$0], Rt = e.buttonsByGamepad.has(ie);
            Ze.pressed ? ne.buttonState.down.has(ie) ? e.events.trigger("gamepadButtonDown", ie, h) : (e.lastInputDevice = "gamepad", Rt && e.buttonsByGamepad.get(ie)?.forEach(De => {
              e.buttonState.press(De);
              e.events.trigger("buttonPress", De);
            }), e.mergedGamepadState.buttonState.press(ie), ne.buttonState.press(ie), e.events.trigger("gamepadButtonPress", ie, h)) : ne.buttonState.down.has(ie) && (Rt && e.buttonsByGamepad.get(ie)?.forEach(De => {
              e.buttonState.release(De);
              e.events.trigger("buttonRelease", De);
            }), e.mergedGamepadState.buttonState.release(ie), ne.buttonState.release(ie), e.events.trigger("gamepadButtonRelease", ie, h));
          }
          for (let Ae in B.sticks) {
            if (Ae$jscomp$0 = B.sticks[Ae]) {
              Ae$jscomp$0 = new E(h$jscomp$0.axes[Ae$jscomp$0.x], h$jscomp$0.axes[Ae$jscomp$0.y]), ne.stickState.set(Ae, Ae$jscomp$0), e.mergedGamepadState.stickState.set(Ae, Ae$jscomp$0), e.events.trigger("gamepadStick", Ae, Ae$jscomp$0, h);
            }
          }
        }
      }
    }
    if (!t.canvas) {
      throw Error("Please provide a canvas");
    }
    let e = Hu(t);
    pt = e;
    Vs();
    s(n, "dt");
    s(r, "fixedDt");
    s(o, "restDt");
    s(i, "isHidden");
    s(a, "time");
    s(l, "fps");
    s(u, "numFrames");
    s(m, "screenshot");
    s(d, "setCursor");
    s(C, "getCursor");
    s(p, "setCursorLocked");
    s(b, "isCursorLocked");
    s(f, "enterFullscreen");
    s(O, "exitFullscreen");
    s(g, "setFullscreen");
    s(y, "isFullscreen");
    s(V, "quit");
    s(A, "run");
    s(D, "isTouchscreen");
    s(G, "mousePos");
    s(x, "mouseDeltaPos");
    s(w, "isMousePressed");
    s(S, "isMouseDown");
    s(M, "isMouseReleased");
    s(R, "isMouseMoved");
    s(F, "isKeyPressed");
    s(j, "isKeyPressedRepeat");
    s(H, "isKeyDown");
    s(q, "isKeyReleased");
    s(W, "isGamepadButtonPressed");
    s(N, "isGamepadButtonDown");
    s(k, "isGamepadButtonReleased");
    s(Z, "isButtonPressed");
    s(X, "isButtonDown");
    s(ee, "isButtonReleased");
    s(Ee, "getButton");
    s(_, "setButton");
    s(gt, "pressButton");
    s(Gt, "releaseButton");
    s(Ht, "onResize");
    let xn = re(h => e.events.on("keyDown", h), (h, T) => e.events.on("keyDown", P => Be(h, P) && T(P))), vn = re(h => e.events.on("keyPress", T => h(T)), (h, T) => e.events.on("keyPress", P => Be(h, P) && T(P))), pr = re(h => e.events.on("keyPressRepeat", h), (h, T) => e.events.on("keyPressRepeat", P => Be(h, P) && T(P))), dr = re(h => e.events.on("keyRelease", h), (h, T) => e.events.on("keyRelease", P => Be(h, P) && T(P))), Mt = re(h => e.events.on("mouseDown", T => h(T)), (h, T) => e.events.on("mouseDown", 
    P => Be(h, P) && T(P))), Xe = re(h => e.events.on("mousePress", T => h(T)), (h, T) => e.events.on("mousePress", P => Be(h, P) && T(P))), Cn = re(h => e.events.on("mouseRelease", T => h(T)), (h, T) => e.events.on("mouseRelease", P => P === h && T(P)));
    s(L, "onMouseMove");
    s(U, "onCharInput");
    s(Y, "onTouchStart");
    s(se, "onTouchMove");
    s(xe, "onTouchEnd");
    s(J, "onScroll");
    s(Ce, "onHide");
    s(qt, "onShow");
    let ut = re(h => e.events.on("gamepadButtonPress", (T, P) => h(T, P)), (h, T) => e.events.on("gamepadButtonPress", (P, B) => Be(h, P) && T(P, B))), fr = re(h => e.events.on("gamepadButtonDown", (T, P) => h(T, P)), (h, T) => e.events.on("gamepadButtonDown", (P, B) => Be(h, P) && T(P, B))), hr = re(h => e.events.on("gamepadButtonRelease", (T, P) => h(T, P)), (h, T) => e.events.on("gamepadButtonRelease", (P, B) => Be(h, P) && T(P, B)));
    s(gr, "onGamepadStick");
    s(br, "onGamepadConnect");
    s(wn, "onGamepadDisconnect");
    s(Qe, "getGamepadStick");
    s(ct, "charInputted");
    s(zt, "getGamepads");
    let Ie = re(h => e.events.on("buttonPress", T => h(T)), (h, T) => e.events.on("buttonPress", P => Be(h, P) && T(P))), Yt = re(h => e.events.on("buttonDown", T => h(T)), (h, T) => e.events.on("buttonDown", P => Be(h, P) && T(P))), Je = re(h => e.events.on("buttonRelease", T => h(T)), (h, T) => e.events.on("buttonRelease", P => Be(h, P) && T(P)));
    s(On, "processInput");
    s(Ja, "resetInput");
    s(vo, "registerGamepad");
    s(Za, "removeGamepad");
    s(eu, "processGamepad");
    let Re = {}, yr = {}, En = {}, Co = t.pixelDensity || 1;
    Re.mousemove = h => {
      let T = new E(h.offsetX, h.offsetY), P = new E(h.movementX, h.movementY);
      if (y()) {
        let B = e.canvas.width / Co, ne = e.canvas.height / Co;
        var Ae = window.innerWidth, ie = window.innerHeight;
        Ae / ie > B / ne ? (ie /= ne, T.x = Ve(h.offsetX - (Ae - B * ie) / 2, 0, B * ie, 0, B), T.y = Ve(h.offsetY, 0, ne * ie, 0, ne)) : (Ae /= B, ie = (ie - ne * Ae) / 2, T.x = Ve(h.offsetX, 0, B * Ae, 0, B), T.y = Ve(h.offsetY - ie, 0, ne * Ae, 0, ne));
      }
      e.events.onOnce("input", () => {
        e.isMouseMoved = !0;
        e.mousePos = T;
        e.mouseDeltaPos = P;
        e.events.trigger("mouseMove");
      });
    };
    let wo = ["left", "middle", "right", "back", "forward"];
    Re.mousedown = h => {
      e.events.onOnce("input", () => {
        let T = wo[h.button];
        T && (e.lastInputDevice = "mouse", e.buttonsByMouse.has(T) && e.buttonsByMouse.get(T)?.forEach(P => {
          e.buttonState.press(P);
          e.events.trigger("buttonPress", P);
        }), e.mouseState.press(T), e.events.trigger("mousePress", T));
      });
    };
    Re.mouseup = h => {
      e.events.onOnce("input", () => {
        let T = wo[h.button];
        T && (e.buttonsByMouse.has(T) && e.buttonsByMouse.get(T)?.forEach(P => {
          e.buttonState.release(P);
          e.events.trigger("buttonRelease", P);
        }), e.mouseState.release(T), e.events.trigger("mouseRelease", T));
      });
    };
    let tu = new Set(" ;ArrowLeft;ArrowRight;ArrowUp;ArrowDown;Tab".split(";")), Oo = {ArrowLeft:"left", ArrowRight:"right", ArrowUp:"up", ArrowDown:"down", " ":"space"};
    Re.keydown = h => {
      tu.has(h.key) && h.preventDefault();
      e.events.onOnce("input", () => {
        let T = Oo[h.key] || h.key.toLowerCase(), P = h.code;
        if (void 0 === T) {
          throw Error(`Unknown key: ${h.key}`);
        }
        1 === T.length ? (e.events.trigger("charInput", T), e.charInputted.push(T)) : "space" === T && (e.events.trigger("charInput", " "), e.charInputted.push(" "));
        h.repeat ? (e.keyState.pressRepeat(T), e.events.trigger("keyPressRepeat", T)) : (e.lastInputDevice = "keyboard", e.buttonsByKey.has(T) && e.buttonsByKey.get(T)?.forEach(B => {
          e.buttonState.press(B);
          e.events.trigger("buttonPress", B);
        }), e.buttonsByKeyCode.has(P) && e.buttonsByKeyCode.get(P)?.forEach(B => {
          e.buttonState.press(B);
          e.events.trigger("buttonPress", B);
        }), e.keyState.press(T), e.events.trigger("keyPressRepeat", T), e.events.trigger("keyPress", T));
      });
    };
    Re.keyup = h => {
      e.events.onOnce("input", () => {
        let T = Oo[h.key] || h.key.toLowerCase(), P = h.code;
        e.buttonsByKey.has(T) && e.buttonsByKey.get(T)?.forEach(B => {
          e.buttonState.release(B);
          e.events.trigger("buttonRelease", B);
        });
        e.buttonsByKeyCode.has(P) && e.buttonsByKeyCode.get(P)?.forEach(B => {
          e.buttonState.release(B);
          e.events.trigger("buttonRelease", B);
        });
        e.keyState.release(T);
        e.events.trigger("keyRelease", T);
      });
    };
    Re.touchstart = h => {
      h.preventDefault();
      e.events.onOnce("input", () => {
        let T = [...h.changedTouches], P = e.canvas.getBoundingClientRect();
        !1 !== t.touchToMouse && (e.mousePos = new E(T[0].clientX - P.x, T[0].clientY - P.y), e.lastInputDevice = "mouse", e.buttonsByMouse.has("left") && e.buttonsByMouse.get("left")?.forEach(B => {
          e.buttonState.press(B);
          e.events.trigger("buttonPress", B);
        }), e.mouseState.press("left"), e.events.trigger("mousePress", "left"));
        T.forEach(B => {
          e.events.trigger("touchStart", new E(B.clientX - P.x, B.clientY - P.y), B);
        });
      });
    };
    Re.touchmove = h => {
      h.preventDefault();
      e.events.onOnce("input", () => {
        let T = [...h.changedTouches], P = e.canvas.getBoundingClientRect();
        if (!1 !== t.touchToMouse) {
          let B = e.mousePos;
          e.mousePos = new E(T[0].clientX - P.x, T[0].clientY - P.y);
          e.mouseDeltaPos = e.mousePos.sub(B);
          e.events.trigger("mouseMove");
        }
        T.forEach(B => {
          e.events.trigger("touchMove", new E(B.clientX - P.x, B.clientY - P.y), B);
        });
      });
    };
    Re.touchend = h => {
      e.events.onOnce("input", () => {
        let T = [...h.changedTouches], P = e.canvas.getBoundingClientRect();
        !1 !== t.touchToMouse && (e.mousePos = new E(T[0].clientX - P.x, T[0].clientY - P.y), e.mouseDeltaPos = new E(0, 0), e.buttonsByMouse.has("left") && e.buttonsByMouse.get("left")?.forEach(B => {
          e.buttonState.release(B);
          e.events.trigger("buttonRelease", B);
        }), e.mouseState.release("left"), e.events.trigger("mouseRelease", "left"));
        T.forEach(B => {
          e.events.trigger("touchEnd", new E(B.clientX - P.x, B.clientY - P.y), B);
        });
      });
    };
    Re.touchcancel = h => {
      e.events.onOnce("input", () => {
        let T = [...h.changedTouches], P = e.canvas.getBoundingClientRect();
        !1 !== t.touchToMouse && (e.mousePos = new E(T[0].clientX - P.x, T[0].clientY - P.y), e.mouseState.release("left"), e.events.trigger("mouseRelease", "left"));
        T.forEach(B => {
          e.events.trigger("touchEnd", new E(B.clientX - P.x, B.clientY - P.y), B);
        });
      });
    };
    Re.wheel = h => {
      h.preventDefault();
      e.events.onOnce("input", () => {
        e.events.trigger("scroll", new E(h.deltaX, h.deltaY));
      });
    };
    Re.contextmenu = h => h.preventDefault();
    yr.visibilitychange = () => {
      "visible" === document.visibilityState ? (e.skipTime = !0, e.isHidden = !1, e.events.trigger("show")) : (e.isHidden = !0, e.events.trigger("hide"));
    };
    En.gamepadconnected = h => {
      let T = vo(h.gamepad);
      e.events.onOnce("input", () => {
        e.events.trigger("gamepadConnect", T);
      });
    };
    En.gamepaddisconnected = h => {
      let T = zt().filter(P => P.index === h.gamepad.index)[0];
      Za(h.gamepad);
      e.events.onOnce("input", () => {
        e.events.trigger("gamepadDisconnect", T);
      });
    };
    for (let [h, T] of Object.entries(Re)) {
      e.canvas.addEventListener(h, T);
    }
    for (let [h, T] of Object.entries(yr)) {
      document.addEventListener(h, T);
    }
    for (let [h, T] of Object.entries(En)) {
      window.addEventListener(h, T);
    }
    let Eo = new ResizeObserver(h => {
      for (let T of h) {
        if (T.target === e.canvas) {
          if (e.lastWidth === e.canvas.offsetWidth && e.lastHeight === e.canvas.offsetHeight) {
            break;
          }
          e.lastWidth = e.canvas.offsetWidth;
          e.lastHeight = e.canvas.offsetHeight;
          e.events.onOnce("input", () => {
            e.events.trigger("resize");
          });
        }
      }
    });
    return Eo.observe(e.canvas), {state:e, dt:n, fixedDt:r, restDt:o, time:a, run:A, canvas:e.canvas, fps:l, numFrames:u, quit:V, isHidden:i, setFullscreen:g, isFullscreen:y, setCursor:d, screenshot:m, getGamepads:zt, getCursor:C, setCursorLocked:p, isCursorLocked:b, isTouchscreen:D, mousePos:G, mouseDeltaPos:x, isKeyDown:H, isKeyPressed:F, isKeyPressedRepeat:j, isKeyReleased:q, isMouseDown:S, isMousePressed:w, isMouseReleased:M, isMouseMoved:R, isGamepadButtonPressed:W, isGamepadButtonDown:N, isGamepadButtonReleased:k, 
    getGamepadStick:Qe, isButtonPressed:Z, isButtonDown:X, isButtonReleased:ee, setButton:_, getButton:Ee, pressButton:gt, releaseButton:Gt, charInputted:ct, onResize:Ht, onKeyDown:xn, onKeyPress:vn, onKeyPressRepeat:pr, onKeyRelease:dr, onMouseDown:Mt, onMousePress:Xe, onMouseRelease:Cn, onMouseMove:L, onCharInput:U, onTouchStart:Y, onTouchMove:se, onTouchEnd:xe, onScroll:J, onHide:Ce, onShow:qt, onGamepadButtonDown:fr, onGamepadButtonPress:ut, onGamepadButtonRelease:hr, onGamepadStick:gr, onGamepadConnect:br, 
    onGamepadDisconnect:wn, onButtonPress:Ie, onButtonDown:Yt, onButtonRelease:Je, getLastInputDeviceType:Ss, events:e.events};
  }, "initApp");
  Fr.$jscomp$static$block$510831985$34();
  Br.$jscomp$static$block$510831985$33();
  vt.$jscomp$static$block$510831985$32();
  s(te, "dt");
  s(an, "fixedDt");
  s(un, "restDt");
  var qu = new E(-1, -1), zu = new E(0, -1), Yu = new E(1, -1), Wu = new E(-1, 0), $u = new E(0, 0), Xu = new E(1, 0), Qu = new E(-1, 1), Ju = new E(0, 1), Zu = new E(1, 1);
  s(Ne, "anchorPt");
  s(Ms, "alignPt");
  s(Rs, "createEmptyAudioBuffer");
  var Bs = 2 * Math.PI / 3, Fs = 2 * Math.PI / 4.5, kn = {linear:s(t => t, "linear"), easeInSine:s(t => 1 - Math.cos(t * Math.PI / 2), "easeInSine"), easeOutSine:s(t => Math.sin(t * Math.PI / 2), "easeOutSine"), easeInOutSine:s(t => -(Math.cos(Math.PI * t) - 1) / 2, "easeInOutSine"), easeInQuad:s(t => t * t, "easeInQuad"), easeOutQuad:s(t => 1 - (1 - t) * (1 - t), "easeOutQuad"), easeInOutQuad:s(t => .5 > t ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2, "easeInOutQuad"), easeInCubic:s(t => t * t * 
  t, "easeInCubic"), easeOutCubic:s(t => 1 - Math.pow(1 - t, 3), "easeOutCubic"), easeInOutCubic:s(t => .5 > t ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2, "easeInOutCubic"), easeInQuart:s(t => t * t * t * t, "easeInQuart"), easeOutQuart:s(t => 1 - Math.pow(1 - t, 4), "easeOutQuart"), easeInOutQuart:s(t => .5 > t ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2, "easeInOutQuart"), easeInQuint:s(t => t * t * t * t * t, "easeInQuint"), easeOutQuint:s(t => 1 - Math.pow(1 - t, 5), "easeOutQuint"), 
  easeInOutQuint:s(t => .5 > t ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2, "easeInOutQuint"), easeInExpo:s(t => 0 === t ? 0 : Math.pow(2, 10 * t - 10), "easeInExpo"), easeOutExpo:s(t => 1 === t ? 1 : 1 - Math.pow(2, -10 * t), "easeOutExpo"), easeInOutExpo:s(t => 0 === t ? 0 : 1 === t ? 1 : .5 > t ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2, "easeInOutExpo"), easeInCirc:s(t => 1 - Math.sqrt(1 - Math.pow(t, 2)), "easeInCirc"), easeOutCirc:s(t => Math.sqrt(1 - 
  Math.pow(t - 1, 2)), "easeOutCirc"), easeInOutCirc:s(t => .5 > t ? (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2, "easeInOutCirc"), easeInBack:s(t => 2.70158 * t * t * t - 1.70158 * t * t, "easeInBack"), easeOutBack:s(t => 1 + 2.70158 * Math.pow(t - 1, 3) + 1.70158 * Math.pow(t - 1, 2), "easeOutBack"), easeInOutBack:s(t => .5 > t ? Math.pow(2 * t, 2) * (7.189819 * t - 2.5949095) / 2 : (Math.pow(2 * t - 2, 2) * (3.5949095 * (2 * t - 2) + 2.5949095) + 
  2) / 2, "easeInOutBack"), easeInElastic:s(t => 0 === t ? 0 : 1 === t ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((10 * t - 10.75) * Bs), "easeInElastic"), easeOutElastic:s(t => 0 === t ? 0 : 1 === t ? 1 : Math.pow(2, -10 * t) * Math.sin((10 * t - .75) * Bs) + 1, "easeOutElastic"), easeInOutElastic:s(t => 0 === t ? 0 : 1 === t ? 1 : .5 > t ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * Fs)) / 2 : Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * Fs) / 2 + 1, "easeInOutElastic"), 
  easeInBounce:s(t => 1 - kn.easeOutBounce(1 - t), "easeInBounce"), easeOutBounce:s(t => t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375, "easeOutBounce"), easeInOutBounce:s(t => .5 > t ? (1 - kn.easeOutBounce(1 - 2 * t)) / 2 : (1 + kn.easeOutBounce(2 * t - 1)) / 2, "easeInOutBounce")}, nt = kn;
  s(ec, "buildPath");
  s(Lr, "aStarSearch");
  var jr = class {
    static $jscomp$static$block$510831985$35() {
      s(this, "NavEdge");
    }
    constructor(e, n, r) {
      this.a = e;
      this.b = n;
      this.polygon = new WeakRef(r);
    }
    isLeft(e, n) {
      return (this.b.x - this.a.x) * (n - this.a.y) - (e - this.a.x) * (this.b.y - this.a.y);
    }
    get middle() {
      return this.a.add(this.b).scale(.5);
    }
  }, Kr = class {
    static $jscomp$static$block$510831985$36() {
      s(this, "NavPolygon");
    }
    constructor(e) {
      this._id = e;
    }
    get id() {
      return this._id;
    }
    set edges(e) {
      this._edges = e;
      let r = e = 0, o = 0;
      for (let i of this._edges) {
        i.polygon = new WeakRef(this);
        let a = i.a.x * i.b.y - i.a.y * i.b.x;
        e += (i.a.x + i.b.x) * a;
        r += (i.a.y + i.b.y) * a;
        o += a;
      }
      o /= 2;
      this._centroid = v(e / (6 * o), r / (6 * o));
    }
    get edges() {
      return this._edges;
    }
    get centroid() {
      return this._centroid;
    }
    contains(e) {
      let n = !1;
      for (let r of this.edges) {
        r.b.y > e.y != r.a.y > e.y && e.x < (r.a.x - r.b.x) * (e.y - r.b.y) / (r.a.y - r.b.y) + r.b.x && (n = !n);
      }
      return n;
    }
  }, _n = class {
    static $jscomp$static$block$510831985$37() {
      s(this, "NavMesh");
    }
    constructor() {
      this._polygons = [];
      this._pointCache = {};
      this._edgeCache = {};
    }
    _addPoint(e) {
      let n = this._pointCache[`${e.x}_${e.y}`];
      return n || (n = e.clone(), this._pointCache[`${e.x}_${e.y}`] = n, n);
    }
    _addEdge(e) {
      return this._edgeCache[`${e.a.x}_${e.a.y}-${e.b.x}_${e.b.y}`] = e, e;
    }
    _findEdge(e, n) {
      return this._edgeCache[`${e.x}_${e.y}-${n.x}_${n.y}`];
    }
    _findCommonEdge(e, n) {
      for (let r of e.edges) {
        if ((e = this._findEdge(r.b, r.a)) && e.polygon.deref().id === n.id) {
          return e;
        }
      }
      return null;
    }
    addPolygon(e) {
      let n = new Kr(this._polygons.length), r = e.map((o, i) => new jr(o, e[(i + 1) % e.length], n));
      n.edges = r;
      this._polygons.push(n);
      for (let o of n.edges) {
        this._addEdge(o);
      }
      return n;
    }
    addRect(e, n) {
      let r = this._addPoint(e), o = this._addPoint(e.add(n.x, 0)), i = this._addPoint(e.add(n));
      e = this._addPoint(e.add(0, n.y));
      return this.addPolygon([r, o, i, e]);
    }
    _getLocation(e) {
      for (let n of this._polygons) {
        if (n.contains(e)) {
          return n;
        }
      }
      return null;
    }
    getNeighbours(e) {
      let n = [];
      for (let r of this._polygons[e].edges) {
        (e = this._findEdge(r.b, r.a)) && (e = e.polygon.deref()) && n.push(e.id);
      }
      return n;
    }
    getCost(e, n) {
      return 1;
    }
    getHeuristic(e, n) {
      e = this._polygons[e];
      let o = this._polygons[n];
      n = e.centroid.x - o.centroid.x;
      e = e.centroid.y - o.centroid.y;
      return Math.sqrt(n * n + e * e);
    }
    getPath(e, n) {
      return void 0 === e || void 0 === n ? [] : e === n ? [e, n] : Lr(this, e, n);
    }
    getWaypointPath(e, n, r) {
      var o = r?.type || "centroids";
      r = this._getLocation(e);
      var a = this._getLocation(n);
      if (void 0 === r || void 0 === a) {
        return [];
      }
      r = this.getPath(r.id, a.id);
      if (!r) {
        return [];
      }
      if ("edges" === o) {
        o = [];
        for (a = 1; a < r.length; a++) {
          let C = this._polygons[r[a]], p = this._findCommonEdge(this._polygons[r[a - 1]], C);
          o.push(p.middle.add(C.centroid.sub(p.middle).unit().scale(4)));
        }
        return [e, ...o, n];
      }
      return [e, ...r.slice(1, -1).map(u => this._polygons[u].centroid), n];
    }
  };
  _n.$jscomp$static$block$510831985$37();
  Kr.$jscomp$static$block$510831985$36();
  jr.$jscomp$static$block$510831985$35();
  s(dt, "calcTransform");
  s(Ls, "screen2ndc");
  s(Ct, "getArcPts");
  s(js, "setBackground");
  s(Ks, "getBackground");
  s(Q, "pushTranslate");
  s(be, "pushTransform");
  s(Is, "pushMatrix");
  s(rt, "pushScale");
  s($e, "pushRotate");
  s(pe, "popTransform");
  s(Oe, "flush");
  s(ae, "width");
  s(ce, "height");
  s(Nn, "getViewportScale");
  s(ks, "contentToView");
  s(tc, "windowToContent");
  s(Un, "mousePos");
  s(wt, "center");
  var cn = class {
    static $jscomp$static$block$510831985$38() {
      s(this, "TexPacker");
    }
    constructor(e, n, r, o) {
      this.lastTextureId = 0;
      this.textures = [];
      this.bigTextures = [];
      this.texturesPosition = new Map();
      this.curHeight = this.y = this.x = 0;
      this.gfx = e;
      this.canvas = document.createElement("canvas");
      this.canvas.width = n;
      this.canvas.height = r;
      this.textures = [Pe.fromImage(e, this.canvas)];
      this.bigTextures = [];
      this.padding = o;
      e = this.canvas.getContext("2d");
      if (!e) {
        throw Error("Failed to get 2d context");
      }
      this.c2d = e;
    }
    add(e) {
      let n = e.width + 2 * this.padding, r = e.height + 2 * this.padding;
      if (n > this.canvas.width || r > this.canvas.height) {
        return e = Pe.fromImage(this.gfx, e), this.bigTextures.push(e), [e, new z(0, 0, 1, 1), 0];
      }
      this.x + n > this.canvas.width && (this.x = 0, this.y += this.curHeight, this.curHeight = 0);
      this.y + r > this.canvas.height && (this.c2d.clearRect(0, 0, this.canvas.width, this.canvas.height), this.textures.push(Pe.fromImage(this.gfx, this.canvas)), this.x = 0, this.y = 0, this.curHeight = 0);
      let o = this.textures[this.textures.length - 1], i = new E(this.x + this.padding, this.y + this.padding);
      return this.x += n, r > this.curHeight && (this.curHeight = r), e instanceof ImageData ? this.c2d.putImageData(e, i.x, i.y) : this.c2d.drawImage(e, i.x, i.y), o.update(this.canvas), this.texturesPosition.set(this.lastTextureId, {position:i, size:new E(e.width, e.height), texture:o}), this.lastTextureId++, [o, new z(i.x / this.canvas.width, i.y / this.canvas.height, e.width / this.canvas.width, e.height / this.canvas.height), this.lastTextureId - 1];
    }
    free() {
      for (let e of this.textures) {
        e.free();
      }
      for (let e of this.bigTextures) {
        e.free();
      }
    }
  };
  cn.$jscomp$static$block$510831985$38();
  s(de, "fixURL");
  const node_modules$kaplay$dist$kaplay_cjs$classdecl$var13 = class {
    static $jscomp$static$block$510831985$39() {
      s(this, "Asset");
    }
    constructor(e) {
      this.loaded = !1;
      this.error = this.data = null;
      this.onLoadEvents = new oe();
      this.onErrorEvents = new oe();
      this.onFinishEvents = new oe();
      e.then(n => {
        this.loaded = !0;
        this.data = n;
        this.onLoadEvents.trigger(n);
      }).catch(n => {
        if (this.error = n, 0 < this.onErrorEvents.numListeners()) {
          this.onErrorEvents.trigger(n);
        } else {
          throw n;
        }
      }).finally(() => {
        this.onFinishEvents.trigger();
        this.loaded = !0;
      });
    }
    static loaded(e) {
      let n = new node_modules$kaplay$dist$kaplay_cjs$classdecl$var13(Promise.resolve(e));
      return n.data = e, n.loaded = !0, n;
    }
    onLoad(e) {
      return this.loaded && this.data ? e(this.data) : this.onLoadEvents.add(e), this;
    }
    onError(e) {
      return this.loaded && this.error ? e(this.error) : this.onErrorEvents.add(e), this;
    }
    onFinish(e) {
      return this.loaded ? e() : this.onFinishEvents.add(e), this;
    }
    then(e) {
      return this.onLoad(e);
    }
    catch(e) {
      return this.onError(e);
    }
    finally(e) {
      return this.onFinish(e);
    }
  };
  node_modules$kaplay$dist$kaplay_cjs$classdecl$var13.$jscomp$static$block$510831985$39();
  var le = node_modules$kaplay$dist$kaplay_cjs$classdecl$var13, ft = class {
    constructor() {
      this.assets = new Map();
      this.lastUID = 0;
    }
    static $jscomp$static$block$510831985$40() {
      s(this, "AssetBucket");
    }
    add(e, n) {
      e = e ?? this.lastUID++ + "";
      n = new le(n);
      return this.assets.set(e, n), n;
    }
    addLoaded(e, n) {
      e = e ?? this.lastUID++ + "";
      n = le.loaded(n);
      return this.assets.set(e, n), n;
    }
    get(e) {
      return this.assets.get(e);
    }
    progress() {
      if (0 === this.assets.size) {
        return 1;
      }
      let e = 0;
      return this.assets.forEach(n => {
        n.loaded && e++;
      }), e / this.assets.size;
    }
    getFailedAssets() {
      return Array.from(this.assets.keys()).filter(e => null !== this.assets.get(e).error).map(e => [e, this.assets.get(e)]);
    }
  };
  ft.$jscomp$static$block$510831985$40();
  s(_r, "fetchURL");
  s(Ot, "fetchJSON");
  s(_s, "fetchText");
  s(Ns, "fetchArrayBuffer");
  s(Us, "loadRoot");
  s(Hs, "loadJSON");
  s(Et, "loadImg");
  s(Fe, "loadProgress");
  s(Hn, "getFailedAssets");
  s(qs, "getAsset");
  s(ln, "load");
  var zs = s((t, e) => ({urlPrefix:"", sprites:new ft(), fonts:new ft(), bitmapFonts:new ft(), sounds:new ft(), shaders:new ft(), custom:new ft(), music:{}, packer:new cn(t, 2048, 2048, e), loaded:!1}), "initAssets");
  const node_modules$kaplay$dist$kaplay_cjs$classdecl$var14 = class {
    static $jscomp$static$block$510831985$41() {
      s(this, "SpriteData");
    }
    constructor(e, n, r = {}, o = null) {
      this.frames = [new z(0, 0, 1, 1)];
      this.anims = {};
      this.slice9 = null;
      this.tex = e;
      n && (this.frames = n);
      this.anims = r;
      this.slice9 = o;
    }
    get width() {
      return this.tex.width * this.frames[0].w;
    }
    get height() {
      return this.tex.height * this.frames[0].h;
    }
    static from(e, n = {}) {
      return "string" == typeof e ? node_modules$kaplay$dist$kaplay_cjs$classdecl$var14.fromURL(e, n) : Promise.resolve(node_modules$kaplay$dist$kaplay_cjs$classdecl$var14.fromImage(e, n));
    }
    static fromImage(e, n = {}) {
      let [r, o] = c.assets.packer.add(e);
      e = n.frames ? n.frames.map(a => new z(o.x + a.x * o.w, o.y + a.y * o.h, a.w * o.w, a.h * o.h)) : Ur(n.sliceX || 1, n.sliceY || 1, o.x, o.y, o.w, o.h);
      return new node_modules$kaplay$dist$kaplay_cjs$classdecl$var14(r, e, n.anims, n.slice9);
    }
    static fromURL(e, n = {}) {
      return Et(e).then(r => node_modules$kaplay$dist$kaplay_cjs$classdecl$var14.fromImage(r, n));
    }
  };
  node_modules$kaplay$dist$kaplay_cjs$classdecl$var14.$jscomp$static$block$510831985$41();
  var Le = node_modules$kaplay$dist$kaplay_cjs$classdecl$var14;
  s(It, "resolveSprite");
  s(Nr, "getSprite");
  s(Tt, "loadSprite");
  s(Ur, "slice");
  s(Ws, "createSpriteSheet");
  s($s, "loadBean");
  s(Xs, "loadAseprite");
  var At = class {
    static $jscomp$static$block$510831985$42() {
      s(this, "FontData");
    }
    constructor(e, n = {}) {
      this.filter = "linear";
      this.outline = null;
      this.size = 64;
      if (this.fontface = e, this.filter = n.filter ?? "linear", this.size = n.size ?? 64, 256 < this.size) {
        throw Error("Max font size: 256");
      }
      n.outline && (this.outline = {width:1, color:I(0, 0, 0)}, "number" == typeof n.outline ? this.outline.width = n.outline : "object" == typeof n.outline && (n.outline.width && (this.outline.width = n.outline.width), n.outline.color && (this.outline.color = n.outline.color)));
    }
  };
  At.$jscomp$static$block$510831985$42();
  s(Hr, "resolveFont");
  s(qr, "getFont");
  s(Qs, "loadFont");
  s(Js, "makeFont");
  s(qn, "getBitmapFont");
  s(Zs, "loadBitmapFont");
  s(ei, "loadPedit");
  var zr = class {
    static $jscomp$static$block$510831985$43() {
      s(this, "Shader");
    }
    constructor(e, n, r, o) {
      this.ctx = e;
      e.onDestroy(() => this.free());
      let i = e.gl;
      e = i.createShader(i.VERTEX_SHADER);
      let l = i.createShader(i.FRAGMENT_SHADER);
      if (!e || !l) {
        throw Error("Failed to create shader");
      }
      i.shaderSource(e, n);
      i.shaderSource(l, r);
      i.compileShader(e);
      i.compileShader(l);
      let u = i.createProgram();
      if (this.glProgram = u, i.attachShader(u, e), i.attachShader(u, l), o.forEach((m, d) => i.bindAttribLocation(u, d, m)), i.linkProgram(u), !i.getProgramParameter(u, i.LINK_STATUS)) {
        if (n = i.getShaderInfoLog(e)) {
          throw Error("VERTEX SHADER " + n);
        }
        if (n = i.getShaderInfoLog(l)) {
          throw Error("FRAGMENT SHADER " + n);
        }
      }
      i.deleteShader(e);
      i.deleteShader(l);
    }
    bind() {
      this.ctx.pushProgram(this.glProgram);
    }
    unbind() {
      this.ctx.popProgram();
    }
    send(e) {
      let n = this.ctx.gl;
      for (let r in e) {
        let o = e[r], i = n.getUniformLocation(this.glProgram, r);
        if ("number" == typeof o) {
          n.uniform1f(i, o);
        } else if (o instanceof he) {
          n.uniformMatrix4fv(i, !1, new Float32Array(o.m));
        } else if (o instanceof K) {
          n.uniform3f(i, o.r, o.g, o.b);
        } else if (o instanceof E) {
          n.uniform2f(i, o.x, o.y);
        } else if (Array.isArray(o)) {
          bs(o) ? n.uniform1fv(i, o) : gs(o) ? n.uniform2fv(i, o.map(l => [l.x, l.y]).flat()) : hs(o) && n.uniform3fv(i, o.map(l => [l.r, l.g, l.b]).flat());
        } else {
          throw Error("Unsupported uniform data type");
        }
      }
    }
    free() {
      this.ctx.gl.deleteProgram(this.glProgram);
    }
  };
  zr.$jscomp$static$block$510831985$43();
  s(zn, "makeShader");
  s(ti, "resolveShader");
  s(Yr, "getShader");
  s(ni, "loadShader");
  s(ri, "loadShaderURL");
  const node_modules$kaplay$dist$kaplay_cjs$classdecl$var15 = class {
    static $jscomp$static$block$510831985$44() {
      s(this, "SoundData");
    }
    constructor(e) {
      this.buf = e;
    }
    static fromArrayBuffer(e) {
      return (new Promise((n, r) => c.audio.ctx.decodeAudioData(e, n, r))).then(n => new node_modules$kaplay$dist$kaplay_cjs$classdecl$var15(n));
    }
    static fromURL(e) {
      return jn(e) ? node_modules$kaplay$dist$kaplay_cjs$classdecl$var15.fromArrayBuffer(ys(e)) : Ns(e).then(n => node_modules$kaplay$dist$kaplay_cjs$classdecl$var15.fromArrayBuffer(n));
    }
  };
  node_modules$kaplay$dist$kaplay_cjs$classdecl$var15.$jscomp$static$block$510831985$44();
  var ot = node_modules$kaplay$dist$kaplay_cjs$classdecl$var15;
  s(oi, "resolveSound");
  s(Wr, "getSound");
  s(si, "loadSound");
  s(ii, "loadMusic");
  s($r, "loadSpriteAtlas");
  s(je, "drawRaw");
  s(Ge, "drawPolygon");
  s(Yn, "drawEllipse");
  s(Ue, "drawCircle");
  s(_t, "drawLine");
  s(rc, "_drawLinesBevel");
  s(oc, "_drawLinesRound");
  s(sc, "_drawLinesMiter");
  s(kt, "drawLines");
  s(Wn, "drawCurve");
  s(ai, "drawBezier");
  const node_modules$kaplay$dist$kaplay_cjs$classdecl$var16 = class {
    static $jscomp$static$block$510831985$45() {
      s(this, "Texture");
    }
    constructor(e, n, r, o = {}) {
      this.src = null;
      this.ctx = e;
      let i = e.gl, a = e.gl.createTexture();
      if (!a) {
        throw Error("Failed to create texture");
      }
      this.glTex = a;
      e.onDestroy(() => this.free());
      this.width = n;
      this.height = r;
      e = {linear:i.LINEAR, nearest:i.NEAREST}[o.filter ?? e.opts.texFilter ?? "nearest"];
      o = {repeat:i.REPEAT, clampToEdge:i.CLAMP_TO_EDGE}[o.wrap ?? "clampToEdge"];
      this.bind();
      n && r && i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, n, r, 0, i.RGBA, i.UNSIGNED_BYTE, null);
      i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, e);
      i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, e);
      i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, o);
      i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, o);
      i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0);
      this.unbind();
    }
    static fromImage(e, n, r = {}) {
      e = new node_modules$kaplay$dist$kaplay_cjs$classdecl$var16(e, n.width, n.height, r);
      return e.update(n), e.src = n, e;
    }
    update(e, n = 0, r = 0) {
      let o = this.ctx.gl;
      this.bind();
      o.texSubImage2D(o.TEXTURE_2D, 0, n, r, o.RGBA, o.UNSIGNED_BYTE, e);
      this.unbind();
    }
    bind() {
      this.ctx.pushTexture2D(this.glTex);
    }
    unbind() {
      this.ctx.popTexture2D();
    }
    free() {
      this.ctx.gl.deleteTexture(this.glTex);
    }
  };
  node_modules$kaplay$dist$kaplay_cjs$classdecl$var16.$jscomp$static$block$510831985$45();
  var Pe = node_modules$kaplay$dist$kaplay_cjs$classdecl$var16, st = class {
    static $jscomp$static$block$510831985$46() {
      s(this, "FrameBuffer");
    }
    constructor(e, n, r, o = {}) {
      this.ctx = e;
      let i = e.gl;
      e.onDestroy(() => this.free());
      this.tex = new Pe(e, n, r, o);
      e = i.createFramebuffer();
      o = i.createRenderbuffer();
      if (!e || !o) {
        throw Error("Failed to create framebuffer");
      }
      this.glFramebuffer = e;
      this.glRenderbuffer = o;
      this.bind();
      i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, n, r);
      i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, this.tex.glTex, 0);
      i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, this.glRenderbuffer);
      this.unbind();
    }
    get width() {
      return this.tex.width;
    }
    get height() {
      return this.tex.height;
    }
    toImageData() {
      var e = this.ctx.gl;
      let n = new Uint8ClampedArray(this.width * this.height * 4);
      this.bind();
      e.readPixels(0, 0, this.width, this.height, e.RGBA, e.UNSIGNED_BYTE, n);
      this.unbind();
      e = 4 * this.width;
      let o = new Uint8Array(e);
      for (let i = 0; i < (this.height / 2 | 0); i++) {
        let a = i * e, l = (this.height - i - 1) * e;
        o.set(n.subarray(a, a + e));
        n.copyWithin(a, l, l + e);
        n.set(o, l);
      }
      return new ImageData(n, this.width, this.height);
    }
    toDataURL() {
      let e = document.createElement("canvas"), n = e.getContext("2d");
      if (e.width = this.width, e.height = this.height, !n) {
        throw Error("Failed to get 2d context");
      }
      return n.putImageData(this.toImageData(), 0, 0), e.toDataURL();
    }
    clear() {
      let e = this.ctx.gl;
      e.clear(e.COLOR_BUFFER_BIT);
    }
    draw(e) {
      this.bind();
      e();
      this.unbind();
    }
    bind() {
      this.ctx.pushFramebuffer(this.glFramebuffer);
      this.ctx.pushRenderbuffer(this.glRenderbuffer);
      this.ctx.pushViewport({x:0, y:0, w:this.width, h:this.height});
    }
    unbind() {
      this.ctx.popFramebuffer();
      this.ctx.popRenderbuffer();
      this.ctx.popViewport();
    }
    free() {
      let e = this.ctx.gl;
      e.deleteFramebuffer(this.glFramebuffer);
      e.deleteRenderbuffer(this.glRenderbuffer);
      this.tex.free();
    }
  }, $n = class {
    static $jscomp$static$block$510831985$47() {
      s(this, "BatchRenderer");
    }
    constructor(e, n, r, o) {
      this.vqueue = [];
      this.iqueue = [];
      this.numDraws = 0;
      this.curShader = this.curTex = this.curPrimitive = null;
      this.curUniform = {};
      let i = e.gl;
      this.vertexFormat = n;
      this.ctx = e;
      this.stride = n.reduce((l, u) => l + u.size, 0);
      this.maxVertices = r;
      this.maxIndices = o;
      n = i.createBuffer();
      if (!n) {
        throw Error("Failed to create vertex buffer");
      }
      this.glVBuf = n;
      e.pushArrayBuffer(this.glVBuf);
      i.bufferData(i.ARRAY_BUFFER, 4 * r, i.DYNAMIC_DRAW);
      e.popArrayBuffer();
      this.glIBuf = i.createBuffer();
      e.pushElementArrayBuffer(this.glIBuf);
      i.bufferData(i.ELEMENT_ARRAY_BUFFER, 4 * o, i.DYNAMIC_DRAW);
      e.popElementArrayBuffer();
    }
    push(e, n, r, o, i = null, a = {}) {
      (e !== this.curPrimitive || i !== this.curTex || o !== this.curShader || !Kn(this.curUniform, a) || this.vqueue.length + n.length * this.stride > this.maxVertices || this.iqueue.length + r.length > this.maxIndices) && this.flush();
      let l = this.vqueue.length / this.stride;
      for (let u of n) {
        this.vqueue.push(u);
      }
      for (let u of r) {
        this.iqueue.push(u + l);
      }
      this.curPrimitive = e;
      this.curShader = o;
      this.curTex = i;
      this.curUniform = a;
    }
    flush() {
      if (this.curPrimitive && this.curShader && 0 !== this.vqueue.length && 0 !== this.iqueue.length) {
        var e = this.ctx.gl;
        this.ctx.pushArrayBuffer(this.glVBuf);
        e.bufferSubData(e.ARRAY_BUFFER, 0, new Float32Array(this.vqueue));
        this.ctx.pushElementArrayBuffer(this.glIBuf);
        e.bufferSubData(e.ELEMENT_ARRAY_BUFFER, 0, new Uint16Array(this.iqueue));
        this.ctx.setVertexFormat(this.vertexFormat);
        this.curShader.bind();
        this.curShader.send(this.curUniform);
        this.curTex?.bind();
        e.drawElements(this.curPrimitive, this.iqueue.length, e.UNSIGNED_SHORT, 0);
        this.curTex?.unbind();
        this.curShader.unbind();
        this.ctx.popArrayBuffer();
        this.ctx.popElementArrayBuffer();
        this.vqueue = [];
        this.iqueue = [];
        this.numDraws++;
      }
    }
    free() {
      let e = this.ctx.gl;
      e.deleteBuffer(this.glVBuf);
      e.deleteBuffer(this.glIBuf);
    }
  };
  $n.$jscomp$static$block$510831985$47();
  st.$jscomp$static$block$510831985$46();
  s(St, "genStack");
  s(ui, "initGfx");
  var Xr = {};
  s(mi, "applyCharTransform");
  s(Xn, "compileStyledText");
  s(He, "formatText");
  s(it, "drawUVQuad");
  s(qe, "drawFormattedText");
  s(ve, "drawRect");
  s(ze, "drawUnscaled");
  s(Qr, "drawInspectText");
  s(Qn, "drawTriangle");
  s(di, "drawDebug");
  s(Jr, "prettyDebug");
  s(fi, "drawFrame");
  s(hi, "drawLoadScreen");
  s(Jn, "drawStenciled");
  s(gi, "drawMasked");
  s(Vt, "drawTexture");
  s(bi, "drawSprite");
  s(yi, "drawSubtracted");
  s(Zr, "drawText");
  var xi = s((t, e) => {
    let n = zn(e, "\nvec4 vert(vec2 pos, vec2 uv, vec4 color) {\n\treturn def_vert();\n}\n", "\nvec4 frag(vec2 pos, vec2 uv, vec4 color, sampler2D tex) {\n\treturn def_frag();\n}\n"), r = t.pixelDensity ?? 1, o = t.scale ?? 1, {gl:i} = e, a = Pe.fromImage(e, new ImageData(new Uint8ClampedArray([255, 255, 255, 255]), 1, 1)), l = t.width && t.height ? new st(e, t.width * r * o, t.height * r * o) : new st(e, i.drawingBufferWidth, i.drawingBufferHeight), u = null, m = 1;
    t.background && ("string" == typeof t.background ? u = I(t.background) : (u = I(...t.background), m = t.background[3] ?? 1), i.clearColor(u.r / 255, u.g / 255, u.b / 255, m ?? 1));
    i.enable(i.BLEND);
    i.blendFuncSeparate(i.ONE, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA);
    let d = new $n(e, en, is, 12288), C = Pe.fromImage(e, new ImageData(new Uint8ClampedArray([128, 128, 128, 255, 190, 190, 190, 255, 190, 190, 190, 255, 128, 128, 128, 255]), 2, 2), {wrap:"repeat", filter:"nearest"});
    return {lastDrawCalls:0, ggl:e, defShader:n, defTex:a, frameBuffer:l, postShader:null, postShaderUniform:null, renderer:d, transform:new he(), transformStack:[], bgTex:C, bgColor:u, bgAlpha:m, width:t.width ?? i.drawingBufferWidth / r / o, height:t.height ?? i.drawingBufferHeight / r / o, viewport:{x:0, y:0, width:i.drawingBufferWidth, height:i.drawingBufferHeight}, fixed:!1};
  }, "initAppGfx");
  s(Zn, "updateViewport");
  s(at, "isFixed");
  s(Ke, "getRenderProps");
  s(vi, "circle");
  s(er, "color");
  s(Ci, "drawon");
  s(wi, "fadeIn");
  s(Oi, "mask");
  s(tr, "opacity");
  s(Ei, "outline");
  var eo = class {
    static $jscomp$static$block$510831985$48() {
      s(this, "Particle");
    }
    constructor() {
      this.pos = v(0);
      this.vel = v(0);
      this.acc = v(0);
      this.damping = this.angularVelocity = this.angle = 0;
      this.lt = null;
      this.t = 0;
      this.gc = !0;
    }
    get progress() {
      return this.lt ? this.t / this.lt : this.t;
    }
  };
  eo.$jscomp$static$block$510831985$48();
  s(Ti, "particles");
  s(Ai, "polygon");
  s(nr, "raycast");
  s(rr, "rect");
  s(Si, "shader");
  s(Vi, "addLevel");
  s(Me, "on");
  var Pi = s((t, e, ...n) => {
    for (let r of c.game.root.children) {
      r.is(e) && r.trigger(t);
    }
  }, "trigger"), Gi = re(t => {
    let e = c.game.root.add([{fixedUpdate:t}]);
    return {get paused() {
      return e.paused;
    }, set paused(n) {
      e.paused = n;
    }, cancel:s(() => e.destroy(), "cancel")};
  }, (t, e) => Me("fixedUpdate", t, e)), Mi = re(t => {
    let e = c.game.root.add([{update:t}]);
    return {get paused() {
      return e.paused;
    }, set paused(n) {
      e.paused = n;
    }, cancel:s(() => e.destroy(), "cancel")};
  }, (t, e) => Me("update", t, e)), Ri = re(t => {
    let e = c.game.root.add([{draw:t}]);
    return {get paused() {
      return e.hidden;
    }, set paused(n) {
      e.hidden = n;
    }, cancel:s(() => e.destroy(), "cancel")};
  }, (t, e) => Me("draw", t, e)), to = re(t => c.game.events.on("add", t), (t, e) => Me("add", t, e)), Di = re(t => c.game.events.on("destroy", t), (t, e) => Me("destroy", t, e)), Bi = re(t => c.game.events.on("use", t), (t, e) => Me("use", t, e)), Fi = re(t => c.game.events.on("unuse", t), (t, e) => Me("unuse", t, e)), no = re(t => c.game.events.on("tag", t), (t, e) => Me("tag", t, e)), Li = re(t => c.game.events.on("untag", t), (t, e) => Me("untag", t, e));
  s(ji, "onCollide");
  s(Ki, "onCollideUpdate");
  s(Ii, "onCollideEnd");
  s(sr, "forAllCurrentAndFuture");
  var ki = re(t => c.app.onMousePress(t), (t, e) => {
    let n = [];
    return sr(t, r => {
      if (!r.area) {
        throw Error("onClick() requires the object to have area() component");
      }
      n.push(r.onClick(() => e(r)));
    }), _e.join(n);
  });
  s(_i, "onHover");
  s(Ni, "onHoverUpdate");
  s(Ui, "onHoverEnd");
  s(Hi, "onLoading");
  s(qi, "onResize");
  s(zi, "onError");
  s(Nt, "onLoad");
  s(Yi, "onLoadError");
  s(ro, "setCamPos");
  s(oo, "getCamPos");
  s(so, "setCamScale");
  s(io, "getCamScale");
  s(ao, "setCamRot");
  s(uo, "getCamRot");
  s(Wi, "getCamTransform");
  s(co, "flash");
  s($i, "camTransform");
  s(Xi, "shake");
  s(dn, "toScreen");
  s(ir, "toWorld");
  s(Qi, "camPos");
  s(Ji, "camScale");
  s(Zi, "camRot");
  s(ea, "camFlash");
  s(fn, "make");
  var ta = s(() => ({events:new Ye(), objEvents:new Ye(), root:fn([]), gravity:null, scenes:{}, currentScene:null, layers:null, defaultLayerIndex:0, logs:[], cam:{pos:null, scale:new E(1), angle:0, shake:0, transform:new he()}}), "initGame");
  s(na, "setGravity");
  s(ra, "getGravity");
  s(oa, "setGravityDirection");
  s(ht, "getGravityDirection");
  var sa = To("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"), 
  ia = s(() => (() => {
    let e = new (window.AudioContext || window.webkitAudioContext)(), n = e.createGain();
    n.connect(e.destination);
    let r = new ot(Rs(e));
    return e.decodeAudioData(sa.buffer.slice(0)).then(o => {
      r.buf = o;
    }).catch(o => {
      console.error("Failed to load burp: ", o);
    }), {ctx:e, masterNode:n, burpSnd:r};
  })(), "initAudio");
  s(aa, "playMusic");
  s(ua, "play");
  s(cr, "burp");
  s(lo, "setVolume");
  s(mo, "getVolume");
  s(ca, "volume");
  s(lr, "initEvents");
  s(la, "addKaboom");
  s(fo, "setLayers");
  s(ma, "getLayers");
  s(pa, "getDefaultLayer");
  s(da, "layers");
  s(ar, "destroy");
  s(fa, "getTreeRoot");
  s(ha, "scene");
  s(ga, "go");
  s(ba, "onSceneLeave");
  s(ya, "getSceneName");
  s(hn, "sprite");
  s(xa, "text");
  s(va, "uvquad");
  s(Ca, "agent");
  s(wa, "pathfinder");
  s(Oa, "patrol");
  s(Ea, "sentry");
  s(or, "tile");
  var yn = class {
    static $jscomp$static$block$510831985$49() {
      s(this, "AnimateChannel");
    }
    constructor(e, n, r) {
      this.name = e;
      this.duration = n.duration;
      this.loops = n.loops || 0;
      this.direction = n.direction || "forward";
      this.easing = n.easing || nt.linear;
      this.interpolation = n.interpolation || "linear";
      this.isFinished = !1;
      this.timing = n.timing;
      this.easings = n.easings;
      this.relative = r;
    }
    update(e, n) {
      return !0;
    }
    getLowerKeyIndexAndRelativeTime(e, n, r) {
      let o = n - 1;
      e /= this.duration;
      if (0 !== this.loops && e >= this.loops) {
        return [o, 0, !0];
      }
      let a = Math.trunc(e);
      if (e -= a, ("reverse" == this.direction || "ping-pong" == this.direction && a & 1) && (e = 1 - e), r) {
        for (n = 0; void 0 !== r[n + 1] && r[n + 1] < e;) {
          n++;
        }
        return n >= o ? [o, 0, !0] : [n, (e - r[n]) / (r[n + 1] - r[n]), !1];
      }
      r = Math.floor((n - 1) * e);
      return [r, (e - r / o) * o, !1];
    }
    setValue(e, n, r) {
      if (this.relative) {
        switch(n) {
          case "pos":
            e.pos = e.base.pos.add(r);
            break;
          case "angle":
            e.angle = e.base.angle + r;
            break;
          case "scale":
            e.scale = e.base.scale.scale(r);
            break;
          case "opacity":
            e.opacity = e.base.opacity * r;
            break;
          default:
            e[n] = r;
        }
      } else {
        e[n] = r;
      }
    }
    serialize() {
      let e = {duration:this.duration, keys:[]};
      return this.loops && (e.loops = this.loops), "forward" !== this.direction && (e.direction = this.direction), this.easing != nt.linear && (e.easing = this.easing.name), "linear" !== this.interpolation && (e.interpolation = this.interpolation), this.timing && (e.timing = this.timing), this.easings && (e.easings = this.easings.map(n => this.easing.name)), e;
    }
  };
  yn.$jscomp$static$block$510831985$49();
  s(Ta, "reflect");
  var ho = class extends yn {
    static $jscomp$static$block$510831985$50() {
      s(this, "AnimateChannelNumber");
    }
    constructor(e, n, r, o) {
      super(e, r, o);
      this.keys = n;
    }
    update(e, n) {
      let [r, o, i] = this.getLowerKeyIndexAndRelativeTime(n, this.keys.length, this.timing);
      0 == o || "none" === this.interpolation ? this.setValue(e, this.name, this.keys[r]) : this.setValue(e, this.name, fe(this.keys[r], this.keys[r + 1], (this.easings ? this.easings[r] : this.easing)(o)));
      return i;
    }
    serialize() {
      return Object.assign(super.serialize(), {keys:this.keys});
    }
  }, go = class extends yn {
    static $jscomp$static$block$510831985$51() {
      s(this, "AnimateChannelVec2");
    }
    constructor(e, n, r, o, i) {
      if (super(e, r, o), this.keys = n, "spline" === this.interpolation) {
        for (this.curves = [], i && (this.dcurves = []), e = 0; e < this.keys.length - 1; e++) {
          n = this.keys[e];
          var u = e + 1;
          r = this.keys[u];
          o = 0 < e ? this.keys[e - 1] : Ta(r, n);
          u = u < this.keys.length - 1 ? this.keys[u + 1] : Ta(n, r);
          this.curves.push(jt(o, n, r, u));
          i && this.dcurves?.push(jt(o, n, r, u, Qo));
        }
      }
    }
    update(e, n) {
      let [r, o, i] = this.getLowerKeyIndexAndRelativeTime(n, this.keys.length, this.timing);
      if (0 == o || "none" === this.interpolation) {
        this.setValue(e, this.name, this.keys[r]);
      } else {
        switch(n = this.easings ? this.easings[r] : this.easing, this.interpolation) {
          case "linear":
            this.setValue(e, this.name, this.keys[r].lerp(this.keys[r + 1], n(o)));
            break;
          case "slerp":
            this.setValue(e, this.name, this.keys[r].slerp(this.keys[r + 1], n(o)));
            break;
          case "spline":
            this.curves && (this.setValue(e, this.name, this.curves[r](n(o))), this.dcurves && this.setValue(e, "angle", this.dcurves[r](n(o)).angle()));
        }
      }
      return i;
    }
    serialize() {
      return Object.assign(super.serialize(), {keys:this.keys.map(e => [e.x, e.y])});
    }
  }, bo = class extends yn {
    static $jscomp$static$block$510831985$52() {
      s(this, "AnimateChannelColor");
    }
    constructor(e, n, r, o) {
      super(e, r, o);
      this.keys = n;
    }
    update(e, n) {
      let [r, o, i] = this.getLowerKeyIndexAndRelativeTime(n, this.keys.length, this.timing);
      0 == o || "none" == this.interpolation ? this.setValue(e, this.name, this.keys[r]) : this.setValue(e, this.name, this.keys[r].lerp(this.keys[r + 1], (this.easings ? this.easings[r] : this.easing)(o)));
      return i;
    }
    serialize() {
      return Object.assign(super.serialize(), {keys:this.keys});
    }
  };
  bo.$jscomp$static$block$510831985$52();
  go.$jscomp$static$block$510831985$51();
  ho.$jscomp$static$block$510831985$50();
  s(Aa, "animate");
  s(yo, "serializeAnimation");
  s(po, "boom");
  s(Sa, "health");
  s(Va, "lifespan");
  s(Pa, "named");
  s(Ga, "state");
  s(mr, "stay");
  s(Ma, "textInput");
  s(bn, "timer");
  var xo = 0;
  s(function() {
    return 0 < xo;
  }, "usesArea");
  s(Da, "area");
  s(Ba, "body");
  s(Fa, "doubleJump");
  s(La, "surfaceEffector");
  s(ja, "areaEffector");
  s(Ka, "pointEffector");
  s(Ia, "constantForce");
  s(ka, "platformEffector");
  s(_a, "buoyancyEffector");
  s(gn, "anchor");
  s(ur, "fixed");
  s(Na, "follow");
  s(Ua, "layer");
  s(Ha, "move");
  s(qa, "offscreen");
  s(Pt, "pos");
  s(za, "rotate");
  s(Ut, "scale");
  s(Ya, "z");
  var c = {k:null, globalOpt:null, gfx:null, game:null, app:null, assets:null, fontCacheCanvas:null, fontCacheC2d:null, debug:null, audio:null, pixelDensity:null, canvas:null, gscale:null, kaSprite:null, boomSprite:null}, fc = s((t = {tagsAsComponents:!0}) => {
    function V(L, U) {
      let Y = new st(b, L, U);
      return {clear:s(() => Y.clear(), "clear"), free:s(() => Y.free(), "free"), toDataURL:s(() => Y.toDataURL(), "toDataURL"), toImageData:s(() => Y.toImageData(), "toImageData"), width:Y.width, height:Y.height, draw:s(se => {
        Oe();
        Y.bind();
        se();
        Oe();
        Y.unbind();
      }, "draw"), get fb() {
        return Y;
      }};
    }
    function A() {
      p.clear(p.COLOR_BUFFER_BIT);
      f.frameBuffer.bind();
      p.clear(p.COLOR_BUFFER_BIT);
      f.bgColor || ze(() => {
        it({width:ae(), height:ce(), quad:new z(0, 0, ae() / 64, ce() / 64), tex:f.bgTex, fixed:!0});
      });
      f.renderer.numDraws = 0;
      f.fixed = !1;
      f.transformStack.length = 0;
      f.transform = new he();
    }
    function D(L, U) {
      f.postShader = L;
      f.postShaderUniform = U ?? null;
    }
    function G() {
      Oe();
      f.lastDrawCalls = f.renderer.numDraws;
      f.frameBuffer.unbind();
      p.viewport(0, 0, p.drawingBufferWidth, p.drawingBufferHeight);
      let L = f.width, U = f.height;
      f.width = p.drawingBufferWidth / a;
      f.height = p.drawingBufferHeight / a;
      Vt({flipY:!0, tex:f.frameBuffer.tex, pos:new E(f.viewport.x, f.viewport.y), width:f.viewport.width, height:f.viewport.height, shader:f.postShader, uniform:"function" == typeof f.postShaderUniform ? f.postShaderUniform() : f.postShaderUniform, fixed:!0});
      Oe();
      f.width = L;
      f.height = U;
    }
    function S(L, U) {
      try {
        return JSON.parse(window.localStorage[L]);
      } catch {
        return U ? (M(L, U), U) : null;
      }
    }
    function M(L, U) {
      window.localStorage[L] = JSON.stringify(U);
    }
    function R(L, ...U) {
      L = L(Xe);
      let se;
      "function" == typeof L ? se = L(...U)(Xe) : se = L;
      for (let xe in se) {
        Xe[xe] = se[xe], !1 !== t.global && (window[xe] = se[xe]);
      }
      return Xe;
    }
    function F(L) {
      let U = m.canvas.captureStream(L), Y = O.ctx.createMediaStreamDestination();
      O.masterNode.connect(Y);
      let se = new MediaRecorder(U), xe = [];
      return se.ondataavailable = J => {
        0 < J.data.size && xe.push(J.data);
      }, se.onerror = () => {
        O.masterNode.disconnect(Y);
        U.getTracks().forEach(J => J.stop());
      }, se.start(), {resume() {
        se.resume();
      }, pause() {
        se.pause();
      }, stop() {
        return se.stop(), O.masterNode.disconnect(Y), U.getTracks().forEach(J => J.stop()), new Promise(J => {
          se.onstop = () => {
            J(new Blob(xe, {type:"video/mp4"}));
          };
        });
      }, download(J = "kaboom.mp4") {
        this.stop().then(Ce => Rr(J, Ce));
      }};
    }
    function j() {
      return document.activeElement === m.canvas;
    }
    function gt() {
      y.root.fixedUpdate();
    }
    function Gt() {
      y.root.update();
    }
    function xn() {
      function xe(J) {
        if (se.push(Y.clone()), J.pos && Y.translate(J.pos), J.scale && Y.scale(J.scale), J.angle && Y.rotate(J.angle), J.transform = Y.clone(), J.c("area") && !J.paused) {
          var ut = J.worldArea().bbox(), fr = Math.floor(ut.pos.x / U);
          let hr = Math.floor(ut.pos.y / U), gr = Math.ceil((ut.pos.x + ut.width) / U);
          ut = Math.ceil((ut.pos.y + ut.height) / U);
          let wn = new Set();
          for (; fr <= gr; fr++) {
            for (let ct = hr; ct <= ut; ct++) {
              if (L[fr]) {
                if (L[fr][ct]) {
                  let zt = L[fr][ct];
                  a: for (let Ie of zt) {
                    if (!Ie.paused && Ie.exists() && !wn.has(Ie.id)) {
                      for (let Je of J.collisionIgnore) {
                        if (Ie.is(Je)) {
                          continue a;
                        }
                      }
                      for (let Je of Ie.collisionIgnore) {
                        if (J.is(Je)) {
                          continue a;
                        }
                      }
                      var Yt = ts(J.worldArea(), Ie.worldArea());
                      if (Yt) {
                        Yt = new Ht(J, Ie, Yt.normal, Yt.distance);
                        J.trigger("collideUpdate", Ie, Yt);
                        let On = Yt.reverse();
                        On.resolved = Yt.resolved;
                        Ie.trigger("collideUpdate", J, On);
                      }
                      wn.add(Ie.id);
                    }
                  }
                  zt.push(J);
                } else {
                  L[fr][ct] = [J];
                }
              } else {
                L[fr] = {}, L[fr][ct] = [J];
              }
            }
          }
        }
        J.children.forEach(xe);
        Y = se.pop();
      }
      if (0 < xo) {
        var L = {}, U = t.hashGridSize || 64, Y = new he(), se = [];
        s(xe, "checkObj");
        xe(y.root);
      }
    }
    function vn(L) {
      console.error(L);
      O.ctx.suspend();
      let U = L.message ?? String(L) ?? "Unknown error, check console for more info";
      m.run(() => {
      }, () => {
        A();
        ze(() => {
          var xe = ae();
          let J = ce(), Ce = {size:36, width:xe - 64, letterSpacing:4, lineSpacing:4, font:"monospace", fixed:!0};
          ve({width:xe, height:J, color:I(0, 0, 255), fixed:!0});
          xe = He({...Ce, text:"Error", pos:v(32), color:I(255, 128, 0), fixed:!0});
          qe(xe);
          Zr({...Ce, text:U, pos:v(32, 32 + xe.height + 16), fixed:!0});
          pe();
          y.events.trigger("error", L);
        });
        G();
      });
    }
    function pr(L) {
      d.push(L);
    }
    function dr() {
      y.events.onOnce("frameEnd", () => {
        m.quit();
        p.clear(p.COLOR_BUFFER_BIT | p.DEPTH_BUFFER_BIT | p.STENCIL_BUFFER_BIT);
        let L = p.getParameter(p.MAX_TEXTURE_IMAGE_UNITS);
        for (let U = 0; U < L; U++) {
          p.activeTexture(p.TEXTURE0 + U), p.bindTexture(p.TEXTURE_2D, null), p.bindTexture(p.TEXTURE_CUBE_MAP, null);
        }
        p.bindBuffer(p.ARRAY_BUFFER, null);
        p.bindBuffer(p.ELEMENT_ARRAY_BUFFER, null);
        p.bindRenderbuffer(p.RENDERBUFFER, null);
        p.bindFramebuffer(p.FRAMEBUFFER, null);
        b.destroy();
        d.forEach(U => U());
      });
    }
    c.k && (console.warn("KAPLAY already initialized, you are calling kaplay() multiple times, it may lead bugs!"), c.k.quit());
    c.globalOpt = t;
    var e = t.root ?? document.body;
    e === document.body && (document.body.style.width = "100%", document.body.style.height = "100%", document.body.style.margin = "0px", document.documentElement.style.width = "100%", document.documentElement.style.height = "100%");
    e = t.canvas ?? e.appendChild(document.createElement("canvas"));
    c.canvas = e;
    var r = t.scale ?? 1;
    c.gscale = r;
    var o = t.width && t.height && !t.stretch && !t.letterbox;
    o ? (e.width = t.width * r, e.height = t.height * r) : (e.width = e.parentElement.offsetWidth, e.height = e.parentElement.offsetHeight);
    r = ["outline: none", "cursor: default"];
    o ? (o = e.height, r.push(`width: ${e.width}px`), r.push(`height: ${o}px`)) : (r.push("width: 100%"), r.push("height: 100%"));
    t.crisp && (r.push("image-rendering: pixelated"), r.push("image-rendering: crisp-edges"));
    e.style.cssText = r.join(";");
    let a = t.pixelDensity || 1;
    c.pixelDensity = a;
    e.width *= a;
    e.height *= a;
    e.tabIndex = 0;
    o = document.createElement("canvas");
    o.width = 256;
    o.height = 256;
    c.fontCacheCanvas = o;
    o = o.getContext("2d", {willReadFrequently:!0});
    c.fontCacheC2d = o;
    let m = Gs({canvas:e, touchToMouse:t.touchToMouse, gamepads:t.gamepads, pixelDensity:t.pixelDensity, maxFPS:t.maxFPS, buttons:t.buttons});
    c.app = m;
    let d = [];
    e = m.canvas.getContext("webgl", {antialias:!0, depth:!0, stencil:!0, alpha:!0, preserveDrawingBuffer:!0});
    if (!e) {
      throw Error("WebGL not supported");
    }
    let p = e, b = ui(p, {texFilter:t.texFilter}), f = xi(t, b);
    c.gfx = f;
    let O = ia();
    c.audio = O;
    let g = zs(b, t.spriteAtlasPadding ?? 0);
    c.assets = g;
    let y = ta();
    c.game = y;
    y.root.use(bn());
    s(V, "makeCanvas");
    s(A, "frameStart");
    s(D, "usePostEffect");
    s(G, "frameEnd");
    let x = !1, w = {inspect:!1, timeScale:1, showLog:!0, fps:s(() => m.fps(), "fps"), numFrames:s(() => m.numFrames(), "numFrames"), stepFrame:Gt, drawCalls:s(() => f.lastDrawCalls, "drawCalls"), clearLog:s(() => y.logs = [], "clearLog"), log:s((...L) => {
      let U = t.logMax ?? 8;
      L = 1 < L.length ? L.concat(" ").join(" ") : L[0];
      y.logs.unshift({msg:L, time:m.time()});
      y.logs.length > U && (y.logs = y.logs.slice(0, U));
    }, "log"), error:s(L => w.log(Error(L.toString ? L.toString() : L)), "error"), curRecording:null, numObjects:s(() => N("*", {recursive:!0}).length, "numObjects"), get paused() {
      return x;
    }, set paused(L) {
      (x = L) ? O.ctx.suspend() : O.ctx.resume();
    }};
    c.debug = w;
    s(S, "getData");
    s(M, "setData");
    s(R, "plug");
    s(F, "record");
    s(j, "isFocused");
    e = y.root.add.bind(y.root);
    o = y.root.readd.bind(y.root);
    r = y.root.removeAll.bind(y.root);
    let N = y.root.get.bind(y.root), k = y.root.wait.bind(y.root), Z = y.root.loop.bind(y.root), X = y.root.query.bind(y.root), ee = y.root.tween.bind(y.root), Ee = Tt(null, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOcAAACDCAYAAAB2kQxsAAAAAXNSR0IArs4c6QAABdRJREFUeJzt3d3N3TYMgGG16ADdoAhyl7UyV9bqXRB0g2zQXgRGDcOWSIoUaX3vAwQBknMk/4gWLcnHrQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACDEb9kb8FH99eeXf6Wf/efn35ynDyj1pEsb6G6NUxOYZ7sdB/QtPdnWRnn29gbKMYDUspPs0SgPb22cHANo/JG9AZF6wWBp3JLgeir36bvff3x9LOvzp2/dbSFA97bk5I4a9VMD7TXOUcP0uJ+d6emu5d6V1QvMs5nj8FZPx37X/b2TFpzShtnafeP0DipJMFnLnN3/w1OQ7tZgP+pA4VVKcHo0TG36KNULKGt5XsHZmi1APS5WM2Vqg0i7vbsG6YcIznN9vRTxXHavgdxtv6Tc3vc1pAHqdaG6ipwKYprpf1sFp6aH0gRTrxxLubPB2avHu+c/l3mICvqnsr//+Cq+qGrK1Xw/wzbBaRkNvSv3yew9cq+cu89L6nu6F/cMzCgzF1ftANlbe+Otp1IkDVxyVfbo6Z481f3507dhvXfbrk3HpdtjKTNqKuio8678c7mzF6ns6arfMyrVNoA75wMfNU2hKSeCx3Fq7dc+SPfDc39H9Vqn2CT//4bsYeT1PecOJyGSJdh6PZOlbElPZz2PHtlD1cUeS4LT4z5IOihwfNaD5ERm9qxH/dZ7Vmt9M999CtCZbdLUP/p3r2zFQ0paG8lr4Eb6+ZWBcSeq/qhyK6bXUfXOSgtO7/tOb9eT1NveqKttpYbiyXu/euV51JV16/T6e86zyF5TUp731V5Sp+Z7M71h9QvFNWWuvr0Sy4LzLfNvrel6zRX1e+hN2VzrnNlfaYD0xhCs++851lDh3vNV95xe6YvHgb8bwbNcuc+f09wbaUj2dzYgjz93//5kh94t0quCM8OKK6glKKuM0EYHfhUZWd8WwenZa0rLsp6s2YY66o0k9WUvS4NManBaGuo1eDIHgUZ1ePdkntsfFaCz5VZJdStsxyt7ziMNXHEAK5yk1mqmhrMPf1fcp57Vqe3SqZTMEduZhqAZyaywFne0DVHngHTZ11bznE88l/1lBZ9meP8851plWkBCO7drmQvWnL/sY/fKtFaqN3iy6iofsQxNktJnTMgfPXJUz3w3VaP5vOQ7Iyszvy2DczSi+aYFET2jINUEqFcAS4+rV480WlwRWXe07dLa0YGvfl9kmbTvPZJ1TXGvn4t4yuRp+2aMgk27wkm63DIztU3vOVfueC8wK4zKWtK0M+nvJXmOdlt65MgFFCva06qsKz044SvjIiN5TjLaaHxhtNyyouXBGZ1WSn66Ivt+M7pRZAWoZsDq+t2emeM1am/WtHxFG9runrO1/n1CxLK7CilxJM/H4bwuTJJBvWtgvm0gcNu01uvpd8la1soLE7xkpYDea4Ot6W3GOSzRc3o/qHw2M9qmXWA+uw+jbd0hyO9Yz0+vJ9QGcO/8ZV2YUqYVPN8dImXp3aJ/w1XTGGYfKZN+P7IXiXqO1uINLzFOm/Pz+BV4C03PNEqpZl//ELXP1ro8nhLyKLPHMyAiXyvh4cMFZ2uyAJXc62gzgJl1nhrSLMEzcLx+5qQnIhgqv6qhTHC2Zmus1tUuowCVDkRU6j0jgiJqhLPSSq2q7wMtMSBkdbcQWjNCq2nMlRrTnajAPP/t+c5Sj3K8VNueQ+pGzaa2MyOb2sZseW2dpL6ZnjMzfeQFt/Fe3XP2WIfGvRY6a569jCJ9TaIlcCS9KQE5p1TP2VrMbwLNDlZEvpE5AkGxh9f2nLO/QOetytIwAnMf6SfS2ns+jaZ6B4i2sWvSvF0HWOAj/aRGNFAaPXbw2rS2Rzr0T/ChshKNM3qd4135BCaqK9VAKy+lAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/4DBC0k0jFtF9wAAAAASUVORK5CYII\x3d"), 
    _ = Tt(null, "data:image/png;base64,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\x3d");
    c.kaSprite = Ee;
    c.boomSprite = _;
    s(gt, "fixedUpdateFrame");
    s(Gt, "updateFrame");
    class Ht {
      static $jscomp$static$block$510831985$53() {
        s(this, "Collision");
      }
      constructor(U, Y, se, xe, J = !1) {
        this.resolved = !1;
        this.source = U;
        this.target = Y;
        this.normal = se;
        this.distance = xe;
        this.resolved = J;
      }
      get displacement() {
        return this.normal.scale(this.distance);
      }
      reverse() {
        return new Ht(this.target, this.source, this.normal.scale(-1), this.distance, this.resolved);
      }
      hasOverlap() {
        return !this.displacement.isZero();
      }
      isLeft() {
        return 0 < this.displacement.cross(y.gravity || v(0, 1));
      }
      isRight() {
        return 0 > this.displacement.cross(y.gravity || v(0, 1));
      }
      isTop() {
        return 0 < this.displacement.dot(y.gravity || v(0, 1));
      }
      isBottom() {
        return 0 > this.displacement.dot(y.gravity || v(0, 1));
      }
      preventResolution() {
        this.resolved = !0;
      }
    }
    Ht.$jscomp$static$block$510831985$53();
    s(xn, "checkFrame");
    s(vn, "handleErr");
    s(pr, "onCleanup");
    s(dr, "quit");
    let Mt = !0;
    m.run(() => {
      try {
        g.loaded && (w.paused || gt(), xn());
      } catch (L) {
        vn(L);
      }
    }, (L, U) => {
      try {
        L(), g.loaded || 1 === Fe() && !Mt && (g.loaded = !0, Hn().forEach(Y => y.events.trigger("loadError", ...Y)), y.events.trigger("load")), !g.loaded && !1 !== t.loadingScreen || Mt ? (A(), hi(), G()) : (w.paused || Gt(), xn(), A(), fi(), !1 !== t.debug && di(), G()), Mt && (Mt = !1), y.events.trigger("frameEnd"), U();
      } catch (Y) {
        vn(Y);
      }
    });
    Zn();
    lr();
    let Xe = {_k:c, VERSION:"3001.0.0", loadRoot:Us, loadProgress:Fe, loadSprite:Tt, loadSpriteAtlas:$r, loadSound:si, loadMusic:ii, loadBitmapFont:Zs, loadFont:Qs, loadShader:ni, loadShaderURL:ri, loadAseprite:Xs, loadPedit:ei, loadBean:$s, loadJSON:Hs, load:ln, getSound:Wr, getFont:qr, getBitmapFont:qn, getSprite:Nr, getShader:Yr, getAsset:qs, Asset:le, SpriteData:Le, SoundData:ot, width:ae, height:ce, center:wt, dt:te, fixedDt:an, restDt:un, time:m.time, screenshot:m.screenshot, record:F, isFocused:j, 
    setCursor:m.setCursor, getCursor:m.getCursor, setCursorLocked:m.setCursorLocked, isCursorLocked:m.isCursorLocked, setFullscreen:m.setFullscreen, isFullscreen:m.isFullscreen, isTouchscreen:m.isTouchscreen, onLoad:Nt, onLoadError:Yi, onLoading:Hi, onResize:qi, onGamepadConnect:m.onGamepadConnect, onGamepadDisconnect:m.onGamepadDisconnect, onError:zi, onCleanup:pr, flash:co, setCamPos:ro, getCamPos:oo, setCamRot:ao, getCamRot:uo, setCamScale:so, getCamScale:io, getCamTransform:Wi, camPos:Qi, camScale:Ji, 
    camFlash:ea, camRot:Zi, camTransform:$i, shake:Xi, toScreen:dn, toWorld:ir, setGravity:na, getGravity:ra, setGravityDirection:oa, getGravityDirection:ht, setBackground:js, getBackground:Ks, getGamepads:m.getGamepads, getTreeRoot:fa, add:e, make:fn, destroy:ar, destroyAll:r, get:N, query:X, readd:o, pos:Pt, scale:Ut, rotate:za, color:er, opacity:tr, anchor:gn, area:Da, sprite:hn, text:xa, polygon:Ai, rect:rr, circle:vi, uvquad:va, outline:Ei, particles:Ti, body:Ba, platformEffector:ka, surfaceEffector:La, 
    areaEffector:ja, pointEffector:Ka, buoyancyEffector:_a, constantForce:Ia, doubleJump:Fa, shader:Si, textInput:Ma, timer:bn, fixed:ur, stay:mr, health:Sa, lifespan:Va, named:Pa, state:Ga, z:Ya, layer:Ua, move:Ha, offscreen:qa, follow:Na, fadeIn:wi, mask:Oi, drawon:Ci, raycast:nr, tile:or, animate:Aa, serializeAnimation:yo, agent:Ca, sentry:Ea, patrol:Oa, pathfinder:wa, trigger:Pi, on:Me, onFixedUpdate:Gi, onUpdate:Mi, onDraw:Ri, onAdd:to, onDestroy:Di, onTag:no, onUntag:Li, onUse:Bi, onUnuse:Fi, 
    onClick:ki, onCollide:ji, onCollideUpdate:Ki, onCollideEnd:Ii, onHover:_i, onHoverUpdate:Ni, onHoverEnd:Ui, onKeyDown:m.onKeyDown, onKeyPress:m.onKeyPress, onKeyPressRepeat:m.onKeyPressRepeat, onKeyRelease:m.onKeyRelease, onMouseDown:m.onMouseDown, onMousePress:m.onMousePress, onMouseRelease:m.onMouseRelease, onMouseMove:m.onMouseMove, onCharInput:m.onCharInput, onTouchStart:m.onTouchStart, onTouchMove:m.onTouchMove, onTouchEnd:m.onTouchEnd, onScroll:m.onScroll, onHide:m.onHide, onShow:m.onShow, 
    onGamepadButtonDown:m.onGamepadButtonDown, onGamepadButtonPress:m.onGamepadButtonPress, onGamepadButtonRelease:m.onGamepadButtonRelease, onGamepadStick:m.onGamepadStick, onButtonPress:m.onButtonPress, onButtonDown:m.onButtonDown, onButtonRelease:m.onButtonRelease, mousePos:Un, mouseDeltaPos:m.mouseDeltaPos, isKeyDown:m.isKeyDown, isKeyPressed:m.isKeyPressed, isKeyPressedRepeat:m.isKeyPressedRepeat, isKeyReleased:m.isKeyReleased, isMouseDown:m.isMouseDown, isMousePressed:m.isMousePressed, isMouseReleased:m.isMouseReleased, 
    isMouseMoved:m.isMouseMoved, isGamepadButtonPressed:m.isGamepadButtonPressed, isGamepadButtonDown:m.isGamepadButtonDown, isGamepadButtonReleased:m.isGamepadButtonReleased, getGamepadStick:m.getGamepadStick, isButtonPressed:m.isButtonPressed, isButtonDown:m.isButtonDown, isButtonReleased:m.isButtonReleased, setButton:m.setButton, getButton:m.getButton, pressButton:m.pressButton, releaseButton:m.releaseButton, getLastInputDeviceType:m.getLastInputDeviceType, charInputted:m.charInputted, loop:Z, 
    wait:k, play:ua, setVolume:lo, getVolume:mo, volume:ca, burp:cr, audioCtx:O.ctx, Line:Te, Rect:$, Circle:we, Ellipse:ke, Point:Sn, Polygon:ye, Vec2:E, Color:K, Mat4:he, Quad:z, RNG:Xt, rand:ge, randi:Or, randSeed:Po, vec2:v, rgb:I, hsl2rgb:Ao, quad:me, choose:Ro, chooseMultiple:Mo, shuffle:Er, chance:Go, lerp:fe, tween:ee, easings:nt, map:Ve, mapc:Vo, wave:Vn, deg2rad:ue, rad2deg:lt, clamp:Se, evaluateQuadratic:_o, evaluateQuadraticFirstDerivative:No, evaluateQuadraticSecondDerivative:Uo, evaluateBezier:Jt, 
    evaluateBezierFirstDerivative:Ho, evaluateBezierSecondDerivative:qo, evaluateCatmullRom:zo, evaluateCatmullRomFirstDerivative:Yo, curveLengthApproximation:Pr, normalizedCurve:Wo, hermite:Lt, cardinal:Gr, catmullRom:jt, bezier:$o, kochanekBartels:Xo, easingSteps:es, easingLinear:Jo, easingCubicBezier:Zo, testLineLine:Pn, testRectRect:Tr, testRectLine:Gn, testRectPoint:Bt, testCirclePolygon:Qt, testLinePoint:Mn, testLineCircle:Ft, isConvex:rs, triangulate:Dn, NavMesh:_n, drawSprite:bi, drawText:Zr, 
    formatText:He, drawRect:ve, drawLine:_t, drawLines:kt, drawTriangle:Qn, drawCircle:Ue, drawEllipse:Yn, drawUVQuad:it, drawPolygon:Ge, drawCurve:Wn, drawBezier:ai, drawFormattedText:qe, drawMasked:gi, drawSubtracted:yi, pushTransform:be, popTransform:pe, pushTranslate:Q, pushScale:rt, pushRotate:$e, pushMatrix:Is, usePostEffect:D, makeCanvas:V, debug:w, scene:ha, getSceneName:ya, go:ga, onSceneLeave:ba, layers:da, getLayers:ma, setLayers:fo, getDefaultLayer:pa, addLevel:Vi, getData:S, setData:M, 
    download:Ln, downloadJSON:xs, downloadText:Mr, downloadBlob:Rr, plug:R, ASCII_CHARS:" !\"#$%\x26'()*+,-./0123456789:;\x3c\x3d\x3e?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", canvas:m.canvas, addKaboom:la, LEFT:E.LEFT, RIGHT:E.RIGHT, UP:E.UP, DOWN:E.DOWN, RED:K.RED, GREEN:K.GREEN, BLUE:K.BLUE, YELLOW:K.YELLOW, MAGENTA:K.MAGENTA, CYAN:K.CYAN, WHITE:K.WHITE, BLACK:K.BLACK, quit:dr, KEvent:oe, KEventHandler:Ye, KEventController:_e, cancel:s(() => Fn, "cancel")};
    c.k = Xe;
    e = t.plugins;
    if (e && e.forEach(R), !1 !== t.global) {
      for (let L in Xe) {
        window[L] = Xe[L];
      }
    }
    return !1 !== t.focus && m.canvas.focus(), Xe;
  }, "kaplay");
};

//# sourceMappingURL=module$node_modules$kaplay$dist$kaplay_cjs.js.map
